// Code generated by counterfeiter. DO NOT EDIT.
package smclientfakes

import (
	"io"
	"net/http"
	"sync"

	"github.com/Peripli/service-manager-cli/pkg/query"
	"github.com/Peripli/service-manager-cli/pkg/smclient"
	"github.com/Peripli/service-manager-cli/pkg/types"
)

type FakeClient struct {
	BindStub        func(*types.ServiceBinding, *query.Parameters) (*types.ServiceBinding, string, error)
	bindMutex       sync.RWMutex
	bindArgsForCall []struct {
		arg1 *types.ServiceBinding
		arg2 *query.Parameters
	}
	bindReturns struct {
		result1 *types.ServiceBinding
		result2 string
		result3 error
	}
	bindReturnsOnCall map[int]struct {
		result1 *types.ServiceBinding
		result2 string
		result3 error
	}
	CallStub        func(string, string, io.Reader, *query.Parameters) (*http.Response, error)
	callMutex       sync.RWMutex
	callArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 io.Reader
		arg4 *query.Parameters
	}
	callReturns struct {
		result1 *http.Response
		result2 error
	}
	callReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteBrokerStub        func(string, *query.Parameters) (string, error)
	deleteBrokerMutex       sync.RWMutex
	deleteBrokerArgsForCall []struct {
		arg1 string
		arg2 *query.Parameters
	}
	deleteBrokerReturns struct {
		result1 string
		result2 error
	}
	deleteBrokerReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeletePlatformsStub        func(*query.Parameters) error
	deletePlatformsMutex       sync.RWMutex
	deletePlatformsArgsForCall []struct {
		arg1 *query.Parameters
	}
	deletePlatformsReturns struct {
		result1 error
	}
	deletePlatformsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVisibilitiesStub        func(*query.Parameters) error
	deleteVisibilitiesMutex       sync.RWMutex
	deleteVisibilitiesArgsForCall []struct {
		arg1 *query.Parameters
	}
	deleteVisibilitiesReturns struct {
		result1 error
	}
	deleteVisibilitiesReturnsOnCall map[int]struct {
		result1 error
	}
	DeprovisionStub        func(string, *query.Parameters) (string, error)
	deprovisionMutex       sync.RWMutex
	deprovisionArgsForCall []struct {
		arg1 string
		arg2 *query.Parameters
	}
	deprovisionReturns struct {
		result1 string
		result2 error
	}
	deprovisionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetBindingByIDStub        func(string, *query.Parameters) (*types.ServiceBinding, error)
	getBindingByIDMutex       sync.RWMutex
	getBindingByIDArgsForCall []struct {
		arg1 string
		arg2 *query.Parameters
	}
	getBindingByIDReturns struct {
		result1 *types.ServiceBinding
		result2 error
	}
	getBindingByIDReturnsOnCall map[int]struct {
		result1 *types.ServiceBinding
		result2 error
	}
	GetBrokerByIDStub        func(string, *query.Parameters) (*types.Broker, error)
	getBrokerByIDMutex       sync.RWMutex
	getBrokerByIDArgsForCall []struct {
		arg1 string
		arg2 *query.Parameters
	}
	getBrokerByIDReturns struct {
		result1 *types.Broker
		result2 error
	}
	getBrokerByIDReturnsOnCall map[int]struct {
		result1 *types.Broker
		result2 error
	}
	GetInfoStub        func(*query.Parameters) (*types.Info, error)
	getInfoMutex       sync.RWMutex
	getInfoArgsForCall []struct {
		arg1 *query.Parameters
	}
	getInfoReturns struct {
		result1 *types.Info
		result2 error
	}
	getInfoReturnsOnCall map[int]struct {
		result1 *types.Info
		result2 error
	}
	GetInstanceByIDStub        func(string, *query.Parameters) (*types.ServiceInstance, error)
	getInstanceByIDMutex       sync.RWMutex
	getInstanceByIDArgsForCall []struct {
		arg1 string
		arg2 *query.Parameters
	}
	getInstanceByIDReturns struct {
		result1 *types.ServiceInstance
		result2 error
	}
	getInstanceByIDReturnsOnCall map[int]struct {
		result1 *types.ServiceInstance
		result2 error
	}
	LabelStub        func(string, string, *types.LabelChanges, *query.Parameters) error
	labelMutex       sync.RWMutex
	labelArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *types.LabelChanges
		arg4 *query.Parameters
	}
	labelReturns struct {
		result1 error
	}
	labelReturnsOnCall map[int]struct {
		result1 error
	}
	ListBindingsStub        func(*query.Parameters) (*types.ServiceBindings, error)
	listBindingsMutex       sync.RWMutex
	listBindingsArgsForCall []struct {
		arg1 *query.Parameters
	}
	listBindingsReturns struct {
		result1 *types.ServiceBindings
		result2 error
	}
	listBindingsReturnsOnCall map[int]struct {
		result1 *types.ServiceBindings
		result2 error
	}
	ListBrokersStub        func(*query.Parameters) (*types.Brokers, error)
	listBrokersMutex       sync.RWMutex
	listBrokersArgsForCall []struct {
		arg1 *query.Parameters
	}
	listBrokersReturns struct {
		result1 *types.Brokers
		result2 error
	}
	listBrokersReturnsOnCall map[int]struct {
		result1 *types.Brokers
		result2 error
	}
	ListInstancesStub        func(*query.Parameters) (*types.ServiceInstances, error)
	listInstancesMutex       sync.RWMutex
	listInstancesArgsForCall []struct {
		arg1 *query.Parameters
	}
	listInstancesReturns struct {
		result1 *types.ServiceInstances
		result2 error
	}
	listInstancesReturnsOnCall map[int]struct {
		result1 *types.ServiceInstances
		result2 error
	}
	ListOfferingsStub        func(*query.Parameters) (*types.ServiceOfferings, error)
	listOfferingsMutex       sync.RWMutex
	listOfferingsArgsForCall []struct {
		arg1 *query.Parameters
	}
	listOfferingsReturns struct {
		result1 *types.ServiceOfferings
		result2 error
	}
	listOfferingsReturnsOnCall map[int]struct {
		result1 *types.ServiceOfferings
		result2 error
	}
	ListPlansStub        func(*query.Parameters) (*types.ServicePlans, error)
	listPlansMutex       sync.RWMutex
	listPlansArgsForCall []struct {
		arg1 *query.Parameters
	}
	listPlansReturns struct {
		result1 *types.ServicePlans
		result2 error
	}
	listPlansReturnsOnCall map[int]struct {
		result1 *types.ServicePlans
		result2 error
	}
	ListPlatformsStub        func(*query.Parameters) (*types.Platforms, error)
	listPlatformsMutex       sync.RWMutex
	listPlatformsArgsForCall []struct {
		arg1 *query.Parameters
	}
	listPlatformsReturns struct {
		result1 *types.Platforms
		result2 error
	}
	listPlatformsReturnsOnCall map[int]struct {
		result1 *types.Platforms
		result2 error
	}
	ListVisibilitiesStub        func(*query.Parameters) (*types.Visibilities, error)
	listVisibilitiesMutex       sync.RWMutex
	listVisibilitiesArgsForCall []struct {
		arg1 *query.Parameters
	}
	listVisibilitiesReturns struct {
		result1 *types.Visibilities
		result2 error
	}
	listVisibilitiesReturnsOnCall map[int]struct {
		result1 *types.Visibilities
		result2 error
	}
	MarketplaceStub        func(*query.Parameters) (*types.Marketplace, error)
	marketplaceMutex       sync.RWMutex
	marketplaceArgsForCall []struct {
		arg1 *query.Parameters
	}
	marketplaceReturns struct {
		result1 *types.Marketplace
		result2 error
	}
	marketplaceReturnsOnCall map[int]struct {
		result1 *types.Marketplace
		result2 error
	}
	ProvisionStub        func(*types.ServiceInstance, *query.Parameters) (*types.ServiceInstance, string, error)
	provisionMutex       sync.RWMutex
	provisionArgsForCall []struct {
		arg1 *types.ServiceInstance
		arg2 *query.Parameters
	}
	provisionReturns struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}
	provisionReturnsOnCall map[int]struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}
	RegisterBrokerStub        func(*types.Broker, *query.Parameters) (*types.Broker, string, error)
	registerBrokerMutex       sync.RWMutex
	registerBrokerArgsForCall []struct {
		arg1 *types.Broker
		arg2 *query.Parameters
	}
	registerBrokerReturns struct {
		result1 *types.Broker
		result2 string
		result3 error
	}
	registerBrokerReturnsOnCall map[int]struct {
		result1 *types.Broker
		result2 string
		result3 error
	}
	RegisterPlatformStub        func(*types.Platform, *query.Parameters) (*types.Platform, error)
	registerPlatformMutex       sync.RWMutex
	registerPlatformArgsForCall []struct {
		arg1 *types.Platform
		arg2 *query.Parameters
	}
	registerPlatformReturns struct {
		result1 *types.Platform
		result2 error
	}
	registerPlatformReturnsOnCall map[int]struct {
		result1 *types.Platform
		result2 error
	}
	RegisterVisibilityStub        func(*types.Visibility, *query.Parameters) (*types.Visibility, error)
	registerVisibilityMutex       sync.RWMutex
	registerVisibilityArgsForCall []struct {
		arg1 *types.Visibility
		arg2 *query.Parameters
	}
	registerVisibilityReturns struct {
		result1 *types.Visibility
		result2 error
	}
	registerVisibilityReturnsOnCall map[int]struct {
		result1 *types.Visibility
		result2 error
	}
	StatusStub        func(string, *query.Parameters) (*types.Operation, error)
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
		arg1 string
		arg2 *query.Parameters
	}
	statusReturns struct {
		result1 *types.Operation
		result2 error
	}
	statusReturnsOnCall map[int]struct {
		result1 *types.Operation
		result2 error
	}
	UnbindStub        func(string, *query.Parameters) (string, error)
	unbindMutex       sync.RWMutex
	unbindArgsForCall []struct {
		arg1 string
		arg2 *query.Parameters
	}
	unbindReturns struct {
		result1 string
		result2 error
	}
	unbindReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UpdateBrokerStub        func(string, *types.Broker, *query.Parameters) (*types.Broker, string, error)
	updateBrokerMutex       sync.RWMutex
	updateBrokerArgsForCall []struct {
		arg1 string
		arg2 *types.Broker
		arg3 *query.Parameters
	}
	updateBrokerReturns struct {
		result1 *types.Broker
		result2 string
		result3 error
	}
	updateBrokerReturnsOnCall map[int]struct {
		result1 *types.Broker
		result2 string
		result3 error
	}
	UpdateInstanceStub        func(string, *types.ServiceInstance, *query.Parameters) (*types.ServiceInstance, string, error)
	updateInstanceMutex       sync.RWMutex
	updateInstanceArgsForCall []struct {
		arg1 string
		arg2 *types.ServiceInstance
		arg3 *query.Parameters
	}
	updateInstanceReturns struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}
	updateInstanceReturnsOnCall map[int]struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}
	UpdatePlatformStub        func(string, *types.Platform, *query.Parameters) (*types.Platform, error)
	updatePlatformMutex       sync.RWMutex
	updatePlatformArgsForCall []struct {
		arg1 string
		arg2 *types.Platform
		arg3 *query.Parameters
	}
	updatePlatformReturns struct {
		result1 *types.Platform
		result2 error
	}
	updatePlatformReturnsOnCall map[int]struct {
		result1 *types.Platform
		result2 error
	}
	UpdateVisibilityStub        func(string, *types.Visibility, *query.Parameters) (*types.Visibility, error)
	updateVisibilityMutex       sync.RWMutex
	updateVisibilityArgsForCall []struct {
		arg1 string
		arg2 *types.Visibility
		arg3 *query.Parameters
	}
	updateVisibilityReturns struct {
		result1 *types.Visibility
		result2 error
	}
	updateVisibilityReturnsOnCall map[int]struct {
		result1 *types.Visibility
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Bind(arg1 *types.ServiceBinding, arg2 *query.Parameters) (*types.ServiceBinding, string, error) {
	fake.bindMutex.Lock()
	ret, specificReturn := fake.bindReturnsOnCall[len(fake.bindArgsForCall)]
	fake.bindArgsForCall = append(fake.bindArgsForCall, struct {
		arg1 *types.ServiceBinding
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("Bind", []interface{}{arg1, arg2})
	fake.bindMutex.Unlock()
	if fake.BindStub != nil {
		return fake.BindStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.bindReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) BindCallCount() int {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return len(fake.bindArgsForCall)
}

func (fake *FakeClient) BindCalls(stub func(*types.ServiceBinding, *query.Parameters) (*types.ServiceBinding, string, error)) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = stub
}

func (fake *FakeClient) BindArgsForCall(i int) (*types.ServiceBinding, *query.Parameters) {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	argsForCall := fake.bindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) BindReturns(result1 *types.ServiceBinding, result2 string, result3 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	fake.bindReturns = struct {
		result1 *types.ServiceBinding
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) BindReturnsOnCall(i int, result1 *types.ServiceBinding, result2 string, result3 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	if fake.bindReturnsOnCall == nil {
		fake.bindReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceBinding
			result2 string
			result3 error
		})
	}
	fake.bindReturnsOnCall[i] = struct {
		result1 *types.ServiceBinding
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) Call(arg1 string, arg2 string, arg3 io.Reader, arg4 *query.Parameters) (*http.Response, error) {
	fake.callMutex.Lock()
	ret, specificReturn := fake.callReturnsOnCall[len(fake.callArgsForCall)]
	fake.callArgsForCall = append(fake.callArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 io.Reader
		arg4 *query.Parameters
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Call", []interface{}{arg1, arg2, arg3, arg4})
	fake.callMutex.Unlock()
	if fake.CallStub != nil {
		return fake.CallStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.callReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CallCallCount() int {
	fake.callMutex.RLock()
	defer fake.callMutex.RUnlock()
	return len(fake.callArgsForCall)
}

func (fake *FakeClient) CallCalls(stub func(string, string, io.Reader, *query.Parameters) (*http.Response, error)) {
	fake.callMutex.Lock()
	defer fake.callMutex.Unlock()
	fake.CallStub = stub
}

func (fake *FakeClient) CallArgsForCall(i int) (string, string, io.Reader, *query.Parameters) {
	fake.callMutex.RLock()
	defer fake.callMutex.RUnlock()
	argsForCall := fake.callArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CallReturns(result1 *http.Response, result2 error) {
	fake.callMutex.Lock()
	defer fake.callMutex.Unlock()
	fake.CallStub = nil
	fake.callReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CallReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.callMutex.Lock()
	defer fake.callMutex.Unlock()
	fake.CallStub = nil
	if fake.callReturnsOnCall == nil {
		fake.callReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.callReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteBroker(arg1 string, arg2 *query.Parameters) (string, error) {
	fake.deleteBrokerMutex.Lock()
	ret, specificReturn := fake.deleteBrokerReturnsOnCall[len(fake.deleteBrokerArgsForCall)]
	fake.deleteBrokerArgsForCall = append(fake.deleteBrokerArgsForCall, struct {
		arg1 string
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("DeleteBroker", []interface{}{arg1, arg2})
	fake.deleteBrokerMutex.Unlock()
	if fake.DeleteBrokerStub != nil {
		return fake.DeleteBrokerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteBrokerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeleteBrokerCallCount() int {
	fake.deleteBrokerMutex.RLock()
	defer fake.deleteBrokerMutex.RUnlock()
	return len(fake.deleteBrokerArgsForCall)
}

func (fake *FakeClient) DeleteBrokerCalls(stub func(string, *query.Parameters) (string, error)) {
	fake.deleteBrokerMutex.Lock()
	defer fake.deleteBrokerMutex.Unlock()
	fake.DeleteBrokerStub = stub
}

func (fake *FakeClient) DeleteBrokerArgsForCall(i int) (string, *query.Parameters) {
	fake.deleteBrokerMutex.RLock()
	defer fake.deleteBrokerMutex.RUnlock()
	argsForCall := fake.deleteBrokerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DeleteBrokerReturns(result1 string, result2 error) {
	fake.deleteBrokerMutex.Lock()
	defer fake.deleteBrokerMutex.Unlock()
	fake.DeleteBrokerStub = nil
	fake.deleteBrokerReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteBrokerReturnsOnCall(i int, result1 string, result2 error) {
	fake.deleteBrokerMutex.Lock()
	defer fake.deleteBrokerMutex.Unlock()
	fake.DeleteBrokerStub = nil
	if fake.deleteBrokerReturnsOnCall == nil {
		fake.deleteBrokerReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.deleteBrokerReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeletePlatforms(arg1 *query.Parameters) error {
	fake.deletePlatformsMutex.Lock()
	ret, specificReturn := fake.deletePlatformsReturnsOnCall[len(fake.deletePlatformsArgsForCall)]
	fake.deletePlatformsArgsForCall = append(fake.deletePlatformsArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("DeletePlatforms", []interface{}{arg1})
	fake.deletePlatformsMutex.Unlock()
	if fake.DeletePlatformsStub != nil {
		return fake.DeletePlatformsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deletePlatformsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeletePlatformsCallCount() int {
	fake.deletePlatformsMutex.RLock()
	defer fake.deletePlatformsMutex.RUnlock()
	return len(fake.deletePlatformsArgsForCall)
}

func (fake *FakeClient) DeletePlatformsCalls(stub func(*query.Parameters) error) {
	fake.deletePlatformsMutex.Lock()
	defer fake.deletePlatformsMutex.Unlock()
	fake.DeletePlatformsStub = stub
}

func (fake *FakeClient) DeletePlatformsArgsForCall(i int) *query.Parameters {
	fake.deletePlatformsMutex.RLock()
	defer fake.deletePlatformsMutex.RUnlock()
	argsForCall := fake.deletePlatformsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeletePlatformsReturns(result1 error) {
	fake.deletePlatformsMutex.Lock()
	defer fake.deletePlatformsMutex.Unlock()
	fake.DeletePlatformsStub = nil
	fake.deletePlatformsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeletePlatformsReturnsOnCall(i int, result1 error) {
	fake.deletePlatformsMutex.Lock()
	defer fake.deletePlatformsMutex.Unlock()
	fake.DeletePlatformsStub = nil
	if fake.deletePlatformsReturnsOnCall == nil {
		fake.deletePlatformsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePlatformsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteVisibilities(arg1 *query.Parameters) error {
	fake.deleteVisibilitiesMutex.Lock()
	ret, specificReturn := fake.deleteVisibilitiesReturnsOnCall[len(fake.deleteVisibilitiesArgsForCall)]
	fake.deleteVisibilitiesArgsForCall = append(fake.deleteVisibilitiesArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("DeleteVisibilities", []interface{}{arg1})
	fake.deleteVisibilitiesMutex.Unlock()
	if fake.DeleteVisibilitiesStub != nil {
		return fake.DeleteVisibilitiesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteVisibilitiesReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteVisibilitiesCallCount() int {
	fake.deleteVisibilitiesMutex.RLock()
	defer fake.deleteVisibilitiesMutex.RUnlock()
	return len(fake.deleteVisibilitiesArgsForCall)
}

func (fake *FakeClient) DeleteVisibilitiesCalls(stub func(*query.Parameters) error) {
	fake.deleteVisibilitiesMutex.Lock()
	defer fake.deleteVisibilitiesMutex.Unlock()
	fake.DeleteVisibilitiesStub = stub
}

func (fake *FakeClient) DeleteVisibilitiesArgsForCall(i int) *query.Parameters {
	fake.deleteVisibilitiesMutex.RLock()
	defer fake.deleteVisibilitiesMutex.RUnlock()
	argsForCall := fake.deleteVisibilitiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteVisibilitiesReturns(result1 error) {
	fake.deleteVisibilitiesMutex.Lock()
	defer fake.deleteVisibilitiesMutex.Unlock()
	fake.DeleteVisibilitiesStub = nil
	fake.deleteVisibilitiesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteVisibilitiesReturnsOnCall(i int, result1 error) {
	fake.deleteVisibilitiesMutex.Lock()
	defer fake.deleteVisibilitiesMutex.Unlock()
	fake.DeleteVisibilitiesStub = nil
	if fake.deleteVisibilitiesReturnsOnCall == nil {
		fake.deleteVisibilitiesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVisibilitiesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Deprovision(arg1 string, arg2 *query.Parameters) (string, error) {
	fake.deprovisionMutex.Lock()
	ret, specificReturn := fake.deprovisionReturnsOnCall[len(fake.deprovisionArgsForCall)]
	fake.deprovisionArgsForCall = append(fake.deprovisionArgsForCall, struct {
		arg1 string
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("Deprovision", []interface{}{arg1, arg2})
	fake.deprovisionMutex.Unlock()
	if fake.DeprovisionStub != nil {
		return fake.DeprovisionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deprovisionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeprovisionCallCount() int {
	fake.deprovisionMutex.RLock()
	defer fake.deprovisionMutex.RUnlock()
	return len(fake.deprovisionArgsForCall)
}

func (fake *FakeClient) DeprovisionCalls(stub func(string, *query.Parameters) (string, error)) {
	fake.deprovisionMutex.Lock()
	defer fake.deprovisionMutex.Unlock()
	fake.DeprovisionStub = stub
}

func (fake *FakeClient) DeprovisionArgsForCall(i int) (string, *query.Parameters) {
	fake.deprovisionMutex.RLock()
	defer fake.deprovisionMutex.RUnlock()
	argsForCall := fake.deprovisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DeprovisionReturns(result1 string, result2 error) {
	fake.deprovisionMutex.Lock()
	defer fake.deprovisionMutex.Unlock()
	fake.DeprovisionStub = nil
	fake.deprovisionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeprovisionReturnsOnCall(i int, result1 string, result2 error) {
	fake.deprovisionMutex.Lock()
	defer fake.deprovisionMutex.Unlock()
	fake.DeprovisionStub = nil
	if fake.deprovisionReturnsOnCall == nil {
		fake.deprovisionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.deprovisionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBindingByID(arg1 string, arg2 *query.Parameters) (*types.ServiceBinding, error) {
	fake.getBindingByIDMutex.Lock()
	ret, specificReturn := fake.getBindingByIDReturnsOnCall[len(fake.getBindingByIDArgsForCall)]
	fake.getBindingByIDArgsForCall = append(fake.getBindingByIDArgsForCall, struct {
		arg1 string
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("GetBindingByID", []interface{}{arg1, arg2})
	fake.getBindingByIDMutex.Unlock()
	if fake.GetBindingByIDStub != nil {
		return fake.GetBindingByIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBindingByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetBindingByIDCallCount() int {
	fake.getBindingByIDMutex.RLock()
	defer fake.getBindingByIDMutex.RUnlock()
	return len(fake.getBindingByIDArgsForCall)
}

func (fake *FakeClient) GetBindingByIDCalls(stub func(string, *query.Parameters) (*types.ServiceBinding, error)) {
	fake.getBindingByIDMutex.Lock()
	defer fake.getBindingByIDMutex.Unlock()
	fake.GetBindingByIDStub = stub
}

func (fake *FakeClient) GetBindingByIDArgsForCall(i int) (string, *query.Parameters) {
	fake.getBindingByIDMutex.RLock()
	defer fake.getBindingByIDMutex.RUnlock()
	argsForCall := fake.getBindingByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetBindingByIDReturns(result1 *types.ServiceBinding, result2 error) {
	fake.getBindingByIDMutex.Lock()
	defer fake.getBindingByIDMutex.Unlock()
	fake.GetBindingByIDStub = nil
	fake.getBindingByIDReturns = struct {
		result1 *types.ServiceBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBindingByIDReturnsOnCall(i int, result1 *types.ServiceBinding, result2 error) {
	fake.getBindingByIDMutex.Lock()
	defer fake.getBindingByIDMutex.Unlock()
	fake.GetBindingByIDStub = nil
	if fake.getBindingByIDReturnsOnCall == nil {
		fake.getBindingByIDReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceBinding
			result2 error
		})
	}
	fake.getBindingByIDReturnsOnCall[i] = struct {
		result1 *types.ServiceBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBrokerByID(arg1 string, arg2 *query.Parameters) (*types.Broker, error) {
	fake.getBrokerByIDMutex.Lock()
	ret, specificReturn := fake.getBrokerByIDReturnsOnCall[len(fake.getBrokerByIDArgsForCall)]
	fake.getBrokerByIDArgsForCall = append(fake.getBrokerByIDArgsForCall, struct {
		arg1 string
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("GetBrokerByID", []interface{}{arg1, arg2})
	fake.getBrokerByIDMutex.Unlock()
	if fake.GetBrokerByIDStub != nil {
		return fake.GetBrokerByIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBrokerByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetBrokerByIDCallCount() int {
	fake.getBrokerByIDMutex.RLock()
	defer fake.getBrokerByIDMutex.RUnlock()
	return len(fake.getBrokerByIDArgsForCall)
}

func (fake *FakeClient) GetBrokerByIDCalls(stub func(string, *query.Parameters) (*types.Broker, error)) {
	fake.getBrokerByIDMutex.Lock()
	defer fake.getBrokerByIDMutex.Unlock()
	fake.GetBrokerByIDStub = stub
}

func (fake *FakeClient) GetBrokerByIDArgsForCall(i int) (string, *query.Parameters) {
	fake.getBrokerByIDMutex.RLock()
	defer fake.getBrokerByIDMutex.RUnlock()
	argsForCall := fake.getBrokerByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetBrokerByIDReturns(result1 *types.Broker, result2 error) {
	fake.getBrokerByIDMutex.Lock()
	defer fake.getBrokerByIDMutex.Unlock()
	fake.GetBrokerByIDStub = nil
	fake.getBrokerByIDReturns = struct {
		result1 *types.Broker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetBrokerByIDReturnsOnCall(i int, result1 *types.Broker, result2 error) {
	fake.getBrokerByIDMutex.Lock()
	defer fake.getBrokerByIDMutex.Unlock()
	fake.GetBrokerByIDStub = nil
	if fake.getBrokerByIDReturnsOnCall == nil {
		fake.getBrokerByIDReturnsOnCall = make(map[int]struct {
			result1 *types.Broker
			result2 error
		})
	}
	fake.getBrokerByIDReturnsOnCall[i] = struct {
		result1 *types.Broker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInfo(arg1 *query.Parameters) (*types.Info, error) {
	fake.getInfoMutex.Lock()
	ret, specificReturn := fake.getInfoReturnsOnCall[len(fake.getInfoArgsForCall)]
	fake.getInfoArgsForCall = append(fake.getInfoArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("GetInfo", []interface{}{arg1})
	fake.getInfoMutex.Unlock()
	if fake.GetInfoStub != nil {
		return fake.GetInfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetInfoCallCount() int {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	return len(fake.getInfoArgsForCall)
}

func (fake *FakeClient) GetInfoCalls(stub func(*query.Parameters) (*types.Info, error)) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = stub
}

func (fake *FakeClient) GetInfoArgsForCall(i int) *query.Parameters {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	argsForCall := fake.getInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetInfoReturns(result1 *types.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	fake.getInfoReturns = struct {
		result1 *types.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInfoReturnsOnCall(i int, result1 *types.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	if fake.getInfoReturnsOnCall == nil {
		fake.getInfoReturnsOnCall = make(map[int]struct {
			result1 *types.Info
			result2 error
		})
	}
	fake.getInfoReturnsOnCall[i] = struct {
		result1 *types.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceByID(arg1 string, arg2 *query.Parameters) (*types.ServiceInstance, error) {
	fake.getInstanceByIDMutex.Lock()
	ret, specificReturn := fake.getInstanceByIDReturnsOnCall[len(fake.getInstanceByIDArgsForCall)]
	fake.getInstanceByIDArgsForCall = append(fake.getInstanceByIDArgsForCall, struct {
		arg1 string
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("GetInstanceByID", []interface{}{arg1, arg2})
	fake.getInstanceByIDMutex.Unlock()
	if fake.GetInstanceByIDStub != nil {
		return fake.GetInstanceByIDStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInstanceByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetInstanceByIDCallCount() int {
	fake.getInstanceByIDMutex.RLock()
	defer fake.getInstanceByIDMutex.RUnlock()
	return len(fake.getInstanceByIDArgsForCall)
}

func (fake *FakeClient) GetInstanceByIDCalls(stub func(string, *query.Parameters) (*types.ServiceInstance, error)) {
	fake.getInstanceByIDMutex.Lock()
	defer fake.getInstanceByIDMutex.Unlock()
	fake.GetInstanceByIDStub = stub
}

func (fake *FakeClient) GetInstanceByIDArgsForCall(i int) (string, *query.Parameters) {
	fake.getInstanceByIDMutex.RLock()
	defer fake.getInstanceByIDMutex.RUnlock()
	argsForCall := fake.getInstanceByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetInstanceByIDReturns(result1 *types.ServiceInstance, result2 error) {
	fake.getInstanceByIDMutex.Lock()
	defer fake.getInstanceByIDMutex.Unlock()
	fake.GetInstanceByIDStub = nil
	fake.getInstanceByIDReturns = struct {
		result1 *types.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInstanceByIDReturnsOnCall(i int, result1 *types.ServiceInstance, result2 error) {
	fake.getInstanceByIDMutex.Lock()
	defer fake.getInstanceByIDMutex.Unlock()
	fake.GetInstanceByIDStub = nil
	if fake.getInstanceByIDReturnsOnCall == nil {
		fake.getInstanceByIDReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceInstance
			result2 error
		})
	}
	fake.getInstanceByIDReturnsOnCall[i] = struct {
		result1 *types.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Label(arg1 string, arg2 string, arg3 *types.LabelChanges, arg4 *query.Parameters) error {
	fake.labelMutex.Lock()
	ret, specificReturn := fake.labelReturnsOnCall[len(fake.labelArgsForCall)]
	fake.labelArgsForCall = append(fake.labelArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *types.LabelChanges
		arg4 *query.Parameters
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Label", []interface{}{arg1, arg2, arg3, arg4})
	fake.labelMutex.Unlock()
	if fake.LabelStub != nil {
		return fake.LabelStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.labelReturns
	return fakeReturns.result1
}

func (fake *FakeClient) LabelCallCount() int {
	fake.labelMutex.RLock()
	defer fake.labelMutex.RUnlock()
	return len(fake.labelArgsForCall)
}

func (fake *FakeClient) LabelCalls(stub func(string, string, *types.LabelChanges, *query.Parameters) error) {
	fake.labelMutex.Lock()
	defer fake.labelMutex.Unlock()
	fake.LabelStub = stub
}

func (fake *FakeClient) LabelArgsForCall(i int) (string, string, *types.LabelChanges, *query.Parameters) {
	fake.labelMutex.RLock()
	defer fake.labelMutex.RUnlock()
	argsForCall := fake.labelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LabelReturns(result1 error) {
	fake.labelMutex.Lock()
	defer fake.labelMutex.Unlock()
	fake.LabelStub = nil
	fake.labelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) LabelReturnsOnCall(i int, result1 error) {
	fake.labelMutex.Lock()
	defer fake.labelMutex.Unlock()
	fake.LabelStub = nil
	if fake.labelReturnsOnCall == nil {
		fake.labelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.labelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ListBindings(arg1 *query.Parameters) (*types.ServiceBindings, error) {
	fake.listBindingsMutex.Lock()
	ret, specificReturn := fake.listBindingsReturnsOnCall[len(fake.listBindingsArgsForCall)]
	fake.listBindingsArgsForCall = append(fake.listBindingsArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListBindings", []interface{}{arg1})
	fake.listBindingsMutex.Unlock()
	if fake.ListBindingsStub != nil {
		return fake.ListBindingsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listBindingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListBindingsCallCount() int {
	fake.listBindingsMutex.RLock()
	defer fake.listBindingsMutex.RUnlock()
	return len(fake.listBindingsArgsForCall)
}

func (fake *FakeClient) ListBindingsCalls(stub func(*query.Parameters) (*types.ServiceBindings, error)) {
	fake.listBindingsMutex.Lock()
	defer fake.listBindingsMutex.Unlock()
	fake.ListBindingsStub = stub
}

func (fake *FakeClient) ListBindingsArgsForCall(i int) *query.Parameters {
	fake.listBindingsMutex.RLock()
	defer fake.listBindingsMutex.RUnlock()
	argsForCall := fake.listBindingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListBindingsReturns(result1 *types.ServiceBindings, result2 error) {
	fake.listBindingsMutex.Lock()
	defer fake.listBindingsMutex.Unlock()
	fake.ListBindingsStub = nil
	fake.listBindingsReturns = struct {
		result1 *types.ServiceBindings
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListBindingsReturnsOnCall(i int, result1 *types.ServiceBindings, result2 error) {
	fake.listBindingsMutex.Lock()
	defer fake.listBindingsMutex.Unlock()
	fake.ListBindingsStub = nil
	if fake.listBindingsReturnsOnCall == nil {
		fake.listBindingsReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceBindings
			result2 error
		})
	}
	fake.listBindingsReturnsOnCall[i] = struct {
		result1 *types.ServiceBindings
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListBrokers(arg1 *query.Parameters) (*types.Brokers, error) {
	fake.listBrokersMutex.Lock()
	ret, specificReturn := fake.listBrokersReturnsOnCall[len(fake.listBrokersArgsForCall)]
	fake.listBrokersArgsForCall = append(fake.listBrokersArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListBrokers", []interface{}{arg1})
	fake.listBrokersMutex.Unlock()
	if fake.ListBrokersStub != nil {
		return fake.ListBrokersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listBrokersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListBrokersCallCount() int {
	fake.listBrokersMutex.RLock()
	defer fake.listBrokersMutex.RUnlock()
	return len(fake.listBrokersArgsForCall)
}

func (fake *FakeClient) ListBrokersCalls(stub func(*query.Parameters) (*types.Brokers, error)) {
	fake.listBrokersMutex.Lock()
	defer fake.listBrokersMutex.Unlock()
	fake.ListBrokersStub = stub
}

func (fake *FakeClient) ListBrokersArgsForCall(i int) *query.Parameters {
	fake.listBrokersMutex.RLock()
	defer fake.listBrokersMutex.RUnlock()
	argsForCall := fake.listBrokersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListBrokersReturns(result1 *types.Brokers, result2 error) {
	fake.listBrokersMutex.Lock()
	defer fake.listBrokersMutex.Unlock()
	fake.ListBrokersStub = nil
	fake.listBrokersReturns = struct {
		result1 *types.Brokers
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListBrokersReturnsOnCall(i int, result1 *types.Brokers, result2 error) {
	fake.listBrokersMutex.Lock()
	defer fake.listBrokersMutex.Unlock()
	fake.ListBrokersStub = nil
	if fake.listBrokersReturnsOnCall == nil {
		fake.listBrokersReturnsOnCall = make(map[int]struct {
			result1 *types.Brokers
			result2 error
		})
	}
	fake.listBrokersReturnsOnCall[i] = struct {
		result1 *types.Brokers
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListInstances(arg1 *query.Parameters) (*types.ServiceInstances, error) {
	fake.listInstancesMutex.Lock()
	ret, specificReturn := fake.listInstancesReturnsOnCall[len(fake.listInstancesArgsForCall)]
	fake.listInstancesArgsForCall = append(fake.listInstancesArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListInstances", []interface{}{arg1})
	fake.listInstancesMutex.Unlock()
	if fake.ListInstancesStub != nil {
		return fake.ListInstancesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listInstancesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListInstancesCallCount() int {
	fake.listInstancesMutex.RLock()
	defer fake.listInstancesMutex.RUnlock()
	return len(fake.listInstancesArgsForCall)
}

func (fake *FakeClient) ListInstancesCalls(stub func(*query.Parameters) (*types.ServiceInstances, error)) {
	fake.listInstancesMutex.Lock()
	defer fake.listInstancesMutex.Unlock()
	fake.ListInstancesStub = stub
}

func (fake *FakeClient) ListInstancesArgsForCall(i int) *query.Parameters {
	fake.listInstancesMutex.RLock()
	defer fake.listInstancesMutex.RUnlock()
	argsForCall := fake.listInstancesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListInstancesReturns(result1 *types.ServiceInstances, result2 error) {
	fake.listInstancesMutex.Lock()
	defer fake.listInstancesMutex.Unlock()
	fake.ListInstancesStub = nil
	fake.listInstancesReturns = struct {
		result1 *types.ServiceInstances
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListInstancesReturnsOnCall(i int, result1 *types.ServiceInstances, result2 error) {
	fake.listInstancesMutex.Lock()
	defer fake.listInstancesMutex.Unlock()
	fake.ListInstancesStub = nil
	if fake.listInstancesReturnsOnCall == nil {
		fake.listInstancesReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceInstances
			result2 error
		})
	}
	fake.listInstancesReturnsOnCall[i] = struct {
		result1 *types.ServiceInstances
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOfferings(arg1 *query.Parameters) (*types.ServiceOfferings, error) {
	fake.listOfferingsMutex.Lock()
	ret, specificReturn := fake.listOfferingsReturnsOnCall[len(fake.listOfferingsArgsForCall)]
	fake.listOfferingsArgsForCall = append(fake.listOfferingsArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListOfferings", []interface{}{arg1})
	fake.listOfferingsMutex.Unlock()
	if fake.ListOfferingsStub != nil {
		return fake.ListOfferingsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listOfferingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOfferingsCallCount() int {
	fake.listOfferingsMutex.RLock()
	defer fake.listOfferingsMutex.RUnlock()
	return len(fake.listOfferingsArgsForCall)
}

func (fake *FakeClient) ListOfferingsCalls(stub func(*query.Parameters) (*types.ServiceOfferings, error)) {
	fake.listOfferingsMutex.Lock()
	defer fake.listOfferingsMutex.Unlock()
	fake.ListOfferingsStub = stub
}

func (fake *FakeClient) ListOfferingsArgsForCall(i int) *query.Parameters {
	fake.listOfferingsMutex.RLock()
	defer fake.listOfferingsMutex.RUnlock()
	argsForCall := fake.listOfferingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListOfferingsReturns(result1 *types.ServiceOfferings, result2 error) {
	fake.listOfferingsMutex.Lock()
	defer fake.listOfferingsMutex.Unlock()
	fake.ListOfferingsStub = nil
	fake.listOfferingsReturns = struct {
		result1 *types.ServiceOfferings
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOfferingsReturnsOnCall(i int, result1 *types.ServiceOfferings, result2 error) {
	fake.listOfferingsMutex.Lock()
	defer fake.listOfferingsMutex.Unlock()
	fake.ListOfferingsStub = nil
	if fake.listOfferingsReturnsOnCall == nil {
		fake.listOfferingsReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceOfferings
			result2 error
		})
	}
	fake.listOfferingsReturnsOnCall[i] = struct {
		result1 *types.ServiceOfferings
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlans(arg1 *query.Parameters) (*types.ServicePlans, error) {
	fake.listPlansMutex.Lock()
	ret, specificReturn := fake.listPlansReturnsOnCall[len(fake.listPlansArgsForCall)]
	fake.listPlansArgsForCall = append(fake.listPlansArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListPlans", []interface{}{arg1})
	fake.listPlansMutex.Unlock()
	if fake.ListPlansStub != nil {
		return fake.ListPlansStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPlansReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListPlansCallCount() int {
	fake.listPlansMutex.RLock()
	defer fake.listPlansMutex.RUnlock()
	return len(fake.listPlansArgsForCall)
}

func (fake *FakeClient) ListPlansCalls(stub func(*query.Parameters) (*types.ServicePlans, error)) {
	fake.listPlansMutex.Lock()
	defer fake.listPlansMutex.Unlock()
	fake.ListPlansStub = stub
}

func (fake *FakeClient) ListPlansArgsForCall(i int) *query.Parameters {
	fake.listPlansMutex.RLock()
	defer fake.listPlansMutex.RUnlock()
	argsForCall := fake.listPlansArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListPlansReturns(result1 *types.ServicePlans, result2 error) {
	fake.listPlansMutex.Lock()
	defer fake.listPlansMutex.Unlock()
	fake.ListPlansStub = nil
	fake.listPlansReturns = struct {
		result1 *types.ServicePlans
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlansReturnsOnCall(i int, result1 *types.ServicePlans, result2 error) {
	fake.listPlansMutex.Lock()
	defer fake.listPlansMutex.Unlock()
	fake.ListPlansStub = nil
	if fake.listPlansReturnsOnCall == nil {
		fake.listPlansReturnsOnCall = make(map[int]struct {
			result1 *types.ServicePlans
			result2 error
		})
	}
	fake.listPlansReturnsOnCall[i] = struct {
		result1 *types.ServicePlans
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlatforms(arg1 *query.Parameters) (*types.Platforms, error) {
	fake.listPlatformsMutex.Lock()
	ret, specificReturn := fake.listPlatformsReturnsOnCall[len(fake.listPlatformsArgsForCall)]
	fake.listPlatformsArgsForCall = append(fake.listPlatformsArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListPlatforms", []interface{}{arg1})
	fake.listPlatformsMutex.Unlock()
	if fake.ListPlatformsStub != nil {
		return fake.ListPlatformsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPlatformsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListPlatformsCallCount() int {
	fake.listPlatformsMutex.RLock()
	defer fake.listPlatformsMutex.RUnlock()
	return len(fake.listPlatformsArgsForCall)
}

func (fake *FakeClient) ListPlatformsCalls(stub func(*query.Parameters) (*types.Platforms, error)) {
	fake.listPlatformsMutex.Lock()
	defer fake.listPlatformsMutex.Unlock()
	fake.ListPlatformsStub = stub
}

func (fake *FakeClient) ListPlatformsArgsForCall(i int) *query.Parameters {
	fake.listPlatformsMutex.RLock()
	defer fake.listPlatformsMutex.RUnlock()
	argsForCall := fake.listPlatformsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListPlatformsReturns(result1 *types.Platforms, result2 error) {
	fake.listPlatformsMutex.Lock()
	defer fake.listPlatformsMutex.Unlock()
	fake.ListPlatformsStub = nil
	fake.listPlatformsReturns = struct {
		result1 *types.Platforms
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlatformsReturnsOnCall(i int, result1 *types.Platforms, result2 error) {
	fake.listPlatformsMutex.Lock()
	defer fake.listPlatformsMutex.Unlock()
	fake.ListPlatformsStub = nil
	if fake.listPlatformsReturnsOnCall == nil {
		fake.listPlatformsReturnsOnCall = make(map[int]struct {
			result1 *types.Platforms
			result2 error
		})
	}
	fake.listPlatformsReturnsOnCall[i] = struct {
		result1 *types.Platforms
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListVisibilities(arg1 *query.Parameters) (*types.Visibilities, error) {
	fake.listVisibilitiesMutex.Lock()
	ret, specificReturn := fake.listVisibilitiesReturnsOnCall[len(fake.listVisibilitiesArgsForCall)]
	fake.listVisibilitiesArgsForCall = append(fake.listVisibilitiesArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListVisibilities", []interface{}{arg1})
	fake.listVisibilitiesMutex.Unlock()
	if fake.ListVisibilitiesStub != nil {
		return fake.ListVisibilitiesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listVisibilitiesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListVisibilitiesCallCount() int {
	fake.listVisibilitiesMutex.RLock()
	defer fake.listVisibilitiesMutex.RUnlock()
	return len(fake.listVisibilitiesArgsForCall)
}

func (fake *FakeClient) ListVisibilitiesCalls(stub func(*query.Parameters) (*types.Visibilities, error)) {
	fake.listVisibilitiesMutex.Lock()
	defer fake.listVisibilitiesMutex.Unlock()
	fake.ListVisibilitiesStub = stub
}

func (fake *FakeClient) ListVisibilitiesArgsForCall(i int) *query.Parameters {
	fake.listVisibilitiesMutex.RLock()
	defer fake.listVisibilitiesMutex.RUnlock()
	argsForCall := fake.listVisibilitiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListVisibilitiesReturns(result1 *types.Visibilities, result2 error) {
	fake.listVisibilitiesMutex.Lock()
	defer fake.listVisibilitiesMutex.Unlock()
	fake.ListVisibilitiesStub = nil
	fake.listVisibilitiesReturns = struct {
		result1 *types.Visibilities
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListVisibilitiesReturnsOnCall(i int, result1 *types.Visibilities, result2 error) {
	fake.listVisibilitiesMutex.Lock()
	defer fake.listVisibilitiesMutex.Unlock()
	fake.ListVisibilitiesStub = nil
	if fake.listVisibilitiesReturnsOnCall == nil {
		fake.listVisibilitiesReturnsOnCall = make(map[int]struct {
			result1 *types.Visibilities
			result2 error
		})
	}
	fake.listVisibilitiesReturnsOnCall[i] = struct {
		result1 *types.Visibilities
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Marketplace(arg1 *query.Parameters) (*types.Marketplace, error) {
	fake.marketplaceMutex.Lock()
	ret, specificReturn := fake.marketplaceReturnsOnCall[len(fake.marketplaceArgsForCall)]
	fake.marketplaceArgsForCall = append(fake.marketplaceArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("Marketplace", []interface{}{arg1})
	fake.marketplaceMutex.Unlock()
	if fake.MarketplaceStub != nil {
		return fake.MarketplaceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.marketplaceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) MarketplaceCallCount() int {
	fake.marketplaceMutex.RLock()
	defer fake.marketplaceMutex.RUnlock()
	return len(fake.marketplaceArgsForCall)
}

func (fake *FakeClient) MarketplaceCalls(stub func(*query.Parameters) (*types.Marketplace, error)) {
	fake.marketplaceMutex.Lock()
	defer fake.marketplaceMutex.Unlock()
	fake.MarketplaceStub = stub
}

func (fake *FakeClient) MarketplaceArgsForCall(i int) *query.Parameters {
	fake.marketplaceMutex.RLock()
	defer fake.marketplaceMutex.RUnlock()
	argsForCall := fake.marketplaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) MarketplaceReturns(result1 *types.Marketplace, result2 error) {
	fake.marketplaceMutex.Lock()
	defer fake.marketplaceMutex.Unlock()
	fake.MarketplaceStub = nil
	fake.marketplaceReturns = struct {
		result1 *types.Marketplace
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MarketplaceReturnsOnCall(i int, result1 *types.Marketplace, result2 error) {
	fake.marketplaceMutex.Lock()
	defer fake.marketplaceMutex.Unlock()
	fake.MarketplaceStub = nil
	if fake.marketplaceReturnsOnCall == nil {
		fake.marketplaceReturnsOnCall = make(map[int]struct {
			result1 *types.Marketplace
			result2 error
		})
	}
	fake.marketplaceReturnsOnCall[i] = struct {
		result1 *types.Marketplace
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Provision(arg1 *types.ServiceInstance, arg2 *query.Parameters) (*types.ServiceInstance, string, error) {
	fake.provisionMutex.Lock()
	ret, specificReturn := fake.provisionReturnsOnCall[len(fake.provisionArgsForCall)]
	fake.provisionArgsForCall = append(fake.provisionArgsForCall, struct {
		arg1 *types.ServiceInstance
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("Provision", []interface{}{arg1, arg2})
	fake.provisionMutex.Unlock()
	if fake.ProvisionStub != nil {
		return fake.ProvisionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.provisionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) ProvisionCallCount() int {
	fake.provisionMutex.RLock()
	defer fake.provisionMutex.RUnlock()
	return len(fake.provisionArgsForCall)
}

func (fake *FakeClient) ProvisionCalls(stub func(*types.ServiceInstance, *query.Parameters) (*types.ServiceInstance, string, error)) {
	fake.provisionMutex.Lock()
	defer fake.provisionMutex.Unlock()
	fake.ProvisionStub = stub
}

func (fake *FakeClient) ProvisionArgsForCall(i int) (*types.ServiceInstance, *query.Parameters) {
	fake.provisionMutex.RLock()
	defer fake.provisionMutex.RUnlock()
	argsForCall := fake.provisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ProvisionReturns(result1 *types.ServiceInstance, result2 string, result3 error) {
	fake.provisionMutex.Lock()
	defer fake.provisionMutex.Unlock()
	fake.ProvisionStub = nil
	fake.provisionReturns = struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) ProvisionReturnsOnCall(i int, result1 *types.ServiceInstance, result2 string, result3 error) {
	fake.provisionMutex.Lock()
	defer fake.provisionMutex.Unlock()
	fake.ProvisionStub = nil
	if fake.provisionReturnsOnCall == nil {
		fake.provisionReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceInstance
			result2 string
			result3 error
		})
	}
	fake.provisionReturnsOnCall[i] = struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) RegisterBroker(arg1 *types.Broker, arg2 *query.Parameters) (*types.Broker, string, error) {
	fake.registerBrokerMutex.Lock()
	ret, specificReturn := fake.registerBrokerReturnsOnCall[len(fake.registerBrokerArgsForCall)]
	fake.registerBrokerArgsForCall = append(fake.registerBrokerArgsForCall, struct {
		arg1 *types.Broker
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("RegisterBroker", []interface{}{arg1, arg2})
	fake.registerBrokerMutex.Unlock()
	if fake.RegisterBrokerStub != nil {
		return fake.RegisterBrokerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.registerBrokerReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) RegisterBrokerCallCount() int {
	fake.registerBrokerMutex.RLock()
	defer fake.registerBrokerMutex.RUnlock()
	return len(fake.registerBrokerArgsForCall)
}

func (fake *FakeClient) RegisterBrokerCalls(stub func(*types.Broker, *query.Parameters) (*types.Broker, string, error)) {
	fake.registerBrokerMutex.Lock()
	defer fake.registerBrokerMutex.Unlock()
	fake.RegisterBrokerStub = stub
}

func (fake *FakeClient) RegisterBrokerArgsForCall(i int) (*types.Broker, *query.Parameters) {
	fake.registerBrokerMutex.RLock()
	defer fake.registerBrokerMutex.RUnlock()
	argsForCall := fake.registerBrokerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RegisterBrokerReturns(result1 *types.Broker, result2 string, result3 error) {
	fake.registerBrokerMutex.Lock()
	defer fake.registerBrokerMutex.Unlock()
	fake.RegisterBrokerStub = nil
	fake.registerBrokerReturns = struct {
		result1 *types.Broker
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) RegisterBrokerReturnsOnCall(i int, result1 *types.Broker, result2 string, result3 error) {
	fake.registerBrokerMutex.Lock()
	defer fake.registerBrokerMutex.Unlock()
	fake.RegisterBrokerStub = nil
	if fake.registerBrokerReturnsOnCall == nil {
		fake.registerBrokerReturnsOnCall = make(map[int]struct {
			result1 *types.Broker
			result2 string
			result3 error
		})
	}
	fake.registerBrokerReturnsOnCall[i] = struct {
		result1 *types.Broker
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) RegisterPlatform(arg1 *types.Platform, arg2 *query.Parameters) (*types.Platform, error) {
	fake.registerPlatformMutex.Lock()
	ret, specificReturn := fake.registerPlatformReturnsOnCall[len(fake.registerPlatformArgsForCall)]
	fake.registerPlatformArgsForCall = append(fake.registerPlatformArgsForCall, struct {
		arg1 *types.Platform
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("RegisterPlatform", []interface{}{arg1, arg2})
	fake.registerPlatformMutex.Unlock()
	if fake.RegisterPlatformStub != nil {
		return fake.RegisterPlatformStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registerPlatformReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RegisterPlatformCallCount() int {
	fake.registerPlatformMutex.RLock()
	defer fake.registerPlatformMutex.RUnlock()
	return len(fake.registerPlatformArgsForCall)
}

func (fake *FakeClient) RegisterPlatformCalls(stub func(*types.Platform, *query.Parameters) (*types.Platform, error)) {
	fake.registerPlatformMutex.Lock()
	defer fake.registerPlatformMutex.Unlock()
	fake.RegisterPlatformStub = stub
}

func (fake *FakeClient) RegisterPlatformArgsForCall(i int) (*types.Platform, *query.Parameters) {
	fake.registerPlatformMutex.RLock()
	defer fake.registerPlatformMutex.RUnlock()
	argsForCall := fake.registerPlatformArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RegisterPlatformReturns(result1 *types.Platform, result2 error) {
	fake.registerPlatformMutex.Lock()
	defer fake.registerPlatformMutex.Unlock()
	fake.RegisterPlatformStub = nil
	fake.registerPlatformReturns = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterPlatformReturnsOnCall(i int, result1 *types.Platform, result2 error) {
	fake.registerPlatformMutex.Lock()
	defer fake.registerPlatformMutex.Unlock()
	fake.RegisterPlatformStub = nil
	if fake.registerPlatformReturnsOnCall == nil {
		fake.registerPlatformReturnsOnCall = make(map[int]struct {
			result1 *types.Platform
			result2 error
		})
	}
	fake.registerPlatformReturnsOnCall[i] = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterVisibility(arg1 *types.Visibility, arg2 *query.Parameters) (*types.Visibility, error) {
	fake.registerVisibilityMutex.Lock()
	ret, specificReturn := fake.registerVisibilityReturnsOnCall[len(fake.registerVisibilityArgsForCall)]
	fake.registerVisibilityArgsForCall = append(fake.registerVisibilityArgsForCall, struct {
		arg1 *types.Visibility
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("RegisterVisibility", []interface{}{arg1, arg2})
	fake.registerVisibilityMutex.Unlock()
	if fake.RegisterVisibilityStub != nil {
		return fake.RegisterVisibilityStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registerVisibilityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RegisterVisibilityCallCount() int {
	fake.registerVisibilityMutex.RLock()
	defer fake.registerVisibilityMutex.RUnlock()
	return len(fake.registerVisibilityArgsForCall)
}

func (fake *FakeClient) RegisterVisibilityCalls(stub func(*types.Visibility, *query.Parameters) (*types.Visibility, error)) {
	fake.registerVisibilityMutex.Lock()
	defer fake.registerVisibilityMutex.Unlock()
	fake.RegisterVisibilityStub = stub
}

func (fake *FakeClient) RegisterVisibilityArgsForCall(i int) (*types.Visibility, *query.Parameters) {
	fake.registerVisibilityMutex.RLock()
	defer fake.registerVisibilityMutex.RUnlock()
	argsForCall := fake.registerVisibilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RegisterVisibilityReturns(result1 *types.Visibility, result2 error) {
	fake.registerVisibilityMutex.Lock()
	defer fake.registerVisibilityMutex.Unlock()
	fake.RegisterVisibilityStub = nil
	fake.registerVisibilityReturns = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterVisibilityReturnsOnCall(i int, result1 *types.Visibility, result2 error) {
	fake.registerVisibilityMutex.Lock()
	defer fake.registerVisibilityMutex.Unlock()
	fake.RegisterVisibilityStub = nil
	if fake.registerVisibilityReturnsOnCall == nil {
		fake.registerVisibilityReturnsOnCall = make(map[int]struct {
			result1 *types.Visibility
			result2 error
		})
	}
	fake.registerVisibilityReturnsOnCall[i] = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Status(arg1 string, arg2 *query.Parameters) (*types.Operation, error) {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
		arg1 string
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("Status", []interface{}{arg1, arg2})
	fake.statusMutex.Unlock()
	if fake.StatusStub != nil {
		return fake.StatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.statusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeClient) StatusCalls(stub func(string, *query.Parameters) (*types.Operation, error)) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeClient) StatusArgsForCall(i int) (string, *query.Parameters) {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	argsForCall := fake.statusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) StatusReturns(result1 *types.Operation, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 *types.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StatusReturnsOnCall(i int, result1 *types.Operation, result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 *types.Operation
			result2 error
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 *types.Operation
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Unbind(arg1 string, arg2 *query.Parameters) (string, error) {
	fake.unbindMutex.Lock()
	ret, specificReturn := fake.unbindReturnsOnCall[len(fake.unbindArgsForCall)]
	fake.unbindArgsForCall = append(fake.unbindArgsForCall, struct {
		arg1 string
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("Unbind", []interface{}{arg1, arg2})
	fake.unbindMutex.Unlock()
	if fake.UnbindStub != nil {
		return fake.UnbindStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.unbindReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UnbindCallCount() int {
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	return len(fake.unbindArgsForCall)
}

func (fake *FakeClient) UnbindCalls(stub func(string, *query.Parameters) (string, error)) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = stub
}

func (fake *FakeClient) UnbindArgsForCall(i int) (string, *query.Parameters) {
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	argsForCall := fake.unbindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UnbindReturns(result1 string, result2 error) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = nil
	fake.unbindReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UnbindReturnsOnCall(i int, result1 string, result2 error) {
	fake.unbindMutex.Lock()
	defer fake.unbindMutex.Unlock()
	fake.UnbindStub = nil
	if fake.unbindReturnsOnCall == nil {
		fake.unbindReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.unbindReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateBroker(arg1 string, arg2 *types.Broker, arg3 *query.Parameters) (*types.Broker, string, error) {
	fake.updateBrokerMutex.Lock()
	ret, specificReturn := fake.updateBrokerReturnsOnCall[len(fake.updateBrokerArgsForCall)]
	fake.updateBrokerArgsForCall = append(fake.updateBrokerArgsForCall, struct {
		arg1 string
		arg2 *types.Broker
		arg3 *query.Parameters
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateBroker", []interface{}{arg1, arg2, arg3})
	fake.updateBrokerMutex.Unlock()
	if fake.UpdateBrokerStub != nil {
		return fake.UpdateBrokerStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.updateBrokerReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) UpdateBrokerCallCount() int {
	fake.updateBrokerMutex.RLock()
	defer fake.updateBrokerMutex.RUnlock()
	return len(fake.updateBrokerArgsForCall)
}

func (fake *FakeClient) UpdateBrokerCalls(stub func(string, *types.Broker, *query.Parameters) (*types.Broker, string, error)) {
	fake.updateBrokerMutex.Lock()
	defer fake.updateBrokerMutex.Unlock()
	fake.UpdateBrokerStub = stub
}

func (fake *FakeClient) UpdateBrokerArgsForCall(i int) (string, *types.Broker, *query.Parameters) {
	fake.updateBrokerMutex.RLock()
	defer fake.updateBrokerMutex.RUnlock()
	argsForCall := fake.updateBrokerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdateBrokerReturns(result1 *types.Broker, result2 string, result3 error) {
	fake.updateBrokerMutex.Lock()
	defer fake.updateBrokerMutex.Unlock()
	fake.UpdateBrokerStub = nil
	fake.updateBrokerReturns = struct {
		result1 *types.Broker
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) UpdateBrokerReturnsOnCall(i int, result1 *types.Broker, result2 string, result3 error) {
	fake.updateBrokerMutex.Lock()
	defer fake.updateBrokerMutex.Unlock()
	fake.UpdateBrokerStub = nil
	if fake.updateBrokerReturnsOnCall == nil {
		fake.updateBrokerReturnsOnCall = make(map[int]struct {
			result1 *types.Broker
			result2 string
			result3 error
		})
	}
	fake.updateBrokerReturnsOnCall[i] = struct {
		result1 *types.Broker
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) UpdateInstance(arg1 string, arg2 *types.ServiceInstance, arg3 *query.Parameters) (*types.ServiceInstance, string, error) {
	fake.updateInstanceMutex.Lock()
	ret, specificReturn := fake.updateInstanceReturnsOnCall[len(fake.updateInstanceArgsForCall)]
	fake.updateInstanceArgsForCall = append(fake.updateInstanceArgsForCall, struct {
		arg1 string
		arg2 *types.ServiceInstance
		arg3 *query.Parameters
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateInstance", []interface{}{arg1, arg2, arg3})
	fake.updateInstanceMutex.Unlock()
	if fake.UpdateInstanceStub != nil {
		return fake.UpdateInstanceStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.updateInstanceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeClient) UpdateInstanceCallCount() int {
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	return len(fake.updateInstanceArgsForCall)
}

func (fake *FakeClient) UpdateInstanceCalls(stub func(string, *types.ServiceInstance, *query.Parameters) (*types.ServiceInstance, string, error)) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = stub
}

func (fake *FakeClient) UpdateInstanceArgsForCall(i int) (string, *types.ServiceInstance, *query.Parameters) {
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	argsForCall := fake.updateInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdateInstanceReturns(result1 *types.ServiceInstance, result2 string, result3 error) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = nil
	fake.updateInstanceReturns = struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) UpdateInstanceReturnsOnCall(i int, result1 *types.ServiceInstance, result2 string, result3 error) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = nil
	if fake.updateInstanceReturnsOnCall == nil {
		fake.updateInstanceReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceInstance
			result2 string
			result3 error
		})
	}
	fake.updateInstanceReturnsOnCall[i] = struct {
		result1 *types.ServiceInstance
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeClient) UpdatePlatform(arg1 string, arg2 *types.Platform, arg3 *query.Parameters) (*types.Platform, error) {
	fake.updatePlatformMutex.Lock()
	ret, specificReturn := fake.updatePlatformReturnsOnCall[len(fake.updatePlatformArgsForCall)]
	fake.updatePlatformArgsForCall = append(fake.updatePlatformArgsForCall, struct {
		arg1 string
		arg2 *types.Platform
		arg3 *query.Parameters
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdatePlatform", []interface{}{arg1, arg2, arg3})
	fake.updatePlatformMutex.Unlock()
	if fake.UpdatePlatformStub != nil {
		return fake.UpdatePlatformStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updatePlatformReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdatePlatformCallCount() int {
	fake.updatePlatformMutex.RLock()
	defer fake.updatePlatformMutex.RUnlock()
	return len(fake.updatePlatformArgsForCall)
}

func (fake *FakeClient) UpdatePlatformCalls(stub func(string, *types.Platform, *query.Parameters) (*types.Platform, error)) {
	fake.updatePlatformMutex.Lock()
	defer fake.updatePlatformMutex.Unlock()
	fake.UpdatePlatformStub = stub
}

func (fake *FakeClient) UpdatePlatformArgsForCall(i int) (string, *types.Platform, *query.Parameters) {
	fake.updatePlatformMutex.RLock()
	defer fake.updatePlatformMutex.RUnlock()
	argsForCall := fake.updatePlatformArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdatePlatformReturns(result1 *types.Platform, result2 error) {
	fake.updatePlatformMutex.Lock()
	defer fake.updatePlatformMutex.Unlock()
	fake.UpdatePlatformStub = nil
	fake.updatePlatformReturns = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePlatformReturnsOnCall(i int, result1 *types.Platform, result2 error) {
	fake.updatePlatformMutex.Lock()
	defer fake.updatePlatformMutex.Unlock()
	fake.UpdatePlatformStub = nil
	if fake.updatePlatformReturnsOnCall == nil {
		fake.updatePlatformReturnsOnCall = make(map[int]struct {
			result1 *types.Platform
			result2 error
		})
	}
	fake.updatePlatformReturnsOnCall[i] = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateVisibility(arg1 string, arg2 *types.Visibility, arg3 *query.Parameters) (*types.Visibility, error) {
	fake.updateVisibilityMutex.Lock()
	ret, specificReturn := fake.updateVisibilityReturnsOnCall[len(fake.updateVisibilityArgsForCall)]
	fake.updateVisibilityArgsForCall = append(fake.updateVisibilityArgsForCall, struct {
		arg1 string
		arg2 *types.Visibility
		arg3 *query.Parameters
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateVisibility", []interface{}{arg1, arg2, arg3})
	fake.updateVisibilityMutex.Unlock()
	if fake.UpdateVisibilityStub != nil {
		return fake.UpdateVisibilityStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateVisibilityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateVisibilityCallCount() int {
	fake.updateVisibilityMutex.RLock()
	defer fake.updateVisibilityMutex.RUnlock()
	return len(fake.updateVisibilityArgsForCall)
}

func (fake *FakeClient) UpdateVisibilityCalls(stub func(string, *types.Visibility, *query.Parameters) (*types.Visibility, error)) {
	fake.updateVisibilityMutex.Lock()
	defer fake.updateVisibilityMutex.Unlock()
	fake.UpdateVisibilityStub = stub
}

func (fake *FakeClient) UpdateVisibilityArgsForCall(i int) (string, *types.Visibility, *query.Parameters) {
	fake.updateVisibilityMutex.RLock()
	defer fake.updateVisibilityMutex.RUnlock()
	argsForCall := fake.updateVisibilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdateVisibilityReturns(result1 *types.Visibility, result2 error) {
	fake.updateVisibilityMutex.Lock()
	defer fake.updateVisibilityMutex.Unlock()
	fake.UpdateVisibilityStub = nil
	fake.updateVisibilityReturns = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateVisibilityReturnsOnCall(i int, result1 *types.Visibility, result2 error) {
	fake.updateVisibilityMutex.Lock()
	defer fake.updateVisibilityMutex.Unlock()
	fake.UpdateVisibilityStub = nil
	if fake.updateVisibilityReturnsOnCall == nil {
		fake.updateVisibilityReturnsOnCall = make(map[int]struct {
			result1 *types.Visibility
			result2 error
		})
	}
	fake.updateVisibilityReturnsOnCall[i] = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	fake.callMutex.RLock()
	defer fake.callMutex.RUnlock()
	fake.deleteBrokerMutex.RLock()
	defer fake.deleteBrokerMutex.RUnlock()
	fake.deletePlatformsMutex.RLock()
	defer fake.deletePlatformsMutex.RUnlock()
	fake.deleteVisibilitiesMutex.RLock()
	defer fake.deleteVisibilitiesMutex.RUnlock()
	fake.deprovisionMutex.RLock()
	defer fake.deprovisionMutex.RUnlock()
	fake.getBindingByIDMutex.RLock()
	defer fake.getBindingByIDMutex.RUnlock()
	fake.getBrokerByIDMutex.RLock()
	defer fake.getBrokerByIDMutex.RUnlock()
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	fake.getInstanceByIDMutex.RLock()
	defer fake.getInstanceByIDMutex.RUnlock()
	fake.labelMutex.RLock()
	defer fake.labelMutex.RUnlock()
	fake.listBindingsMutex.RLock()
	defer fake.listBindingsMutex.RUnlock()
	fake.listBrokersMutex.RLock()
	defer fake.listBrokersMutex.RUnlock()
	fake.listInstancesMutex.RLock()
	defer fake.listInstancesMutex.RUnlock()
	fake.listOfferingsMutex.RLock()
	defer fake.listOfferingsMutex.RUnlock()
	fake.listPlansMutex.RLock()
	defer fake.listPlansMutex.RUnlock()
	fake.listPlatformsMutex.RLock()
	defer fake.listPlatformsMutex.RUnlock()
	fake.listVisibilitiesMutex.RLock()
	defer fake.listVisibilitiesMutex.RUnlock()
	fake.marketplaceMutex.RLock()
	defer fake.marketplaceMutex.RUnlock()
	fake.provisionMutex.RLock()
	defer fake.provisionMutex.RUnlock()
	fake.registerBrokerMutex.RLock()
	defer fake.registerBrokerMutex.RUnlock()
	fake.registerPlatformMutex.RLock()
	defer fake.registerPlatformMutex.RUnlock()
	fake.registerVisibilityMutex.RLock()
	defer fake.registerVisibilityMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.unbindMutex.RLock()
	defer fake.unbindMutex.RUnlock()
	fake.updateBrokerMutex.RLock()
	defer fake.updateBrokerMutex.RUnlock()
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	fake.updatePlatformMutex.RLock()
	defer fake.updatePlatformMutex.RUnlock()
	fake.updateVisibilityMutex.RLock()
	defer fake.updateVisibilityMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ smclient.Client = new(FakeClient)
