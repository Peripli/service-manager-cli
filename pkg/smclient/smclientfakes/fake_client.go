// Code generated by counterfeiter. DO NOT EDIT.
package smclientfakes

import (
	"io"
	"net/http"
	"sync"

	"github.com/Peripli/service-manager-cli/pkg/query"
	"github.com/Peripli/service-manager-cli/pkg/smclient"
	"github.com/Peripli/service-manager-cli/pkg/types"
)

type FakeClient struct {
	CallStub        func(string, string, io.Reader, *query.Parameters) (*http.Response, error)
	callMutex       sync.RWMutex
	callArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 io.Reader
		arg4 *query.Parameters
	}
	callReturns struct {
		result1 *http.Response
		result2 error
	}
	callReturnsOnCall map[int]struct {
		result1 *http.Response
		result2 error
	}
	DeleteBrokersStub        func(*query.Parameters) error
	deleteBrokersMutex       sync.RWMutex
	deleteBrokersArgsForCall []struct {
		arg1 *query.Parameters
	}
	deleteBrokersReturns struct {
		result1 error
	}
	deleteBrokersReturnsOnCall map[int]struct {
		result1 error
	}
	DeletePlatformsStub        func(*query.Parameters) error
	deletePlatformsMutex       sync.RWMutex
	deletePlatformsArgsForCall []struct {
		arg1 *query.Parameters
	}
	deletePlatformsReturns struct {
		result1 error
	}
	deletePlatformsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteVisibilitiesStub        func(*query.Parameters) error
	deleteVisibilitiesMutex       sync.RWMutex
	deleteVisibilitiesArgsForCall []struct {
		arg1 *query.Parameters
	}
	deleteVisibilitiesReturns struct {
		result1 error
	}
	deleteVisibilitiesReturnsOnCall map[int]struct {
		result1 error
	}
	GetInfoStub        func(*query.Parameters) (*types.Info, error)
	getInfoMutex       sync.RWMutex
	getInfoArgsForCall []struct {
		arg1 *query.Parameters
	}
	getInfoReturns struct {
		result1 *types.Info
		result2 error
	}
	getInfoReturnsOnCall map[int]struct {
		result1 *types.Info
		result2 error
	}
	LabelStub        func(string, string, *types.LabelChanges, *query.Parameters) error
	labelMutex       sync.RWMutex
	labelArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *types.LabelChanges
		arg4 *query.Parameters
	}
	labelReturns struct {
		result1 error
	}
	labelReturnsOnCall map[int]struct {
		result1 error
	}
	ListBrokersStub        func(*query.Parameters) (*types.Brokers, error)
	listBrokersMutex       sync.RWMutex
	listBrokersArgsForCall []struct {
		arg1 *query.Parameters
	}
	listBrokersReturns struct {
		result1 *types.Brokers
		result2 error
	}
	listBrokersReturnsOnCall map[int]struct {
		result1 *types.Brokers
		result2 error
	}
	ListOfferingsStub        func(*query.Parameters) (*types.ServiceOfferings, error)
	listOfferingsMutex       sync.RWMutex
	listOfferingsArgsForCall []struct {
		arg1 *query.Parameters
	}
	listOfferingsReturns struct {
		result1 *types.ServiceOfferings
		result2 error
	}
	listOfferingsReturnsOnCall map[int]struct {
		result1 *types.ServiceOfferings
		result2 error
	}
	ListPlansStub        func(*query.Parameters) (*types.ServicePlans, error)
	listPlansMutex       sync.RWMutex
	listPlansArgsForCall []struct {
		arg1 *query.Parameters
	}
	listPlansReturns struct {
		result1 *types.ServicePlans
		result2 error
	}
	listPlansReturnsOnCall map[int]struct {
		result1 *types.ServicePlans
		result2 error
	}
	ListPlatformsStub        func(*query.Parameters) (*types.Platforms, error)
	listPlatformsMutex       sync.RWMutex
	listPlatformsArgsForCall []struct {
		arg1 *query.Parameters
	}
	listPlatformsReturns struct {
		result1 *types.Platforms
		result2 error
	}
	listPlatformsReturnsOnCall map[int]struct {
		result1 *types.Platforms
		result2 error
	}
	ListVisibilitiesStub        func(*query.Parameters) (*types.Visibilities, error)
	listVisibilitiesMutex       sync.RWMutex
	listVisibilitiesArgsForCall []struct {
		arg1 *query.Parameters
	}
	listVisibilitiesReturns struct {
		result1 *types.Visibilities
		result2 error
	}
	listVisibilitiesReturnsOnCall map[int]struct {
		result1 *types.Visibilities
		result2 error
	}
	MarketplaceStub        func(*query.Parameters) (*types.Marketplace, error)
	marketplaceMutex       sync.RWMutex
	marketplaceArgsForCall []struct {
		arg1 *query.Parameters
	}
	marketplaceReturns struct {
		result1 *types.Marketplace
		result2 error
	}
	marketplaceReturnsOnCall map[int]struct {
		result1 *types.Marketplace
		result2 error
	}
	RegisterBrokerStub        func(*types.Broker, *query.Parameters) (*types.Broker, error)
	registerBrokerMutex       sync.RWMutex
	registerBrokerArgsForCall []struct {
		arg1 *types.Broker
		arg2 *query.Parameters
	}
	registerBrokerReturns struct {
		result1 *types.Broker
		result2 error
	}
	registerBrokerReturnsOnCall map[int]struct {
		result1 *types.Broker
		result2 error
	}
	RegisterPlatformStub        func(*types.Platform, *query.Parameters) (*types.Platform, error)
	registerPlatformMutex       sync.RWMutex
	registerPlatformArgsForCall []struct {
		arg1 *types.Platform
		arg2 *query.Parameters
	}
	registerPlatformReturns struct {
		result1 *types.Platform
		result2 error
	}
	registerPlatformReturnsOnCall map[int]struct {
		result1 *types.Platform
		result2 error
	}
	RegisterVisibilityStub        func(*types.Visibility, *query.Parameters) (*types.Visibility, error)
	registerVisibilityMutex       sync.RWMutex
	registerVisibilityArgsForCall []struct {
		arg1 *types.Visibility
		arg2 *query.Parameters
	}
	registerVisibilityReturns struct {
		result1 *types.Visibility
		result2 error
	}
	registerVisibilityReturnsOnCall map[int]struct {
		result1 *types.Visibility
		result2 error
	}
	UpdateBrokerStub        func(string, *types.Broker, *query.Parameters) (*types.Broker, error)
	updateBrokerMutex       sync.RWMutex
	updateBrokerArgsForCall []struct {
		arg1 string
		arg2 *types.Broker
		arg3 *query.Parameters
	}
	updateBrokerReturns struct {
		result1 *types.Broker
		result2 error
	}
	updateBrokerReturnsOnCall map[int]struct {
		result1 *types.Broker
		result2 error
	}
	UpdatePlatformStub        func(string, *types.Platform, *query.Parameters) (*types.Platform, error)
	updatePlatformMutex       sync.RWMutex
	updatePlatformArgsForCall []struct {
		arg1 string
		arg2 *types.Platform
		arg3 *query.Parameters
	}
	updatePlatformReturns struct {
		result1 *types.Platform
		result2 error
	}
	updatePlatformReturnsOnCall map[int]struct {
		result1 *types.Platform
		result2 error
	}
	UpdateVisibilityStub        func(string, *types.Visibility, *query.Parameters) (*types.Visibility, error)
	updateVisibilityMutex       sync.RWMutex
	updateVisibilityArgsForCall []struct {
		arg1 string
		arg2 *types.Visibility
		arg3 *query.Parameters
	}
	updateVisibilityReturns struct {
		result1 *types.Visibility
		result2 error
	}
	updateVisibilityReturnsOnCall map[int]struct {
		result1 *types.Visibility
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Call(arg1 string, arg2 string, arg3 io.Reader, arg4 *query.Parameters) (*http.Response, error) {
	fake.callMutex.Lock()
	ret, specificReturn := fake.callReturnsOnCall[len(fake.callArgsForCall)]
	fake.callArgsForCall = append(fake.callArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 io.Reader
		arg4 *query.Parameters
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Call", []interface{}{arg1, arg2, arg3, arg4})
	fake.callMutex.Unlock()
	if fake.CallStub != nil {
		return fake.CallStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.callReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CallCallCount() int {
	fake.callMutex.RLock()
	defer fake.callMutex.RUnlock()
	return len(fake.callArgsForCall)
}

func (fake *FakeClient) CallCalls(stub func(string, string, io.Reader, *query.Parameters) (*http.Response, error)) {
	fake.callMutex.Lock()
	defer fake.callMutex.Unlock()
	fake.CallStub = stub
}

func (fake *FakeClient) CallArgsForCall(i int) (string, string, io.Reader, *query.Parameters) {
	fake.callMutex.RLock()
	defer fake.callMutex.RUnlock()
	argsForCall := fake.callArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) CallReturns(result1 *http.Response, result2 error) {
	fake.callMutex.Lock()
	defer fake.callMutex.Unlock()
	fake.CallStub = nil
	fake.callReturns = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CallReturnsOnCall(i int, result1 *http.Response, result2 error) {
	fake.callMutex.Lock()
	defer fake.callMutex.Unlock()
	fake.CallStub = nil
	if fake.callReturnsOnCall == nil {
		fake.callReturnsOnCall = make(map[int]struct {
			result1 *http.Response
			result2 error
		})
	}
	fake.callReturnsOnCall[i] = struct {
		result1 *http.Response
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteBrokers(arg1 *query.Parameters) error {
	fake.deleteBrokersMutex.Lock()
	ret, specificReturn := fake.deleteBrokersReturnsOnCall[len(fake.deleteBrokersArgsForCall)]
	fake.deleteBrokersArgsForCall = append(fake.deleteBrokersArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("DeleteBrokers", []interface{}{arg1})
	fake.deleteBrokersMutex.Unlock()
	if fake.DeleteBrokersStub != nil {
		return fake.DeleteBrokersStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteBrokersReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteBrokersCallCount() int {
	fake.deleteBrokersMutex.RLock()
	defer fake.deleteBrokersMutex.RUnlock()
	return len(fake.deleteBrokersArgsForCall)
}

func (fake *FakeClient) DeleteBrokersCalls(stub func(*query.Parameters) error) {
	fake.deleteBrokersMutex.Lock()
	defer fake.deleteBrokersMutex.Unlock()
	fake.DeleteBrokersStub = stub
}

func (fake *FakeClient) DeleteBrokersArgsForCall(i int) *query.Parameters {
	fake.deleteBrokersMutex.RLock()
	defer fake.deleteBrokersMutex.RUnlock()
	argsForCall := fake.deleteBrokersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteBrokersReturns(result1 error) {
	fake.deleteBrokersMutex.Lock()
	defer fake.deleteBrokersMutex.Unlock()
	fake.DeleteBrokersStub = nil
	fake.deleteBrokersReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteBrokersReturnsOnCall(i int, result1 error) {
	fake.deleteBrokersMutex.Lock()
	defer fake.deleteBrokersMutex.Unlock()
	fake.DeleteBrokersStub = nil
	if fake.deleteBrokersReturnsOnCall == nil {
		fake.deleteBrokersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBrokersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeletePlatforms(arg1 *query.Parameters) error {
	fake.deletePlatformsMutex.Lock()
	ret, specificReturn := fake.deletePlatformsReturnsOnCall[len(fake.deletePlatformsArgsForCall)]
	fake.deletePlatformsArgsForCall = append(fake.deletePlatformsArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("DeletePlatforms", []interface{}{arg1})
	fake.deletePlatformsMutex.Unlock()
	if fake.DeletePlatformsStub != nil {
		return fake.DeletePlatformsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deletePlatformsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeletePlatformsCallCount() int {
	fake.deletePlatformsMutex.RLock()
	defer fake.deletePlatformsMutex.RUnlock()
	return len(fake.deletePlatformsArgsForCall)
}

func (fake *FakeClient) DeletePlatformsCalls(stub func(*query.Parameters) error) {
	fake.deletePlatformsMutex.Lock()
	defer fake.deletePlatformsMutex.Unlock()
	fake.DeletePlatformsStub = stub
}

func (fake *FakeClient) DeletePlatformsArgsForCall(i int) *query.Parameters {
	fake.deletePlatformsMutex.RLock()
	defer fake.deletePlatformsMutex.RUnlock()
	argsForCall := fake.deletePlatformsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeletePlatformsReturns(result1 error) {
	fake.deletePlatformsMutex.Lock()
	defer fake.deletePlatformsMutex.Unlock()
	fake.DeletePlatformsStub = nil
	fake.deletePlatformsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeletePlatformsReturnsOnCall(i int, result1 error) {
	fake.deletePlatformsMutex.Lock()
	defer fake.deletePlatformsMutex.Unlock()
	fake.DeletePlatformsStub = nil
	if fake.deletePlatformsReturnsOnCall == nil {
		fake.deletePlatformsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePlatformsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteVisibilities(arg1 *query.Parameters) error {
	fake.deleteVisibilitiesMutex.Lock()
	ret, specificReturn := fake.deleteVisibilitiesReturnsOnCall[len(fake.deleteVisibilitiesArgsForCall)]
	fake.deleteVisibilitiesArgsForCall = append(fake.deleteVisibilitiesArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("DeleteVisibilities", []interface{}{arg1})
	fake.deleteVisibilitiesMutex.Unlock()
	if fake.DeleteVisibilitiesStub != nil {
		return fake.DeleteVisibilitiesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteVisibilitiesReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteVisibilitiesCallCount() int {
	fake.deleteVisibilitiesMutex.RLock()
	defer fake.deleteVisibilitiesMutex.RUnlock()
	return len(fake.deleteVisibilitiesArgsForCall)
}

func (fake *FakeClient) DeleteVisibilitiesCalls(stub func(*query.Parameters) error) {
	fake.deleteVisibilitiesMutex.Lock()
	defer fake.deleteVisibilitiesMutex.Unlock()
	fake.DeleteVisibilitiesStub = stub
}

func (fake *FakeClient) DeleteVisibilitiesArgsForCall(i int) *query.Parameters {
	fake.deleteVisibilitiesMutex.RLock()
	defer fake.deleteVisibilitiesMutex.RUnlock()
	argsForCall := fake.deleteVisibilitiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteVisibilitiesReturns(result1 error) {
	fake.deleteVisibilitiesMutex.Lock()
	defer fake.deleteVisibilitiesMutex.Unlock()
	fake.DeleteVisibilitiesStub = nil
	fake.deleteVisibilitiesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteVisibilitiesReturnsOnCall(i int, result1 error) {
	fake.deleteVisibilitiesMutex.Lock()
	defer fake.deleteVisibilitiesMutex.Unlock()
	fake.DeleteVisibilitiesStub = nil
	if fake.deleteVisibilitiesReturnsOnCall == nil {
		fake.deleteVisibilitiesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteVisibilitiesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetInfo(arg1 *query.Parameters) (*types.Info, error) {
	fake.getInfoMutex.Lock()
	ret, specificReturn := fake.getInfoReturnsOnCall[len(fake.getInfoArgsForCall)]
	fake.getInfoArgsForCall = append(fake.getInfoArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("GetInfo", []interface{}{arg1})
	fake.getInfoMutex.Unlock()
	if fake.GetInfoStub != nil {
		return fake.GetInfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getInfoReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetInfoCallCount() int {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	return len(fake.getInfoArgsForCall)
}

func (fake *FakeClient) GetInfoCalls(stub func(*query.Parameters) (*types.Info, error)) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = stub
}

func (fake *FakeClient) GetInfoArgsForCall(i int) *query.Parameters {
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	argsForCall := fake.getInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetInfoReturns(result1 *types.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	fake.getInfoReturns = struct {
		result1 *types.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetInfoReturnsOnCall(i int, result1 *types.Info, result2 error) {
	fake.getInfoMutex.Lock()
	defer fake.getInfoMutex.Unlock()
	fake.GetInfoStub = nil
	if fake.getInfoReturnsOnCall == nil {
		fake.getInfoReturnsOnCall = make(map[int]struct {
			result1 *types.Info
			result2 error
		})
	}
	fake.getInfoReturnsOnCall[i] = struct {
		result1 *types.Info
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Label(arg1 string, arg2 string, arg3 *types.LabelChanges, arg4 *query.Parameters) error {
	fake.labelMutex.Lock()
	ret, specificReturn := fake.labelReturnsOnCall[len(fake.labelArgsForCall)]
	fake.labelArgsForCall = append(fake.labelArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *types.LabelChanges
		arg4 *query.Parameters
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Label", []interface{}{arg1, arg2, arg3, arg4})
	fake.labelMutex.Unlock()
	if fake.LabelStub != nil {
		return fake.LabelStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.labelReturns
	return fakeReturns.result1
}

func (fake *FakeClient) LabelCallCount() int {
	fake.labelMutex.RLock()
	defer fake.labelMutex.RUnlock()
	return len(fake.labelArgsForCall)
}

func (fake *FakeClient) LabelCalls(stub func(string, string, *types.LabelChanges, *query.Parameters) error) {
	fake.labelMutex.Lock()
	defer fake.labelMutex.Unlock()
	fake.LabelStub = stub
}

func (fake *FakeClient) LabelArgsForCall(i int) (string, string, *types.LabelChanges, *query.Parameters) {
	fake.labelMutex.RLock()
	defer fake.labelMutex.RUnlock()
	argsForCall := fake.labelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) LabelReturns(result1 error) {
	fake.labelMutex.Lock()
	defer fake.labelMutex.Unlock()
	fake.LabelStub = nil
	fake.labelReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) LabelReturnsOnCall(i int, result1 error) {
	fake.labelMutex.Lock()
	defer fake.labelMutex.Unlock()
	fake.LabelStub = nil
	if fake.labelReturnsOnCall == nil {
		fake.labelReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.labelReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ListBrokers(arg1 *query.Parameters) (*types.Brokers, error) {
	fake.listBrokersMutex.Lock()
	ret, specificReturn := fake.listBrokersReturnsOnCall[len(fake.listBrokersArgsForCall)]
	fake.listBrokersArgsForCall = append(fake.listBrokersArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListBrokers", []interface{}{arg1})
	fake.listBrokersMutex.Unlock()
	if fake.ListBrokersStub != nil {
		return fake.ListBrokersStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listBrokersReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListBrokersCallCount() int {
	fake.listBrokersMutex.RLock()
	defer fake.listBrokersMutex.RUnlock()
	return len(fake.listBrokersArgsForCall)
}

func (fake *FakeClient) ListBrokersCalls(stub func(*query.Parameters) (*types.Brokers, error)) {
	fake.listBrokersMutex.Lock()
	defer fake.listBrokersMutex.Unlock()
	fake.ListBrokersStub = stub
}

func (fake *FakeClient) ListBrokersArgsForCall(i int) *query.Parameters {
	fake.listBrokersMutex.RLock()
	defer fake.listBrokersMutex.RUnlock()
	argsForCall := fake.listBrokersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListBrokersReturns(result1 *types.Brokers, result2 error) {
	fake.listBrokersMutex.Lock()
	defer fake.listBrokersMutex.Unlock()
	fake.ListBrokersStub = nil
	fake.listBrokersReturns = struct {
		result1 *types.Brokers
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListBrokersReturnsOnCall(i int, result1 *types.Brokers, result2 error) {
	fake.listBrokersMutex.Lock()
	defer fake.listBrokersMutex.Unlock()
	fake.ListBrokersStub = nil
	if fake.listBrokersReturnsOnCall == nil {
		fake.listBrokersReturnsOnCall = make(map[int]struct {
			result1 *types.Brokers
			result2 error
		})
	}
	fake.listBrokersReturnsOnCall[i] = struct {
		result1 *types.Brokers
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOfferings(arg1 *query.Parameters) (*types.ServiceOfferings, error) {
	fake.listOfferingsMutex.Lock()
	ret, specificReturn := fake.listOfferingsReturnsOnCall[len(fake.listOfferingsArgsForCall)]
	fake.listOfferingsArgsForCall = append(fake.listOfferingsArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListOfferings", []interface{}{arg1})
	fake.listOfferingsMutex.Unlock()
	if fake.ListOfferingsStub != nil {
		return fake.ListOfferingsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listOfferingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListOfferingsCallCount() int {
	fake.listOfferingsMutex.RLock()
	defer fake.listOfferingsMutex.RUnlock()
	return len(fake.listOfferingsArgsForCall)
}

func (fake *FakeClient) ListOfferingsCalls(stub func(*query.Parameters) (*types.ServiceOfferings, error)) {
	fake.listOfferingsMutex.Lock()
	defer fake.listOfferingsMutex.Unlock()
	fake.ListOfferingsStub = stub
}

func (fake *FakeClient) ListOfferingsArgsForCall(i int) *query.Parameters {
	fake.listOfferingsMutex.RLock()
	defer fake.listOfferingsMutex.RUnlock()
	argsForCall := fake.listOfferingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListOfferingsReturns(result1 *types.ServiceOfferings, result2 error) {
	fake.listOfferingsMutex.Lock()
	defer fake.listOfferingsMutex.Unlock()
	fake.ListOfferingsStub = nil
	fake.listOfferingsReturns = struct {
		result1 *types.ServiceOfferings
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListOfferingsReturnsOnCall(i int, result1 *types.ServiceOfferings, result2 error) {
	fake.listOfferingsMutex.Lock()
	defer fake.listOfferingsMutex.Unlock()
	fake.ListOfferingsStub = nil
	if fake.listOfferingsReturnsOnCall == nil {
		fake.listOfferingsReturnsOnCall = make(map[int]struct {
			result1 *types.ServiceOfferings
			result2 error
		})
	}
	fake.listOfferingsReturnsOnCall[i] = struct {
		result1 *types.ServiceOfferings
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlans(arg1 *query.Parameters) (*types.ServicePlans, error) {
	fake.listPlansMutex.Lock()
	ret, specificReturn := fake.listPlansReturnsOnCall[len(fake.listPlansArgsForCall)]
	fake.listPlansArgsForCall = append(fake.listPlansArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListPlans", []interface{}{arg1})
	fake.listPlansMutex.Unlock()
	if fake.ListPlansStub != nil {
		return fake.ListPlansStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPlansReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListPlansCallCount() int {
	fake.listPlansMutex.RLock()
	defer fake.listPlansMutex.RUnlock()
	return len(fake.listPlansArgsForCall)
}

func (fake *FakeClient) ListPlansCalls(stub func(*query.Parameters) (*types.ServicePlans, error)) {
	fake.listPlansMutex.Lock()
	defer fake.listPlansMutex.Unlock()
	fake.ListPlansStub = stub
}

func (fake *FakeClient) ListPlansArgsForCall(i int) *query.Parameters {
	fake.listPlansMutex.RLock()
	defer fake.listPlansMutex.RUnlock()
	argsForCall := fake.listPlansArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListPlansReturns(result1 *types.ServicePlans, result2 error) {
	fake.listPlansMutex.Lock()
	defer fake.listPlansMutex.Unlock()
	fake.ListPlansStub = nil
	fake.listPlansReturns = struct {
		result1 *types.ServicePlans
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlansReturnsOnCall(i int, result1 *types.ServicePlans, result2 error) {
	fake.listPlansMutex.Lock()
	defer fake.listPlansMutex.Unlock()
	fake.ListPlansStub = nil
	if fake.listPlansReturnsOnCall == nil {
		fake.listPlansReturnsOnCall = make(map[int]struct {
			result1 *types.ServicePlans
			result2 error
		})
	}
	fake.listPlansReturnsOnCall[i] = struct {
		result1 *types.ServicePlans
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlatforms(arg1 *query.Parameters) (*types.Platforms, error) {
	fake.listPlatformsMutex.Lock()
	ret, specificReturn := fake.listPlatformsReturnsOnCall[len(fake.listPlatformsArgsForCall)]
	fake.listPlatformsArgsForCall = append(fake.listPlatformsArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListPlatforms", []interface{}{arg1})
	fake.listPlatformsMutex.Unlock()
	if fake.ListPlatformsStub != nil {
		return fake.ListPlatformsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listPlatformsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListPlatformsCallCount() int {
	fake.listPlatformsMutex.RLock()
	defer fake.listPlatformsMutex.RUnlock()
	return len(fake.listPlatformsArgsForCall)
}

func (fake *FakeClient) ListPlatformsCalls(stub func(*query.Parameters) (*types.Platforms, error)) {
	fake.listPlatformsMutex.Lock()
	defer fake.listPlatformsMutex.Unlock()
	fake.ListPlatformsStub = stub
}

func (fake *FakeClient) ListPlatformsArgsForCall(i int) *query.Parameters {
	fake.listPlatformsMutex.RLock()
	defer fake.listPlatformsMutex.RUnlock()
	argsForCall := fake.listPlatformsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListPlatformsReturns(result1 *types.Platforms, result2 error) {
	fake.listPlatformsMutex.Lock()
	defer fake.listPlatformsMutex.Unlock()
	fake.ListPlatformsStub = nil
	fake.listPlatformsReturns = struct {
		result1 *types.Platforms
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListPlatformsReturnsOnCall(i int, result1 *types.Platforms, result2 error) {
	fake.listPlatformsMutex.Lock()
	defer fake.listPlatformsMutex.Unlock()
	fake.ListPlatformsStub = nil
	if fake.listPlatformsReturnsOnCall == nil {
		fake.listPlatformsReturnsOnCall = make(map[int]struct {
			result1 *types.Platforms
			result2 error
		})
	}
	fake.listPlatformsReturnsOnCall[i] = struct {
		result1 *types.Platforms
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListVisibilities(arg1 *query.Parameters) (*types.Visibilities, error) {
	fake.listVisibilitiesMutex.Lock()
	ret, specificReturn := fake.listVisibilitiesReturnsOnCall[len(fake.listVisibilitiesArgsForCall)]
	fake.listVisibilitiesArgsForCall = append(fake.listVisibilitiesArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("ListVisibilities", []interface{}{arg1})
	fake.listVisibilitiesMutex.Unlock()
	if fake.ListVisibilitiesStub != nil {
		return fake.ListVisibilitiesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listVisibilitiesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ListVisibilitiesCallCount() int {
	fake.listVisibilitiesMutex.RLock()
	defer fake.listVisibilitiesMutex.RUnlock()
	return len(fake.listVisibilitiesArgsForCall)
}

func (fake *FakeClient) ListVisibilitiesCalls(stub func(*query.Parameters) (*types.Visibilities, error)) {
	fake.listVisibilitiesMutex.Lock()
	defer fake.listVisibilitiesMutex.Unlock()
	fake.ListVisibilitiesStub = stub
}

func (fake *FakeClient) ListVisibilitiesArgsForCall(i int) *query.Parameters {
	fake.listVisibilitiesMutex.RLock()
	defer fake.listVisibilitiesMutex.RUnlock()
	argsForCall := fake.listVisibilitiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ListVisibilitiesReturns(result1 *types.Visibilities, result2 error) {
	fake.listVisibilitiesMutex.Lock()
	defer fake.listVisibilitiesMutex.Unlock()
	fake.ListVisibilitiesStub = nil
	fake.listVisibilitiesReturns = struct {
		result1 *types.Visibilities
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ListVisibilitiesReturnsOnCall(i int, result1 *types.Visibilities, result2 error) {
	fake.listVisibilitiesMutex.Lock()
	defer fake.listVisibilitiesMutex.Unlock()
	fake.ListVisibilitiesStub = nil
	if fake.listVisibilitiesReturnsOnCall == nil {
		fake.listVisibilitiesReturnsOnCall = make(map[int]struct {
			result1 *types.Visibilities
			result2 error
		})
	}
	fake.listVisibilitiesReturnsOnCall[i] = struct {
		result1 *types.Visibilities
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Marketplace(arg1 *query.Parameters) (*types.Marketplace, error) {
	fake.marketplaceMutex.Lock()
	ret, specificReturn := fake.marketplaceReturnsOnCall[len(fake.marketplaceArgsForCall)]
	fake.marketplaceArgsForCall = append(fake.marketplaceArgsForCall, struct {
		arg1 *query.Parameters
	}{arg1})
	fake.recordInvocation("Marketplace", []interface{}{arg1})
	fake.marketplaceMutex.Unlock()
	if fake.MarketplaceStub != nil {
		return fake.MarketplaceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.marketplaceReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) MarketplaceCallCount() int {
	fake.marketplaceMutex.RLock()
	defer fake.marketplaceMutex.RUnlock()
	return len(fake.marketplaceArgsForCall)
}

func (fake *FakeClient) MarketplaceCalls(stub func(*query.Parameters) (*types.Marketplace, error)) {
	fake.marketplaceMutex.Lock()
	defer fake.marketplaceMutex.Unlock()
	fake.MarketplaceStub = stub
}

func (fake *FakeClient) MarketplaceArgsForCall(i int) *query.Parameters {
	fake.marketplaceMutex.RLock()
	defer fake.marketplaceMutex.RUnlock()
	argsForCall := fake.marketplaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) MarketplaceReturns(result1 *types.Marketplace, result2 error) {
	fake.marketplaceMutex.Lock()
	defer fake.marketplaceMutex.Unlock()
	fake.MarketplaceStub = nil
	fake.marketplaceReturns = struct {
		result1 *types.Marketplace
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) MarketplaceReturnsOnCall(i int, result1 *types.Marketplace, result2 error) {
	fake.marketplaceMutex.Lock()
	defer fake.marketplaceMutex.Unlock()
	fake.MarketplaceStub = nil
	if fake.marketplaceReturnsOnCall == nil {
		fake.marketplaceReturnsOnCall = make(map[int]struct {
			result1 *types.Marketplace
			result2 error
		})
	}
	fake.marketplaceReturnsOnCall[i] = struct {
		result1 *types.Marketplace
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterBroker(arg1 *types.Broker, arg2 *query.Parameters) (*types.Broker, error) {
	fake.registerBrokerMutex.Lock()
	ret, specificReturn := fake.registerBrokerReturnsOnCall[len(fake.registerBrokerArgsForCall)]
	fake.registerBrokerArgsForCall = append(fake.registerBrokerArgsForCall, struct {
		arg1 *types.Broker
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("RegisterBroker", []interface{}{arg1, arg2})
	fake.registerBrokerMutex.Unlock()
	if fake.RegisterBrokerStub != nil {
		return fake.RegisterBrokerStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registerBrokerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RegisterBrokerCallCount() int {
	fake.registerBrokerMutex.RLock()
	defer fake.registerBrokerMutex.RUnlock()
	return len(fake.registerBrokerArgsForCall)
}

func (fake *FakeClient) RegisterBrokerCalls(stub func(*types.Broker, *query.Parameters) (*types.Broker, error)) {
	fake.registerBrokerMutex.Lock()
	defer fake.registerBrokerMutex.Unlock()
	fake.RegisterBrokerStub = stub
}

func (fake *FakeClient) RegisterBrokerArgsForCall(i int) (*types.Broker, *query.Parameters) {
	fake.registerBrokerMutex.RLock()
	defer fake.registerBrokerMutex.RUnlock()
	argsForCall := fake.registerBrokerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RegisterBrokerReturns(result1 *types.Broker, result2 error) {
	fake.registerBrokerMutex.Lock()
	defer fake.registerBrokerMutex.Unlock()
	fake.RegisterBrokerStub = nil
	fake.registerBrokerReturns = struct {
		result1 *types.Broker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterBrokerReturnsOnCall(i int, result1 *types.Broker, result2 error) {
	fake.registerBrokerMutex.Lock()
	defer fake.registerBrokerMutex.Unlock()
	fake.RegisterBrokerStub = nil
	if fake.registerBrokerReturnsOnCall == nil {
		fake.registerBrokerReturnsOnCall = make(map[int]struct {
			result1 *types.Broker
			result2 error
		})
	}
	fake.registerBrokerReturnsOnCall[i] = struct {
		result1 *types.Broker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterPlatform(arg1 *types.Platform, arg2 *query.Parameters) (*types.Platform, error) {
	fake.registerPlatformMutex.Lock()
	ret, specificReturn := fake.registerPlatformReturnsOnCall[len(fake.registerPlatformArgsForCall)]
	fake.registerPlatformArgsForCall = append(fake.registerPlatformArgsForCall, struct {
		arg1 *types.Platform
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("RegisterPlatform", []interface{}{arg1, arg2})
	fake.registerPlatformMutex.Unlock()
	if fake.RegisterPlatformStub != nil {
		return fake.RegisterPlatformStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registerPlatformReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RegisterPlatformCallCount() int {
	fake.registerPlatformMutex.RLock()
	defer fake.registerPlatformMutex.RUnlock()
	return len(fake.registerPlatformArgsForCall)
}

func (fake *FakeClient) RegisterPlatformCalls(stub func(*types.Platform, *query.Parameters) (*types.Platform, error)) {
	fake.registerPlatformMutex.Lock()
	defer fake.registerPlatformMutex.Unlock()
	fake.RegisterPlatformStub = stub
}

func (fake *FakeClient) RegisterPlatformArgsForCall(i int) (*types.Platform, *query.Parameters) {
	fake.registerPlatformMutex.RLock()
	defer fake.registerPlatformMutex.RUnlock()
	argsForCall := fake.registerPlatformArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RegisterPlatformReturns(result1 *types.Platform, result2 error) {
	fake.registerPlatformMutex.Lock()
	defer fake.registerPlatformMutex.Unlock()
	fake.RegisterPlatformStub = nil
	fake.registerPlatformReturns = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterPlatformReturnsOnCall(i int, result1 *types.Platform, result2 error) {
	fake.registerPlatformMutex.Lock()
	defer fake.registerPlatformMutex.Unlock()
	fake.RegisterPlatformStub = nil
	if fake.registerPlatformReturnsOnCall == nil {
		fake.registerPlatformReturnsOnCall = make(map[int]struct {
			result1 *types.Platform
			result2 error
		})
	}
	fake.registerPlatformReturnsOnCall[i] = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterVisibility(arg1 *types.Visibility, arg2 *query.Parameters) (*types.Visibility, error) {
	fake.registerVisibilityMutex.Lock()
	ret, specificReturn := fake.registerVisibilityReturnsOnCall[len(fake.registerVisibilityArgsForCall)]
	fake.registerVisibilityArgsForCall = append(fake.registerVisibilityArgsForCall, struct {
		arg1 *types.Visibility
		arg2 *query.Parameters
	}{arg1, arg2})
	fake.recordInvocation("RegisterVisibility", []interface{}{arg1, arg2})
	fake.registerVisibilityMutex.Unlock()
	if fake.RegisterVisibilityStub != nil {
		return fake.RegisterVisibilityStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.registerVisibilityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RegisterVisibilityCallCount() int {
	fake.registerVisibilityMutex.RLock()
	defer fake.registerVisibilityMutex.RUnlock()
	return len(fake.registerVisibilityArgsForCall)
}

func (fake *FakeClient) RegisterVisibilityCalls(stub func(*types.Visibility, *query.Parameters) (*types.Visibility, error)) {
	fake.registerVisibilityMutex.Lock()
	defer fake.registerVisibilityMutex.Unlock()
	fake.RegisterVisibilityStub = stub
}

func (fake *FakeClient) RegisterVisibilityArgsForCall(i int) (*types.Visibility, *query.Parameters) {
	fake.registerVisibilityMutex.RLock()
	defer fake.registerVisibilityMutex.RUnlock()
	argsForCall := fake.registerVisibilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) RegisterVisibilityReturns(result1 *types.Visibility, result2 error) {
	fake.registerVisibilityMutex.Lock()
	defer fake.registerVisibilityMutex.Unlock()
	fake.RegisterVisibilityStub = nil
	fake.registerVisibilityReturns = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RegisterVisibilityReturnsOnCall(i int, result1 *types.Visibility, result2 error) {
	fake.registerVisibilityMutex.Lock()
	defer fake.registerVisibilityMutex.Unlock()
	fake.RegisterVisibilityStub = nil
	if fake.registerVisibilityReturnsOnCall == nil {
		fake.registerVisibilityReturnsOnCall = make(map[int]struct {
			result1 *types.Visibility
			result2 error
		})
	}
	fake.registerVisibilityReturnsOnCall[i] = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateBroker(arg1 string, arg2 *types.Broker, arg3 *query.Parameters) (*types.Broker, error) {
	fake.updateBrokerMutex.Lock()
	ret, specificReturn := fake.updateBrokerReturnsOnCall[len(fake.updateBrokerArgsForCall)]
	fake.updateBrokerArgsForCall = append(fake.updateBrokerArgsForCall, struct {
		arg1 string
		arg2 *types.Broker
		arg3 *query.Parameters
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateBroker", []interface{}{arg1, arg2, arg3})
	fake.updateBrokerMutex.Unlock()
	if fake.UpdateBrokerStub != nil {
		return fake.UpdateBrokerStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateBrokerReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateBrokerCallCount() int {
	fake.updateBrokerMutex.RLock()
	defer fake.updateBrokerMutex.RUnlock()
	return len(fake.updateBrokerArgsForCall)
}

func (fake *FakeClient) UpdateBrokerCalls(stub func(string, *types.Broker, *query.Parameters) (*types.Broker, error)) {
	fake.updateBrokerMutex.Lock()
	defer fake.updateBrokerMutex.Unlock()
	fake.UpdateBrokerStub = stub
}

func (fake *FakeClient) UpdateBrokerArgsForCall(i int) (string, *types.Broker, *query.Parameters) {
	fake.updateBrokerMutex.RLock()
	defer fake.updateBrokerMutex.RUnlock()
	argsForCall := fake.updateBrokerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdateBrokerReturns(result1 *types.Broker, result2 error) {
	fake.updateBrokerMutex.Lock()
	defer fake.updateBrokerMutex.Unlock()
	fake.UpdateBrokerStub = nil
	fake.updateBrokerReturns = struct {
		result1 *types.Broker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateBrokerReturnsOnCall(i int, result1 *types.Broker, result2 error) {
	fake.updateBrokerMutex.Lock()
	defer fake.updateBrokerMutex.Unlock()
	fake.UpdateBrokerStub = nil
	if fake.updateBrokerReturnsOnCall == nil {
		fake.updateBrokerReturnsOnCall = make(map[int]struct {
			result1 *types.Broker
			result2 error
		})
	}
	fake.updateBrokerReturnsOnCall[i] = struct {
		result1 *types.Broker
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePlatform(arg1 string, arg2 *types.Platform, arg3 *query.Parameters) (*types.Platform, error) {
	fake.updatePlatformMutex.Lock()
	ret, specificReturn := fake.updatePlatformReturnsOnCall[len(fake.updatePlatformArgsForCall)]
	fake.updatePlatformArgsForCall = append(fake.updatePlatformArgsForCall, struct {
		arg1 string
		arg2 *types.Platform
		arg3 *query.Parameters
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdatePlatform", []interface{}{arg1, arg2, arg3})
	fake.updatePlatformMutex.Unlock()
	if fake.UpdatePlatformStub != nil {
		return fake.UpdatePlatformStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updatePlatformReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdatePlatformCallCount() int {
	fake.updatePlatformMutex.RLock()
	defer fake.updatePlatformMutex.RUnlock()
	return len(fake.updatePlatformArgsForCall)
}

func (fake *FakeClient) UpdatePlatformCalls(stub func(string, *types.Platform, *query.Parameters) (*types.Platform, error)) {
	fake.updatePlatformMutex.Lock()
	defer fake.updatePlatformMutex.Unlock()
	fake.UpdatePlatformStub = stub
}

func (fake *FakeClient) UpdatePlatformArgsForCall(i int) (string, *types.Platform, *query.Parameters) {
	fake.updatePlatformMutex.RLock()
	defer fake.updatePlatformMutex.RUnlock()
	argsForCall := fake.updatePlatformArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdatePlatformReturns(result1 *types.Platform, result2 error) {
	fake.updatePlatformMutex.Lock()
	defer fake.updatePlatformMutex.Unlock()
	fake.UpdatePlatformStub = nil
	fake.updatePlatformReturns = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdatePlatformReturnsOnCall(i int, result1 *types.Platform, result2 error) {
	fake.updatePlatformMutex.Lock()
	defer fake.updatePlatformMutex.Unlock()
	fake.UpdatePlatformStub = nil
	if fake.updatePlatformReturnsOnCall == nil {
		fake.updatePlatformReturnsOnCall = make(map[int]struct {
			result1 *types.Platform
			result2 error
		})
	}
	fake.updatePlatformReturnsOnCall[i] = struct {
		result1 *types.Platform
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateVisibility(arg1 string, arg2 *types.Visibility, arg3 *query.Parameters) (*types.Visibility, error) {
	fake.updateVisibilityMutex.Lock()
	ret, specificReturn := fake.updateVisibilityReturnsOnCall[len(fake.updateVisibilityArgsForCall)]
	fake.updateVisibilityArgsForCall = append(fake.updateVisibilityArgsForCall, struct {
		arg1 string
		arg2 *types.Visibility
		arg3 *query.Parameters
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateVisibility", []interface{}{arg1, arg2, arg3})
	fake.updateVisibilityMutex.Unlock()
	if fake.UpdateVisibilityStub != nil {
		return fake.UpdateVisibilityStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateVisibilityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateVisibilityCallCount() int {
	fake.updateVisibilityMutex.RLock()
	defer fake.updateVisibilityMutex.RUnlock()
	return len(fake.updateVisibilityArgsForCall)
}

func (fake *FakeClient) UpdateVisibilityCalls(stub func(string, *types.Visibility, *query.Parameters) (*types.Visibility, error)) {
	fake.updateVisibilityMutex.Lock()
	defer fake.updateVisibilityMutex.Unlock()
	fake.UpdateVisibilityStub = stub
}

func (fake *FakeClient) UpdateVisibilityArgsForCall(i int) (string, *types.Visibility, *query.Parameters) {
	fake.updateVisibilityMutex.RLock()
	defer fake.updateVisibilityMutex.RUnlock()
	argsForCall := fake.updateVisibilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) UpdateVisibilityReturns(result1 *types.Visibility, result2 error) {
	fake.updateVisibilityMutex.Lock()
	defer fake.updateVisibilityMutex.Unlock()
	fake.UpdateVisibilityStub = nil
	fake.updateVisibilityReturns = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateVisibilityReturnsOnCall(i int, result1 *types.Visibility, result2 error) {
	fake.updateVisibilityMutex.Lock()
	defer fake.updateVisibilityMutex.Unlock()
	fake.UpdateVisibilityStub = nil
	if fake.updateVisibilityReturnsOnCall == nil {
		fake.updateVisibilityReturnsOnCall = make(map[int]struct {
			result1 *types.Visibility
			result2 error
		})
	}
	fake.updateVisibilityReturnsOnCall[i] = struct {
		result1 *types.Visibility
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.callMutex.RLock()
	defer fake.callMutex.RUnlock()
	fake.deleteBrokersMutex.RLock()
	defer fake.deleteBrokersMutex.RUnlock()
	fake.deletePlatformsMutex.RLock()
	defer fake.deletePlatformsMutex.RUnlock()
	fake.deleteVisibilitiesMutex.RLock()
	defer fake.deleteVisibilitiesMutex.RUnlock()
	fake.getInfoMutex.RLock()
	defer fake.getInfoMutex.RUnlock()
	fake.labelMutex.RLock()
	defer fake.labelMutex.RUnlock()
	fake.listBrokersMutex.RLock()
	defer fake.listBrokersMutex.RUnlock()
	fake.listOfferingsMutex.RLock()
	defer fake.listOfferingsMutex.RUnlock()
	fake.listPlansMutex.RLock()
	defer fake.listPlansMutex.RUnlock()
	fake.listPlatformsMutex.RLock()
	defer fake.listPlatformsMutex.RUnlock()
	fake.listVisibilitiesMutex.RLock()
	defer fake.listVisibilitiesMutex.RUnlock()
	fake.marketplaceMutex.RLock()
	defer fake.marketplaceMutex.RUnlock()
	fake.registerBrokerMutex.RLock()
	defer fake.registerBrokerMutex.RUnlock()
	fake.registerPlatformMutex.RLock()
	defer fake.registerPlatformMutex.RUnlock()
	fake.registerVisibilityMutex.RLock()
	defer fake.registerVisibilityMutex.RUnlock()
	fake.updateBrokerMutex.RLock()
	defer fake.updateBrokerMutex.RUnlock()
	fake.updatePlatformMutex.RLock()
	defer fake.updatePlatformMutex.RUnlock()
	fake.updateVisibilityMutex.RLock()
	defer fake.updateVisibilityMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ smclient.Client = new(FakeClient)
