
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>binding: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Peripli/service-manager-cli/internal/cmd/binding/bind.go (97.1%)</option>
				
				<option value="file1">github.com/Peripli/service-manager-cli/internal/cmd/binding/get_binding.go (77.8%)</option>
				
				<option value="file2">github.com/Peripli/service-manager-cli/internal/cmd/binding/list_bindings.go (94.7%)</option>
				
				<option value="file3">github.com/Peripli/service-manager-cli/internal/cmd/binding/unbind.go (88.0%)</option>
				
				<option value="file4">github.com/Peripli/service-manager-cli/internal/cmd/broker/delete_broker.go (90.3%)</option>
				
				<option value="file5">github.com/Peripli/service-manager-cli/internal/cmd/broker/get_broker.go (82.1%)</option>
				
				<option value="file6">github.com/Peripli/service-manager-cli/internal/cmd/broker/list_brokers.go (100.0%)</option>
				
				<option value="file7">github.com/Peripli/service-manager-cli/internal/cmd/broker/register_broker.go (97.2%)</option>
				
				<option value="file8">github.com/Peripli/service-manager-cli/internal/cmd/broker/update_broker.go (96.8%)</option>
				
				<option value="file9">github.com/Peripli/service-manager-cli/internal/cmd/commander.go (64.3%)</option>
				
				<option value="file10">github.com/Peripli/service-manager-cli/internal/cmd/curl/curl.go (82.9%)</option>
				
				<option value="file11">github.com/Peripli/service-manager-cli/internal/cmd/info/info.go (100.0%)</option>
				
				<option value="file12">github.com/Peripli/service-manager-cli/internal/cmd/instance/deprovision.go (92.9%)</option>
				
				<option value="file13">github.com/Peripli/service-manager-cli/internal/cmd/instance/get_instance.go (78.0%)</option>
				
				<option value="file14">github.com/Peripli/service-manager-cli/internal/cmd/instance/list_instances.go (100.0%)</option>
				
				<option value="file15">github.com/Peripli/service-manager-cli/internal/cmd/instance/provision.go (90.0%)</option>
				
				<option value="file16">github.com/Peripli/service-manager-cli/internal/cmd/instance/transfer.go (90.7%)</option>
				
				<option value="file17">github.com/Peripli/service-manager-cli/internal/cmd/instance/update_instance.go (92.5%)</option>
				
				<option value="file18">github.com/Peripli/service-manager-cli/internal/cmd/instance/update_sharing_instance.go (84.2%)</option>
				
				<option value="file19">github.com/Peripli/service-manager-cli/internal/cmd/label/label.go (96.7%)</option>
				
				<option value="file20">github.com/Peripli/service-manager-cli/internal/cmd/login/login.go (81.8%)</option>
				
				<option value="file21">github.com/Peripli/service-manager-cli/internal/cmd/logout/logout.go (90.0%)</option>
				
				<option value="file22">github.com/Peripli/service-manager-cli/internal/cmd/offering/list_offerings.go (100.0%)</option>
				
				<option value="file23">github.com/Peripli/service-manager-cli/internal/cmd/offering/marketplace.go (100.0%)</option>
				
				<option value="file24">github.com/Peripli/service-manager-cli/internal/cmd/plan/list_plans.go (100.0%)</option>
				
				<option value="file25">github.com/Peripli/service-manager-cli/internal/cmd/platform/delete_platform.go (93.6%)</option>
				
				<option value="file26">github.com/Peripli/service-manager-cli/internal/cmd/platform/list_platforms.go (100.0%)</option>
				
				<option value="file27">github.com/Peripli/service-manager-cli/internal/cmd/platform/register_platform.go (100.0%)</option>
				
				<option value="file28">github.com/Peripli/service-manager-cli/internal/cmd/platform/update_platform.go (96.9%)</option>
				
				<option value="file29">github.com/Peripli/service-manager-cli/internal/cmd/smctl.go (0.0%)</option>
				
				<option value="file30">github.com/Peripli/service-manager-cli/internal/cmd/status/status.go (95.0%)</option>
				
				<option value="file31">github.com/Peripli/service-manager-cli/internal/cmd/version/version.go (100.0%)</option>
				
				<option value="file32">github.com/Peripli/service-manager-cli/internal/cmd/visibility/delete_visibility.go (91.7%)</option>
				
				<option value="file33">github.com/Peripli/service-manager-cli/internal/cmd/visibility/list_visibilities.go (100.0%)</option>
				
				<option value="file34">github.com/Peripli/service-manager-cli/internal/cmd/visibility/register_visibility.go (100.0%)</option>
				
				<option value="file35">github.com/Peripli/service-manager-cli/internal/cmd/visibility/update_visibility.go (95.2%)</option>
				
				<option value="file36">github.com/Peripli/service-manager-cli/internal/configuration/config_helpers.go (13.6%)</option>
				
				<option value="file37">github.com/Peripli/service-manager-cli/internal/configuration/configuration.go (76.4%)</option>
				
				<option value="file38">github.com/Peripli/service-manager-cli/internal/output/output.go (75.0%)</option>
				
				<option value="file39">github.com/Peripli/service-manager-cli/internal/output/printers.go (75.0%)</option>
				
				<option value="file40">github.com/Peripli/service-manager-cli/internal/util/util.go (60.0%)</option>
				
				<option value="file41">github.com/Peripli/service-manager-cli/main.go (0.0%)</option>
				
				<option value="file42">github.com/Peripli/service-manager-cli/pkg/auth/auth.go (0.0%)</option>
				
				<option value="file43">github.com/Peripli/service-manager-cli/pkg/auth/oidc/client.go (93.0%)</option>
				
				<option value="file44">github.com/Peripli/service-manager-cli/pkg/auth/oidc/oidc.go (76.1%)</option>
				
				<option value="file45">github.com/Peripli/service-manager-cli/pkg/errors/error.go (0.0%)</option>
				
				<option value="file46">github.com/Peripli/service-manager-cli/pkg/httputil/httputil.go (75.0%)</option>
				
				<option value="file47">github.com/Peripli/service-manager-cli/pkg/query/parameters.go (93.3%)</option>
				
				<option value="file48">github.com/Peripli/service-manager-cli/pkg/smclient/client.go (82.0%)</option>
				
				<option value="file49">github.com/Peripli/service-manager-cli/pkg/types/broker.go (95.8%)</option>
				
				<option value="file50">github.com/Peripli/service-manager-cli/pkg/types/operation.go (81.8%)</option>
				
				<option value="file51">github.com/Peripli/service-manager-cli/pkg/types/platform.go (100.0%)</option>
				
				<option value="file52">github.com/Peripli/service-manager-cli/pkg/types/service_binding.go (87.9%)</option>
				
				<option value="file53">github.com/Peripli/service-manager-cli/pkg/types/service_instance.go (87.9%)</option>
				
				<option value="file54">github.com/Peripli/service-manager-cli/pkg/types/service_offering.go (75.6%)</option>
				
				<option value="file55">github.com/Peripli/service-manager-cli/pkg/types/service_plan.go (78.9%)</option>
				
				<option value="file56">github.com/Peripli/service-manager-cli/pkg/types/tableData.go (90.5%)</option>
				
				<option value="file57">github.com/Peripli/service-manager-cli/pkg/types/visibility.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package binding

import (
        "encoding/json"
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager-cli/pkg/types"

        "fmt"
        "github.com/spf13/cobra"
)

// BindCmd wraps the smctl bind command
type BindCmd struct {
        *cmd.Context

        binding        types.ServiceBinding
        instanceName   string
        parametersJSON string

        outputFormat output.Format
}

// NewBindCmd returns new bind command with context
func NewBindCmd(context *cmd.Context) *BindCmd <span class="cov8" title="1">{
        return &amp;BindCmd{Context: context, binding: types.ServiceBinding{}}
}</span>

// Prepare returns cobra command
func (bc *BindCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:   "bind [instance-name] [binding-name]",
                Short: "Creates binding in SM",
                Long:  `Creates binding in SM`,

                PreRunE: prepare(bc, bc.Context),
                RunE:    cmd.RunE(bc),
        }

        result.Flags().StringVarP(&amp;bc.binding.ServiceInstanceID, "id", "", "", "ID of the service instance. Required when name is ambiguous")
        result.Flags().StringVarP(&amp;bc.parametersJSON, "parameters", "c", "", "Valid JSON object containing binding parameters")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;bc.Parameters)
        cmd.AddModeFlag(result.Flags(), "async")

        return result
}</span>

// Validate validates command's arguments
func (bc *BindCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("instance and binding names are required")
        }</span>

        <span class="cov8" title="1">bc.instanceName = args[0]
        bc.binding.Name = args[1]
        return nil</span>
}

// Run runs the command's logic
func (bc *BindCmd) Run() error <span class="cov8" title="1">{
        if bc.binding.ServiceInstanceID == "" </span><span class="cov8" title="1">{
                instanceToBind, err := bc.Client.ListInstances(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", bc.instanceName),
                        },
                        GeneralParams: bc.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(instanceToBind.ServiceInstances) &lt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("service instance with name %s not found", bc.instanceName)
                }</span>
                <span class="cov8" title="1">if len(instanceToBind.ServiceInstances) &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("more than one service instance with name %s found. Use --id flag to specify id of the instance to bind", bc.instanceName)
                }</span>
                <span class="cov8" title="1">bc.binding.ServiceInstanceID = instanceToBind.ServiceInstances[0].ID</span>
        }

        <span class="cov8" title="1">bc.binding.Parameters = json.RawMessage(bc.parametersJSON)
        resultBinding, location, err := bc.Client.Bind(&amp;bc.binding, &amp;bc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov8" title="1">{
                cmd.CommonHandleAsyncExecution(bc.Context, location, fmt.Sprintf("Service Binding %s successfully scheduled. To see status of the operation use:\n", bc.binding.Name))
                return nil
        }</span>

        <span class="cov8" title="1">resultBinding.ServiceInstanceName = bc.instanceName
        output.PrintServiceManagerObject(bc.Output, bc.outputFormat, resultBinding)
        output.Println(bc.Output)
        return nil</span>
}

// SetOutputFormat set output format
func (bc *BindCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        bc.outputFormat = format
}</span>

// HideUsage hide command's usage
func (bc *BindCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package binding

import (
        "fmt"
        "strings"

        "github.com/Peripli/service-manager-cli/pkg/types"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/spf13/cobra"
)

// GetBindingCmd wraps the smctl get-binding command
type GetBindingCmd struct {
        *cmd.Context

        bindingName   string
        outputFormat  output.Format
        bindingParams *bool
}

// NewGetBindingCmd returns new get status command with context
func NewGetBindingCmd(context *cmd.Context) *GetBindingCmd <span class="cov8" title="1">{
        return &amp;GetBindingCmd{Context: context}
}</span>

// Run runs the command's logic
func (gb *GetBindingCmd) Run() error <span class="cov8" title="1">{
        bindings, err := gb.Client.ListBindings(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", gb.bindingName),
                },
                GeneralParams: gb.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(bindings.ServiceBindings) &lt; 1 </span><span class="cov8" title="1">{
                output.PrintMessage(gb.Output, "No binding found with name: %s", gb.bindingName)
                return nil
        }</span>
        <span class="cov8" title="1">if *gb.bindingParams </span><span class="cov8" title="1">{
                return gb.printParameters(bindings)
        }</span>

        <span class="cov8" title="1">resultBindings := &amp;types.ServiceBindings{Vertical: true}
        for _, binding := range bindings.ServiceBindings </span><span class="cov8" title="1">{
                bd, err := gb.Client.GetBindingByID(binding.ID, &amp;gb.Parameters)
                if err != nil </span><span class="cov0" title="0">{
                        // The binding could be deleted after List and before Get
                        if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">instance, err := gb.Client.GetInstanceByID(bd.ServiceInstanceID, &amp;gb.Parameters)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">bd.ServiceInstanceName = instance.Name
                resultBindings.ServiceBindings = append(resultBindings.ServiceBindings, *bd)</span>
        }

        <span class="cov8" title="1">if len(resultBindings.ServiceBindings) &lt; 1 </span><span class="cov0" title="0">{
                output.PrintMessage(gb.Output, "No binding found with name: %s", gb.bindingName)
                return nil
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(gb.Output, gb.outputFormat, resultBindings)
        output.Println(gb.Output)

        return nil</span>
}

func (gb *GetBindingCmd) printParameters(bindings *types.ServiceBindings) error <span class="cov8" title="1">{
        for _, binding := range bindings.ServiceBindings </span><span class="cov8" title="1">{
                parameters, err := gb.Client.GetBindingParameters(binding.ID, &amp;gb.Parameters)
                if err != nil </span><span class="cov0" title="0">{
                        // The binding could be deleted after List and before Get
                        if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">output.PrintMessage(gb.Output, "Unable to show configuration parameters for service binding id: %s\n", binding.ID)
                        output.PrintMessage(gb.Output, "The error: %s\n\n", err)
                        continue</span>
                }
                <span class="cov8" title="1">if len(parameters) == 0 </span><span class="cov8" title="1">{
                        output.PrintMessage(gb.Output, "No configuration parameters are set for service binding id: %s\n\n", binding.ID)
                        continue</span>
                }

                <span class="cov8" title="1">output.PrintMessage(gb.Output, "Showing configuration parameters for service binding id: %s \n", binding.ID)
                output.PrintMessage(gb.Output, "The parameters: \n")
                output.PrintMessage(gb.Output, "%s \n\n ", output.PrintParameters(parameters))</span>
        }

        <span class="cov8" title="1">output.Println(gb.Output)
        return nil</span>
}

// Validate validates command's arguments
func (gb *GetBindingCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 || len(args[0]) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("binding name is required")
        }</span>

        <span class="cov8" title="1">gb.bindingName = args[0]

        return nil</span>
}

// SetOutputFormat set output format
func (gb *GetBindingCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        gb.outputFormat = format
}</span>

// HideUsage hide command's usage
func (gb *GetBindingCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (gb *GetBindingCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "get-binding [name]",
                Aliases: []string{"gsb"},
                Short:   "Get single binding",
                Long:    `Get single binding by its name`,
                PreRunE: prepare(gb, gb.Context),
                RunE:    cmd.RunE(gb),
        }
        gb.bindingParams = result.PersistentFlags().Bool("show-binding-params", false, "Show the service binding configuration parameters")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;gb.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package binding

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// ListBindingsCmd wraps the smctl list-bindings command
type ListBindingsCmd struct {
        *cmd.Context

        outputFormat output.Format
}

// NewListBindingsCmd returns new list-bindings command with context
func NewListBindingsCmd(context *cmd.Context) *ListBindingsCmd <span class="cov8" title="1">{
        return &amp;ListBindingsCmd{Context: context}
}</span>

// Run runs the command's logic
func (li *ListBindingsCmd) Run() error <span class="cov8" title="1">{
        bindings, err := li.Client.ListBindings(&amp;li.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for i := range bindings.ServiceBindings </span><span class="cov8" title="1">{
                instance, err := li.Client.GetInstanceByID(bindings.ServiceBindings[i].ServiceInstanceID, &amp;li.Parameters)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">bindings.ServiceBindings[i].ServiceInstanceName = instance.Name</span>
        }

        <span class="cov8" title="1">output.PrintServiceManagerObject(li.Output, li.outputFormat, bindings)
        output.Println(li.Output)

        return nil</span>
}

// SetOutputFormat sets output format
func (li *ListBindingsCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        li.outputFormat = format
}</span>

// HideUsage hides command's usage
func (li *ListBindingsCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (li *ListBindingsCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "list-bindings",
                Aliases: []string{"lsb"},
                Short:   "List service-bindings",
                Long:    `List all service-bindings.`,
                PreRunE: prepare(li, li.Context),
                RunE:    cmd.RunE(li),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddQueryingFlags(result.Flags(), &amp;li.Parameters)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;li.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package binding

import (
        "fmt"
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager/pkg/web"
        "github.com/spf13/cobra"
        "io"
)

// UnbindCmd wraps the smctl bind command
type UnbindCmd struct {
        *cmd.Context

        input io.Reader
        force bool
        forceDelete bool

        instanceName string
        bindingID    string
        bindingName  string
}

// NewUnbindCmd returns new bind command with context
func NewUnbindCmd(context *cmd.Context, input io.Reader) *UnbindCmd <span class="cov8" title="1">{
        return &amp;UnbindCmd{Context: context, input: input}
}</span>

// Prepare returns cobra command
func (ubc *UnbindCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:   "unbind [instance-name] [binding-name]",
                Short: "Deletes a binding from SM",
                Long:  `Deletes a binding from SM`,

                PreRunE: prepare(ubc, ubc.Context),
                RunE:    cmd.RunE(ubc),
        }

        forceUsage := "Use this parameter to delete a resource without raising a confirmation message."
        forceDeleteUsage := "Delete the service binding and all of its associated resources from the database. Use this parameter if the service binding cannot be properly deleted. This parameter can only be used by operators with technical access."

        result.Flags().BoolVarP(&amp;ubc.force, "force", "f", false, forceUsage)
        result.Flags().BoolVarP(&amp;ubc.forceDelete, "force-delete", "", false, forceDeleteUsage)
        result.Flags().StringVarP(&amp;ubc.bindingID, "id", "", "", "ID of the service binding. Required when name is ambiguous.")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;ubc.Parameters)
        cmd.AddModeFlag(result.Flags(), "async")

        return result
}</span>

// Validate validates command's arguments
func (ubc *UnbindCmd) Validate(args []string) error <span class="cov8" title="1">{
        if ubc.bindingID != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("instance and binding names are required")
        }</span>

        <span class="cov8" title="1">ubc.instanceName = args[0]
        ubc.bindingName = args[1]
        return nil</span>
}

// Run runs the command's logic
func (ubc *UnbindCmd) Run() error <span class="cov8" title="1">{
        if ubc.bindingID == "" </span><span class="cov8" title="1">{
                instanceToUnbind, err := ubc.Client.ListInstances(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", ubc.instanceName),
                        },
                        GeneralParams: ubc.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(instanceToUnbind.ServiceInstances) &lt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("service instance with name %s not found", ubc.instanceName)
                }</span>
                <span class="cov8" title="1">if len(instanceToUnbind.ServiceInstances) &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("more than one service instance with name %s found. Use --id flag to specify id of the binding to be deleted", ubc.instanceName)
                }</span>

                <span class="cov8" title="1">bindingsToDelete, err := ubc.Client.ListBindings(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", ubc.bindingName),
                                fmt.Sprintf("service_instance_id eq '%s'", instanceToUnbind.ServiceInstances[0].ID),
                        },
                        GeneralParams: ubc.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(bindingsToDelete.ServiceBindings) &lt; 1 </span><span class="cov8" title="1">{
                        output.PrintMessage(ubc.Output, "Service Binding with name %s for instance with name %s not found", ubc.bindingName, ubc.instanceName)
                        return nil
                }</span>
                <span class="cov8" title="1">ubc.bindingID = bindingsToDelete.ServiceBindings[0].ID</span>
        }

        <span class="cov8" title="1">if ubc.forceDelete </span><span class="cov8" title="1">{
                ubc.Parameters.GeneralParams = append(ubc.Parameters.GeneralParams, fmt.Sprintf("%s=%s", web.QueryParamCascade, "true"))
                ubc.Parameters.GeneralParams = append(ubc.Parameters.GeneralParams, fmt.Sprintf("%s=%s", web.QueryParamForce, "true"))
        }</span>

        <span class="cov8" title="1">location, err := ubc.Client.Unbind(ubc.bindingID, &amp;ubc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                output.PrintMessage(ubc.Output, "Could not delete service binding. Reason: ")
                return err
        }</span>
        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov0" title="0">{
                cmd.CommonHandleAsyncExecution(ubc.Context, location, fmt.Sprintf("Service Binding %s successfully scheduled for deletion. To see status of the operation use:\n", ubc.bindingName))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintMessage(ubc.Output, "Service Binding successfully deleted.\n")
        return nil</span>
}

// AskForConfirmation asks the user to confirm deletion
func (ubc *UnbindCmd) AskForConfirmation() (bool, error) <span class="cov8" title="1">{
        if !ubc.force </span><span class="cov8" title="1">{
                message := fmt.Sprintf("Do you really want to delete binding with name [%s] for instance with name %s (Y/n): ", ubc.bindingName, ubc.instanceName)
                return cmd.CommonConfirmationPrompt(message, ubc.Context, ubc.input)
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// PrintDeclineMessage prints confirmation decline message to the user
func (ubc *UnbindCmd) PrintDeclineMessage() <span class="cov8" title="1">{
        cmd.CommonPrintDeclineMessage(ubc.Output)
}</span>

// HideUsage hide command's usage
func (ubc *UnbindCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package broker

import (
        "fmt"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "io"

        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
)

// DeleteBrokerCmd wraps the smctl delete-broker command
type DeleteBrokerCmd struct {
        *cmd.Context

        input io.Reader
        force bool

        name string
}

// NewDeleteBrokerCmd returns new delete-broker command with context
func NewDeleteBrokerCmd(context *cmd.Context, input io.Reader) *DeleteBrokerCmd <span class="cov8" title="1">{
        return &amp;DeleteBrokerCmd{Context: context, input: input}
}</span>

// Validate validates command's arguments
func (dbc *DeleteBrokerCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("single [name] is required")
        }</span>

        <span class="cov8" title="1">dbc.name = args[0]

        return nil</span>
}

// Run runs the command's logic
func (dbc *DeleteBrokerCmd) Run() error <span class="cov8" title="1">{
        toDeleteBrokers, err := dbc.Client.ListBrokers(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", dbc.name),
                },
                GeneralParams: dbc.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(toDeleteBrokers.Brokers) &lt; 1 </span><span class="cov8" title="1">{
                output.PrintMessage(dbc.Output, "Service Broker not found.\n")
                return nil
        }</span>
        <span class="cov8" title="1">location, err := dbc.Client.DeleteBroker(toDeleteBrokers.Brokers[0].ID, &amp;dbc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                output.PrintMessage(dbc.Output, "Could not delete broker. Reason: ")
                return err
        }</span>
        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov0" title="0">{
                cmd.CommonHandleAsyncExecution(dbc.Context, location, fmt.Sprintf("Service Broker %s successfully scheduled for deletion. To see status of the operation use:\n", dbc.name))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintMessage(dbc.Output, "Service Broker successfully deleted.\n")
        return nil</span>
}

// HideUsage hide command's usage
func (dbc *DeleteBrokerCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// AskForConfirmation asks the user to confirm deletion
func (dbc *DeleteBrokerCmd) AskForConfirmation() (bool, error) <span class="cov8" title="1">{
        if !dbc.force </span><span class="cov8" title="1">{
                message := fmt.Sprintf("Do you really want to delete broker with name [%s] (Y/n): ", dbc.name)
                return cmd.CommonConfirmationPrompt(message, dbc.Context, dbc.input)
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// PrintDeclineMessage prints confirmation decline message to the user
func (dbc *DeleteBrokerCmd) PrintDeclineMessage() <span class="cov8" title="1">{
        cmd.CommonPrintDeclineMessage(dbc.Output)
}</span>

// Prepare returns cobra command
func (dbc *DeleteBrokerCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "delete-broker [name]",
                Aliases: []string{"db"},
                Short:   "Deletes broker",
                Long:    `Deletes broker by name.`,
                PreRunE: prepare(dbc, dbc.Context),
                RunE:    cmd.RunE(dbc),
        }

        result.Flags().BoolVarP(&amp;dbc.force, "force", "f", false, "Force delete without confirmation")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;dbc.Parameters)
        cmd.AddModeFlag(result.Flags(), "sync")

        return result
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package broker

import (
        "fmt"
        "strings"

        "github.com/Peripli/service-manager-cli/pkg/query"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// GetBrokerCmd wraps the smctl list-brokers command
type GetBrokerCmd struct {
        *cmd.Context

        name         string
        prepare      cmd.PrepareFunc
        outputFormat output.Format
}

// NewGetBrokerCmd returns new get status command with context
func NewGetBrokerCmd(context *cmd.Context) *GetBrokerCmd <span class="cov8" title="1">{
        return &amp;GetBrokerCmd{Context: context}
}</span>

// Run runs the command's logic
func (gb *GetBrokerCmd) Run() error <span class="cov8" title="1">{
        brokers, err := gb.Client.ListBrokers(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", gb.name),
                },
                GeneralParams: gb.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(brokers.Brokers) &lt; 1 </span><span class="cov8" title="1">{
                output.PrintMessage(gb.Output, "No broker found with name: %s", gb.name)
                return nil
        }</span>

        <span class="cov8" title="1">id := brokers.Brokers[0].ID
        broker, err := gb.Client.GetBrokerByID(id, &amp;gb.Parameters)
        if err != nil </span><span class="cov0" title="0">{
                // The broker could be deleted after List and before Get
                if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov0" title="0">{
                        output.PrintMessage(gb.Output, "No broker found with name: %s", gb.name)
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">output.PrintServiceManagerObject(gb.Output, gb.outputFormat, broker)
        output.Println(gb.Output)

        return nil</span>
}

// Validate validates command's arguments
func (gb *GetBrokerCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 || len(args[0]) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("name is required")
        }</span>

        <span class="cov8" title="1">gb.name = args[0]

        return nil</span>
}

// SetOutputFormat set output format
func (gb *GetBrokerCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        gb.outputFormat = format
}</span>

// HideUsage hide command's usage
func (gb *GetBrokerCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (gb *GetBrokerCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        gb.prepare = prepare
        result := &amp;cobra.Command{
                Use:     "get-broker [name]",
                Aliases: []string{"gb"},
                Short:   "Get single broker",
                Long:    `Get single broker by its name`,
                PreRunE: gb.prepare(gb, gb.Context),
                RunE:    cmd.RunE(gb),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;gb.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package broker

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// ListBrokersCmd wraps the smctl list-brokers command
type ListBrokersCmd struct {
        *cmd.Context

        prepare      cmd.PrepareFunc
        outputFormat output.Format
}

// NewListBrokersCmd returns new list-brokers command with context
func NewListBrokersCmd(context *cmd.Context) *ListBrokersCmd <span class="cov8" title="1">{
        return &amp;ListBrokersCmd{Context: context}
}</span>

// Run runs the command's logic
func (lb *ListBrokersCmd) Run() error <span class="cov8" title="1">{
        brokers, err := lb.Client.ListBrokers(&amp;lb.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(lb.Output, lb.outputFormat, brokers)
        output.Println(lb.Output)

        return nil</span>
}

// SetOutputFormat set output format
func (lb *ListBrokersCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        lb.outputFormat = format
}</span>

// HideUsage hide command's usage
func (lb *ListBrokersCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (lb *ListBrokersCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        lb.prepare = prepare
        result := &amp;cobra.Command{
                Use:     "list-brokers",
                Aliases: []string{"lb"},
                Short:   "List brokers",
                Long:    `List all brokers.`,
                PreRunE: lb.prepare(lb, lb.Context),
                RunE:    cmd.RunE(lb),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddQueryingFlags(result.Flags(), &amp;lb.Parameters)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;lb.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package broker

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/types"

        "fmt"
        "strings"

        "errors"

        "github.com/spf13/cobra"
)

// RegisterBrokerCmd wraps the smctl register-broker command
type RegisterBrokerCmd struct {
        *cmd.Context

        broker types.Broker

        basicString  string
        outputFormat output.Format
}

// NewRegisterBrokerCmd returns new register-broker command with context
func NewRegisterBrokerCmd(context *cmd.Context) *RegisterBrokerCmd <span class="cov8" title="1">{
        return &amp;RegisterBrokerCmd{Context: context, broker: types.Broker{}}
}</span>

// Prepare returns cobra command
func (rbc *RegisterBrokerCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "register-broker [name] [url] &lt;description&gt;",
                Aliases: []string{"rb"},
                Short:   "Registers a broker",
                Long:    `Registers a broker`,

                PreRunE: prepare(rbc, rbc.Context),
                RunE:    cmd.RunE(rbc),
        }

        result.Flags().StringVarP(&amp;rbc.basicString, "basic", "b", "", "Sets the username and password for basic authentication. Format is &lt;username:password&gt;.")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;rbc.Parameters)
        cmd.AddModeFlag(result.Flags(), "sync")

        return result
}</span>

// Validate validates command's arguments
func (rbc *RegisterBrokerCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("name and URL are required")
        }</span>

        <span class="cov8" title="1">if rbc.basicString == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("--basic flag is required")
        }</span>

        <span class="cov8" title="1">rbc.broker.Name = args[0]
        rbc.broker.URL = args[1]

        if len(args) &gt; 2 </span><span class="cov8" title="1">{
                rbc.broker.Description = args[2]
        }</span>

        <span class="cov8" title="1">return rbc.parseCredentials()</span>
}

// Run runs the command's logic
func (rbc *RegisterBrokerCmd) Run() error <span class="cov8" title="1">{
        resultBroker, location, err := rbc.Client.RegisterBroker(&amp;rbc.broker, &amp;rbc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov8" title="1">{
                cmd.CommonHandleAsyncExecution(rbc.Context, location, fmt.Sprintf("Service Broker %s successfully scheduled for registration. To see status of the operation use:\n", rbc.broker.Name))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(rbc.Output, rbc.outputFormat, resultBroker)
        output.Println(rbc.Output)
        return nil</span>
}

// SetOutputFormat set output format
func (rbc *RegisterBrokerCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        rbc.outputFormat = format
}</span>

// HideUsage hide command's usage
func (rbc *RegisterBrokerCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

func (rbc *RegisterBrokerCmd) parseCredentials() error <span class="cov8" title="1">{
        if rbc.basicString != "" </span><span class="cov8" title="1">{
                splitBasicString := strings.Split(rbc.basicString, ":")
                if len(splitBasicString) != 2 </span><span class="cov8" title="1">{
                        return errors.New("basic string is invalid")
                }</span>
                <span class="cov8" title="1">user := splitBasicString[0]
                password := splitBasicString[1]
                basic := types.Basic{User: user, Password: password}
                rbc.broker.Credentials = &amp;types.Credentials{Basic: basic}</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package broker

import (
        "encoding/json"
        "fmt"
        "github.com/Peripli/service-manager-cli/pkg/query"

        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/pkg/types"
)

// UpdateBrokerCmd wraps the smctl update-broker command
type UpdateBrokerCmd struct {
        *cmd.Context

        outputFormat  output.Format
        name          string
        updatedBroker *types.Broker
}

// NewUpdateBrokerCmd returns new update-broker command with context
func NewUpdateBrokerCmd(context *cmd.Context) *UpdateBrokerCmd <span class="cov8" title="1">{
        return &amp;UpdateBrokerCmd{Context: context}
}</span>

// Validate validates command's arguments
func (ubc *UpdateBrokerCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("[name] is required")
        }</span>

        <span class="cov8" title="1">ubc.name = args[0]

        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("nothing to update. Broker JSON is not provided")
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal([]byte(args[1]), &amp;ubc.updatedBroker); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("broker JSON is invalid. Reason: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Run runs the command's logic
func (ubc *UpdateBrokerCmd) Run() error <span class="cov8" title="1">{
        toUpdateBrokers, err := ubc.Client.ListBrokers(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", ubc.name),
                },
                GeneralParams: ubc.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(toUpdateBrokers.Brokers) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("broker with name %s not found", ubc.name)
        }</span>
        <span class="cov8" title="1">toUpdateBroker := toUpdateBrokers.Brokers[0]
        result, location, err := ubc.Client.UpdateBroker(toUpdateBroker.ID, ubc.updatedBroker, &amp;ubc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov8" title="1">{
                cmd.CommonHandleAsyncExecution(ubc.Context, location, fmt.Sprintf("Service Broker %s successfully scheduled for update. To see status of the operation use:\n", toUpdateBroker.Name))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(ubc.Output, ubc.outputFormat, result)
        output.Println(ubc.Output)
        return nil</span>
}

// HideUsage hide command's usage
func (ubc *UpdateBrokerCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (ubc *UpdateBrokerCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "update-broker [name] &lt;json_broker&gt;",
                Aliases: []string{"ub"},
                Short:   "Updates broker",
                Long: `Update broker with name.
Example:
smctl update-broker broker '{"name": "new-name", "description": "new-description", "broker_url": "http://broker.com", "credentials": { "basic": { "username": "admin", "password": "admin" } }}'`,
                PreRunE: prepare(ubc, ubc.Context),
                RunE:    cmd.RunE(ubc),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;ubc.Parameters)
        cmd.AddModeFlag(result.Flags(), "sync")

        return result
}</span>

// SetOutputFormat set output format
func (ubc *UpdateBrokerCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        ubc.outputFormat = format
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package cmd

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"
        "syscall"

        "github.com/Peripli/service-manager-cli/pkg/query"

        "github.com/spf13/cobra"
        "github.com/spf13/pflag"

        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/auth"
        "github.com/Peripli/service-manager-cli/pkg/auth/oidc"
        "github.com/Peripli/service-manager-cli/pkg/smclient"
)

var supportedFormats = map[string]output.Format{
        "text": output.FormatText,
        "json": output.FormatJSON,
        "yaml": output.FormatYAML,
}

// CommandPreparator used to wrap CLI commands
type CommandPreparator interface {
        Prepare(PrepareFunc) *cobra.Command
}

// Command provides common logic for SM commands
type Command interface {
        Run() error
}

// ValidatedCommand should be implemented if the command will have validation
type ValidatedCommand interface {
        // Validate command usage in the implementation of this method
        Validate([]string) error
}

// HiddenUsageCommand should be implemented if the command should not print its usage
type HiddenUsageCommand interface {
        // HideUsage returns true when usage should be hidden and false otherwise
        HideUsage() bool
}

// FormattedCommand should be implemented if the command supports different output formatting through a --format or -f flag
type FormattedCommand interface {
        // SetOutputFormat sets the command's output format
        SetOutputFormat(output.Format)
}

//ConfirmedCommand should be implemented if the command should ask for user confirmation prior execution
type ConfirmedCommand interface {
        // AskForConfirmation asks user to confirm the execution of desired operation
        AskForConfirmation() (bool, error)
        // PrintDeclineMessage prints message to the user if the confirmation is declined
        PrintDeclineMessage()
}

// PrepareFunc is function type which executes common prepare logic for commands
type PrepareFunc func(cmd Command, ctx *Context) func(*cobra.Command, []string) error

func newMissingLoginError() error <span class="cov0" title="0">{
        return errors.New(`no logged user, use "smctl login" to log in`)
}</span>

// SmPrepare creates a SM client for SM commands
func SmPrepare(cmd Command, ctx *Context) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(c *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                if err := CommonPrepare(cmd, ctx)(c, args); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">mode, err := c.Flags().GetString("mode")
                if err == nil </span><span class="cov8" title="1">{
                        if mode != "async" &amp;&amp; mode != "sync" </span><span class="cov0" title="0">{
                                return fmt.Errorf("only sync/async modes are supported")
                        }</span>
                        <span class="cov8" title="1">ctx.Parameters.GeneralParams = append(ctx.Parameters.GeneralParams, fmt.Sprintf("async=%t", mode == "async"))</span>
                }

                <span class="cov8" title="1">if ctx.Client == nil </span><span class="cov0" title="0">{
                        settings, err := ctx.Configuration.Load()
                        if err != nil </span><span class="cov0" title="0">{
                                if isNotExistError(err) </span><span class="cov0" title="0">{
                                        return newMissingLoginError()
                                }</span>
                                <span class="cov0" title="0">return err</span> // error is descriptive enough, no need to wrap it
                        }
                        <span class="cov0" title="0">if settings.AccessToken == "" </span><span class="cov0" title="0">{
                                return newMissingLoginError()
                        }</span>

                        <span class="cov0" title="0">oidcClient, err := oidc.NewClient(&amp;auth.Options{
                                AuthorizationEndpoint: settings.AuthorizationEndpoint,
                                TokenEndpoint:         settings.TokenEndpoint,
                                ClientID:              settings.ClientID,
                                ClientSecret:          settings.ClientSecret,
                                IssuerURL:             settings.IssuerURL,
                                SSLDisabled:           settings.SSLDisabled,
                                TokenBasicAuth:        settings.TokenBasicAuth,
                        }, &amp;settings.Token)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">token, err := oidcClient.Token()
                        if err != nil </span><span class="cov0" title="0">{
                                if err == oidc.ErrTokenExpired </span><span class="cov0" title="0">{
                                        return errors.New(`access token has expired, use "smctl login" to log in`)
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("error refreshing token: %s", err)</span>
                        }
                        <span class="cov0" title="0">if settings.AccessToken != token.AccessToken </span><span class="cov0" title="0">{
                                settings.Token = *token
                                if saveErr := ctx.Configuration.Save(settings); saveErr != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("error saving configuration: %s", saveErr)
                                }</span>
                        }

                        <span class="cov0" title="0">ctx.Client = smclient.NewClient(ctx.Ctx, oidcClient, settings.URL)</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}

func isNotExistError(err error) bool <span class="cov0" title="0">{
        e, ok := err.(*os.PathError)
        if ok </span><span class="cov0" title="0">{
                errno, ok := e.Err.(syscall.Errno)
                return ok &amp;&amp; errno == syscall.ENOENT
        }</span>
        <span class="cov0" title="0">return false</span>
}

// CommonPrepare provides common pre-run logic for SM commands
func CommonPrepare(cmd Command, ctx *Context) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(c *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                if valCmd, ok := cmd.(ValidatedCommand); ok </span><span class="cov8" title="1">{
                        if err := valCmd.Validate(args); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if fmtCmd, ok := cmd.(FormattedCommand); ok </span><span class="cov8" title="1">{
                        outputFormat, err := getOutputFormat(c.Flags())
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">fmtCmd.SetOutputFormat(outputFormat)</span>
                }

                <span class="cov8" title="1">if huCmd, ok := cmd.(HiddenUsageCommand); ok </span><span class="cov8" title="1">{
                        c.SilenceUsage = huCmd.HideUsage()
                }</span>

                <span class="cov8" title="1">return nil</span>
        }
}

// RunE provides common run logic for SM commands
func RunE(cmd Command) func(*cobra.Command, []string) error <span class="cov8" title="1">{
        return func(c *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                if confirmedCmd, ok := cmd.(ConfirmedCommand); ok </span><span class="cov8" title="1">{
                        confirmed, err := confirmedCmd.AskForConfirmation()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if !confirmed </span><span class="cov8" title="1">{
                                confirmedCmd.PrintDeclineMessage()
                                return nil
                        }</span>
                }
                <span class="cov8" title="1">return cmd.Run()</span>
        }
}

// AddFormatFlag adds the --output (-o) flag.
func AddFormatFlag(flags *pflag.FlagSet) <span class="cov8" title="1">{
        flags.StringP("output", "o", "", "output format")
}</span>

// AddFormatFlagDefault is same as AddFormatFlag but allows to set default value.
func AddFormatFlagDefault(flags *pflag.FlagSet, defValue string) <span class="cov8" title="1">{
        flags.StringP("output", "o", defValue, "output format")
}</span>

// AddQueryingFlags adds --field-query (-f) and --label-query (-l) flags
func AddQueryingFlags(flags *pflag.FlagSet, parameters *query.Parameters) <span class="cov8" title="1">{
        flags.StringArrayVarP(&amp;parameters.FieldQuery, "field-query", "f", nil, "Filtering based on field querying")
        flags.StringArrayVarP(&amp;parameters.LabelQuery, "label-query", "l", nil, "Filtering based on label querying")
}</span>

// AddCommonQueryFlag adds the CLI param that provides general query parameters
func AddCommonQueryFlag(flags *pflag.FlagSet, parameters *query.Parameters) <span class="cov8" title="1">{
        flags.StringArrayVarP(&amp;parameters.GeneralParams, "param", "", nil, "Additional query parameters in the form key=value")
}</span>
func AddSupportedEnvironmentFlag(flags *pflag.FlagSet, parameters *query.Parameters, description string) <span class="cov8" title="1">{
        flags.StringVarP(&amp;parameters.Environment, "environment", "e", "", description)
}</span>

// AddModeFlag adds the --mode flag for SM calls.
func AddModeFlag(flags *pflag.FlagSet, defValue string) <span class="cov8" title="1">{
        flags.StringP("mode", "", defValue, "How calls to SM are performed sync or async")
}</span>

// CommonHandleAsyncExecution handles async execution of SM calls
func CommonHandleAsyncExecution(ctx *Context, location string, message string) <span class="cov8" title="1">{
        output.PrintMessage(ctx.Output, message)
        output.PrintMessage(ctx.Output, "smctl status %s\n", location)
}</span>

//CommonConfirmationPrompt provides common logic for confirmation of an operation
func CommonConfirmationPrompt(message string, ctx *Context, input io.Reader) (bool, error) <span class="cov8" title="1">{
        output.PrintMessage(ctx.Output, message)

        positiveResponses := map[string]bool{
                "y":   true,
                "Y":   true,
                "yes": true,
                "Yes": true,
                "YES": true,
        }

        bufReader := bufio.NewReader(input)
        resp, isPrefix, err := bufReader.ReadLine()
        if isPrefix </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return positiveResponses[string(resp)], nil</span>
}

//CommonPrintDeclineMessage provides common confirmation declined message
func CommonPrintDeclineMessage(wr io.Writer) <span class="cov8" title="1">{
        output.PrintMessage(wr, "Delete declined")
}</span>

func getOutputFormat(flags *pflag.FlagSet) (output.Format, error) <span class="cov8" title="1">{
        outputFormat, _ := flags.GetString("output")
        outputFormat = strings.ToLower(outputFormat)

        if outputFormat == "" </span><span class="cov8" title="1">{
                return output.FormatText, nil
        }</span>
        <span class="cov8" title="1">format, exists := supportedFormats[outputFormat]
        if !exists </span><span class="cov8" title="1">{
                return output.FormatUnknown, errors.New("unknown output: " + outputFormat)
        }</span>
        <span class="cov8" title="1">return format, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package curl

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "path/filepath"
        "strings"

        "github.com/spf13/afero"

        "github.com/Peripli/service-manager-cli/internal/output"

        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
)

// Cmd wraps the smctl curl command
type Cmd struct {
        *cmd.Context
        Fs afero.Fs

        outputFormat output.Format

        path   string
        method string
        body   string
}

// NewCurlCmd returns new curl command with context
func NewCurlCmd(context *cmd.Context, fs afero.Fs) *Cmd <span class="cov8" title="1">{
        return &amp;Cmd{Context: context, Fs: fs}
}</span>

// Prepare returns the cobra command
func (c *Cmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "curl [path]",
                Aliases: []string{"c"},
                Short:   "call arbitrary SM endpoint",
                Long:    `call arbitrary SM endpoint`,

                PreRunE: prepare(c, c.Context),
                RunE:    cmd.RunE(c),
        }

        // TODO: Add flag for headers
        result.Flags().StringVarP(&amp;c.method, "X", "X", "GET", "HTTP method (GET,POST,PUT,DELETE,etc)")
        result.Flags().StringVarP(&amp;c.body, "d", "d", "", "HTTP data to include in the request body, or '@' followed by a file name to read the data from")
        cmd.AddFormatFlagDefault(result.Flags(), "json")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;c.Parameters)

        return result
}</span>

// Validate validates command's arguments
func (c *Cmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("[path] is required")
        }</span>
        <span class="cov8" title="1">c.path = args[0]

        if strings.HasPrefix(c.body, "@") </span><span class="cov8" title="1">{
                filename, err := filepath.Abs(c.body[1:])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f, err := c.Fs.Open(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">fileContents, err := ioutil.ReadAll(f)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error reading file %s. Reason: %v", filename, err)
                }</span>
                <span class="cov8" title="1">c.body = string(fileContents)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Run runs the command's logic
func (c *Cmd) Run() error <span class="cov8" title="1">{
        var reader io.Reader
        if c.method != http.MethodGet </span><span class="cov8" title="1">{
                reader = bytes.NewReader([]byte(c.body))
        }</span>

        <span class="cov8" title="1">resp, err := c.Client.Call(c.method, c.path, reader, &amp;c.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">data, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov8" title="1">{
                return output.PrintFormat(c.Output, c.outputFormat, data, toMap)
        }</span>
        <span class="cov0" title="0">output.PrintMessage(c.Output, string(data))

        return nil</span>
}

func toMap(data []byte) (interface{}, error) <span class="cov8" title="1">{
        var result map[string]interface{}
        if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// SetOutputFormat set output format
func (c *Cmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        c.outputFormat = format
}</span>

// HideUsage hide command's usage
func (c *Cmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package info

import (
        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
)

// Cmd wraps the smctl info command
type Cmd struct {
        *cmd.Context
}

// NewInfoCmd returns new info command with context
func NewInfoCmd(context *cmd.Context) *Cmd <span class="cov8" title="1">{
        return &amp;Cmd{context}
}</span>

// Prepare returns the cobra command
func (ic *Cmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "info",
                Aliases: []string{"i"},
                Short:   "Prints information for logged user",
                Long:    `Prints information for logged user`,

                PreRunE: prepare(ic, ic.Context),
                RunE:    cmd.RunE(ic),
        }

        return result
}</span>

// Run runs the command's logic
func (ic *Cmd) Run() error <span class="cov8" title="1">{
        clientConfig, err := ic.Configuration.Load()
        if err != nil </span><span class="cov8" title="1">{
                output.PrintMessage(ic.Output, "There is no logged user. Use \"smctl login\" to log in.\n")
        }</span> else<span class="cov8" title="1"> {
                output.PrintMessage(ic.Output, "Service Manager URL: %s\n", clientConfig.URL)
                output.PrintMessage(ic.Output, "User: %s\n", clientConfig.User)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package instance

import (
        "fmt"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager/pkg/web"
        "io"

        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
)

// DeprovisionCmd wraps the smctl deprovision command
type DeprovisionCmd struct {
        *cmd.Context

        input io.Reader
        force bool
        forceDelete bool

        name string
        id   string
}

// NewDeprovisionCmd returns new deprovision command with context
func NewDeprovisionCmd(context *cmd.Context, input io.Reader) *DeprovisionCmd <span class="cov8" title="1">{
        return &amp;DeprovisionCmd{Context: context, input: input}
}</span>

// Validate validates command's arguments
func (dbc *DeprovisionCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("single [name] is required")
        }</span>

        <span class="cov8" title="1">dbc.name = args[0]

        return nil</span>
}

// Run runs the command's logic
func (dbc *DeprovisionCmd) Run() error <span class="cov8" title="1">{
        if dbc.id == "" </span><span class="cov8" title="1">{
                toDeprovision, err := dbc.Client.ListInstances(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", dbc.name),
                        },
                        GeneralParams: dbc.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(toDeprovision.ServiceInstances) &lt; 1 </span><span class="cov8" title="1">{
                        output.PrintMessage(dbc.Output, "Service Instance not found.\n")
                        return nil
                }</span>
                <span class="cov8" title="1">if len(toDeprovision.ServiceInstances) &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("more than one service instance with name %s found. Use --id flag to specify id of the instance to be deleted", dbc.name)
                }</span>
                <span class="cov8" title="1">dbc.id = toDeprovision.ServiceInstances[0].ID</span>
        }


        <span class="cov8" title="1">if dbc.forceDelete </span><span class="cov8" title="1">{
                dbc.Parameters.GeneralParams = append(dbc.Parameters.GeneralParams, fmt.Sprintf("%s=%s", web.QueryParamCascade, "true"))
                dbc.Parameters.GeneralParams = append(dbc.Parameters.GeneralParams, fmt.Sprintf("%s=%s", web.QueryParamForce, "true"))
        }</span>
        <span class="cov8" title="1">location, err := dbc.Client.Deprovision(dbc.id, &amp;dbc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                output.PrintMessage(dbc.Output, "Could not delete service instance. Reason: ")
                return err
        }</span>
        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov0" title="0">{
                cmd.CommonHandleAsyncExecution(dbc.Context, location, fmt.Sprintf("Service Instance %s successfully scheduled for deletion. To see status of the operation use:\n", dbc.name))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintMessage(dbc.Output, "Service Instance successfully deleted.\n")
        return nil</span>
}

// HideUsage hide command's usage
func (dbc *DeprovisionCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// AskForConfirmation asks the user to confirm deletion
func (dbc *DeprovisionCmd) AskForConfirmation() (bool, error) <span class="cov8" title="1">{
        if !dbc.force </span><span class="cov8" title="1">{
                message := fmt.Sprintf("Do you really want to delete instance with name [%s] (Y/n): ", dbc.name)
                return cmd.CommonConfirmationPrompt(message, dbc.Context, dbc.input)
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// PrintDeclineMessage prints confirmation decline message to the user
func (dbc *DeprovisionCmd) PrintDeclineMessage() <span class="cov8" title="1">{
        cmd.CommonPrintDeclineMessage(dbc.Output)
}</span>

// Prepare returns cobra command
func (dbc *DeprovisionCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "deprovision [name]",
                Short:   "Deletes service instance",
                Long:    `Deletes service instance by name.`,
                PreRunE: prepare(dbc, dbc.Context),
                RunE:    cmd.RunE(dbc),
        }

        forceUsage := "Use this parameter to delete a resource without raising a confirmation message."
        forceDeleteUsage := "Delete the service instance and all of its associated resources from the database, including all its service bindings. Use this parameter if the service instance cannot be properly deleted. This parameter can only be used by operators with technical access."
        result.Flags().BoolVarP(&amp;dbc.force, "force", "f", false, forceUsage)
        result.Flags().BoolVarP(&amp;dbc.forceDelete, "force-delete", "", false, forceDeleteUsage)
        result.Flags().StringVarP(&amp;dbc.id, "id", "", "", "ID of the service instance. Required when name is ambiguous.")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;dbc.Parameters)
        cmd.AddModeFlag(result.Flags(), "async")

        return result
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package instance

import (
        "fmt"
        "strings"

        "github.com/Peripli/service-manager-cli/pkg/types"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/spf13/cobra"
)

// GetInstanceCmd wraps the smctl list-brokers command
type GetInstanceCmd struct {
        *cmd.Context

        instanceName   string
        outputFormat   output.Format
        instanceParams *bool
}

// NewGetInstanceCmd returns new get status command with context
func NewGetInstanceCmd(context *cmd.Context) *GetInstanceCmd <span class="cov8" title="1">{
        return &amp;GetInstanceCmd{Context: context}
}</span>

// Run runs the command's logic
func (gb *GetInstanceCmd) Run() error <span class="cov8" title="1">{        
        instances, err := gb.Client.ListInstances(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", gb.instanceName),
                },
                GeneralParams: gb.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(instances.ServiceInstances) &lt; 1 </span><span class="cov8" title="1">{
                output.PrintMessage(gb.Output, "No instance found with name: %s", gb.instanceName)
                return nil
        }</span>
        <span class="cov8" title="1">if *gb.instanceParams </span><span class="cov8" title="1">{
                return gb.printParameters(instances)
        }</span>

        <span class="cov8" title="1">resultInstances := &amp;types.ServiceInstances{Vertical: true}
        for _, instance := range instances.ServiceInstances </span><span class="cov8" title="1">{
                inst, err := gb.Client.GetInstanceByID(instance.ID, &amp;gb.Parameters)
                if err != nil </span><span class="cov0" title="0">{
                        // The instance could be deleted after List and before Get
                        if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">resultInstances.ServiceInstances = append(resultInstances.ServiceInstances, *inst)</span>
        }

        <span class="cov8" title="1">if len(resultInstances.ServiceInstances) &lt; 1 </span><span class="cov0" title="0">{
                output.PrintMessage(gb.Output, "No instance found with name: %s", gb.instanceName)
                return nil
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(gb.Output, gb.outputFormat, resultInstances)
        output.Println(gb.Output)
        return nil</span>
}

func (gb *GetInstanceCmd) printParameters(instances *types.ServiceInstances) error <span class="cov8" title="1">{

        for _, instance := range instances.ServiceInstances </span><span class="cov8" title="1">{
                parameters, err := gb.Client.GetInstanceParameters(instance.ID, &amp;gb.Parameters)
                if err != nil </span><span class="cov0" title="0">{
                        // The instance could be deleted after List and before Get
                        if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">output.PrintMessage(gb.Output, "Unable to show configuration parameters for service instance id: %s\n", instance.ID)
                        output.PrintMessage(gb.Output, "The error: %s\n\n", err)
                        continue</span>
                }
                <span class="cov8" title="1">if len(parameters) == 0 </span><span class="cov8" title="1">{
                        output.PrintMessage(gb.Output, "No configuration parameters are set for service instance id: %s\n\n", instance.ID)
                        continue</span>
                }
                <span class="cov8" title="1">output.PrintMessage(gb.Output, "Showing configuration parameters for service instance id: %s \n", instance.ID)
                output.PrintMessage(gb.Output, "The parameters: \n")

                output.PrintMessage(gb.Output, "%s \n\n", output.PrintParameters(parameters))</span>
        }

        <span class="cov8" title="1">output.Println(gb.Output)
        return nil</span>
}

// Validate validates command's arguments
func (gb *GetInstanceCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 || len(args[0]) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("instance name is required")
        }</span>

        <span class="cov8" title="1">gb.instanceName = args[0]

        return nil</span>
}

// SetOutputFormat set output format
func (gb *GetInstanceCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        gb.outputFormat = format
}</span>

// HideUsage hide command's usage
func (gb *GetInstanceCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (gb *GetInstanceCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "get-instance [name]",
                Aliases: []string{"gi"},
                Short:   "Get single instance",
                Long:    `Get single instance by its name`,
                PreRunE: prepare(gb, gb.Context),
                RunE:    cmd.RunE(gb),
        }
        gb.instanceParams = result.PersistentFlags().Bool("show-instance-params", false, "Show the service instance configuration parameters")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;gb.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package instance

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// ListInstancesCmd wraps the smctl list-instances command
type ListInstancesCmd struct {
        *cmd.Context

        outputFormat output.Format
}

// NewListInstancesCmd returns new list-instances command with context
func NewListInstancesCmd(context *cmd.Context) *ListInstancesCmd <span class="cov8" title="1">{
        return &amp;ListInstancesCmd{Context: context}
}</span>

// Run runs the command's logic
func (li *ListInstancesCmd) Run() error <span class="cov8" title="1">{
        instances, err := li.Client.ListInstances(&amp;li.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(li.Output, li.outputFormat, instances)
        output.Println(li.Output)

        return nil</span>
}

// SetOutputFormat sets output format
func (li *ListInstancesCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        li.outputFormat = format
}</span>

// HideUsage hides command's usage
func (li *ListInstancesCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (li *ListInstancesCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "list-instances",
                Aliases: []string{"li"},
                Short:   "List service-instances",
                Long:    `List all service-instances.`,
                PreRunE: prepare(li, li.Context),
                RunE:    cmd.RunE(li),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddQueryingFlags(result.Flags(), &amp;li.Parameters)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;li.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package instance

import (
        "encoding/json"
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager-cli/pkg/types"

        "fmt"
        "github.com/spf13/cobra"
)

// ProvisionCmd wraps the smctl provision command
type ProvisionCmd struct {
        *cmd.Context

        instance       types.ServiceInstance
        offeringName   string
        planName       string
        brokerName     string
        parametersJSON string

        outputFormat output.Format
}

// NewProvisionCmd returns new provision command with context
func NewProvisionCmd(context *cmd.Context) *ProvisionCmd <span class="cov8" title="1">{
        return &amp;ProvisionCmd{Context: context, instance: types.ServiceInstance{}}
}</span>

// Prepare returns cobra command
func (pi *ProvisionCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:   "provision [name] [offering] [plan]",
                Short: "Provisions an instance in SM",
                Long:  `Provisions an instance in SM`,

                PreRunE: prepare(pi, pi.Context),
                RunE:    cmd.RunE(pi),
        }

        result.Flags().StringVarP(&amp;pi.brokerName, "broker-name", "b", "", "Name of the broker which provides the service offering. Required when offering name is ambiguous")
        result.Flags().StringVarP(&amp;pi.parametersJSON, "parameters", "c", "", "Valid JSON object containing instance parameters")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;pi.Parameters)
        cmd.AddModeFlag(result.Flags(), "async")

        return result
}</span>

// Validate validates command's arguments
func (pi *ProvisionCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 3 </span><span class="cov8" title="1">{
                return fmt.Errorf("name, offering and plan are required")
        }</span>

        <span class="cov8" title="1">pi.instance.Name = args[0]
        pi.offeringName = args[1]
        pi.planName = args[2]

        return nil</span>
}

// Run runs the command's logic
func (pi *ProvisionCmd) Run() error <span class="cov8" title="1">{
        offerings, err := pi.Client.ListOfferings(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", pi.offeringName),
                },
                GeneralParams: pi.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(offerings.ServiceOfferings) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("service offering with name %s not found", pi.offeringName)
        }</span>

        <span class="cov8" title="1">pi.instance.ServiceID = offerings.ServiceOfferings[0].ID

        if len(offerings.ServiceOfferings) &gt; 1 </span><span class="cov8" title="1">{
                if len(pi.brokerName) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("more than one service offering with name %s found. Use -b flag to specify broker name", pi.offeringName)
                }</span>

                <span class="cov8" title="1">brokers, err := pi.Client.ListBrokers(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", pi.brokerName),
                        },
                        GeneralParams: pi.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(brokers.Brokers) != 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("exactly one broker with name %s expected, found %d", pi.brokerName, len(brokers.Brokers))
                }</span>
                <span class="cov8" title="1">for _, offering := range offerings.ServiceOfferings </span><span class="cov8" title="1">{
                        if offering.BrokerID == brokers.Brokers[0].ID </span><span class="cov8" title="1">{
                                pi.instance.ServiceID = offering.ID
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">plans, err := pi.Client.ListPlans(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", pi.planName),
                        fmt.Sprintf("service_offering_id eq '%s'", pi.instance.ServiceID),
                },
                GeneralParams: pi.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(plans.ServicePlans) != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("exactly one service plan with name %s for offering with id %s expected", pi.planName, pi.instance.ServiceID)
        }</span>

        <span class="cov8" title="1">pi.instance.ServicePlanID = plans.ServicePlans[0].ID
        pi.instance.Parameters = json.RawMessage(pi.parametersJSON)

        resultInstance, location, err := pi.Client.Provision(&amp;pi.instance, &amp;pi.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov8" title="1">{
                cmd.CommonHandleAsyncExecution(pi.Context, location, fmt.Sprintf("Service Instance %s successfully scheduled for provisioning. To see status of the operation use:\n", pi.instance.Name))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(pi.Output, pi.outputFormat, resultInstance)
        output.Println(pi.Output)
        return nil</span>
}

// SetOutputFormat set output format
func (pi *ProvisionCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        pi.outputFormat = format
}</span>

// HideUsage hide command's usage
func (pi *ProvisionCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package instance

import (
        "io"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager-cli/pkg/types"

        "fmt"

        "github.com/spf13/cobra"
)

// TransferCmd wraps the smctl provision command
type TransferCmd struct {
        *cmd.Context

        input io.Reader
        force bool

        instanceName   string
        instanceID     string
        fromPlatformID string
        toPlatformID   string

        outputFormat output.Format
}

// NewTransferCmd returns new transfer instance command with context
func NewTransferCmd(context *cmd.Context, input io.Reader) *TransferCmd <span class="cov8" title="1">{
        return &amp;TransferCmd{Context: context, input: input}
}</span>

// Prepare returns cobra command
func (trc *TransferCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:   "transfer-instance [name] --from [from_plafrom_id] --to [to_platform_id]",
                Short: "Transfer instance in one platform to another in SM",
                Long:  `Transfer instance in one platform to another in SM`,

                PreRunE: prepare(trc, trc.Context),
                RunE:    cmd.RunE(trc),
        }

        result.Flags().BoolVarP(&amp;trc.force, "force", "f", false, "Force transfer without confirmation")
        result.Flags().StringVarP(&amp;trc.instanceID, "id", "", "", cmd.INSTANCE_ID_DESCRIPTION)
        result.Flags().StringVarP(&amp;trc.fromPlatformID, "from", "", "", "ID of the platform from which you want to move the instance")
        result.Flags().StringVarP(&amp;trc.toPlatformID, "to", "", "", "ID of the platform to which you want to move the instance")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddModeFlag(result.Flags(), "async")

        return result
}</span>

// Validate validates command's arguments
func (trc *TransferCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("name is required")
        }</span>
        <span class="cov8" title="1">trc.instanceName = args[0]

        if len(trc.fromPlatformID) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--from is required")
        }</span>

        <span class="cov8" title="1">if len(trc.toPlatformID) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--to is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Run runs the command's logic
func (trc *TransferCmd) Run() error <span class="cov8" title="1">{
        if trc.instanceID == "" </span><span class="cov8" title="1">{
                instances, err := trc.Client.ListInstances(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", trc.instanceName),
                                fmt.Sprintf("platform_id eq '%s'", trc.fromPlatformID),
                        },
                        GeneralParams: trc.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(instances.ServiceInstances) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf(cmd.NO_INSTANCES_FOUND, trc.instanceName)
                }</span>

                <span class="cov8" title="1">if len(instances.ServiceInstances) &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf(cmd.FOUND_TOO_MANY_INSTANCES, trc.instanceName, "transfer")
                }</span>

                <span class="cov8" title="1">trc.instanceID = instances.ServiceInstances[0].ID</span>
        }

        <span class="cov8" title="1">resultInstance, location, err := trc.Client.UpdateInstance(trc.instanceID, &amp;types.ServiceInstance{
                PlatformID: trc.toPlatformID,
        }, nil)
        if err != nil </span><span class="cov8" title="1">{
                output.PrintMessage(trc.Output, "Could not transfer service instance. Reason: ")
                return err
        }</span>

        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov8" title="1">{
                cmd.CommonHandleAsyncExecution(trc.Context, location, fmt.Sprintf("Service Instance %s successfully scheduled for transfer to platform with id %s. To see status of the operation use:\n", trc.instanceName, trc.toPlatformID))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(trc.Output, trc.outputFormat, resultInstance)
        output.Println(trc.Output)
        return nil</span>
}

// AskForConfirmation asks the user to confirm deletion
func (trc *TransferCmd) AskForConfirmation() (bool, error) <span class="cov8" title="1">{
        if !trc.force </span><span class="cov8" title="1">{
                message := fmt.Sprintf("Do you really want to transfer service instance with name [%s] to platform with id %s (Y/n): ", trc.instanceName, trc.toPlatformID)
                return cmd.CommonConfirmationPrompt(message, trc.Context, trc.input)
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// PrintDeclineMessage prints confirmation decline message to the user
func (trc *TransferCmd) PrintDeclineMessage() <span class="cov8" title="1">{
        output.PrintMessage(trc.Output, "Transfer declined")
}</span>

// SetOutputFormat set output format
func (trc *TransferCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        trc.outputFormat = format
}</span>

// HideUsage hide command's usage
func (trc *TransferCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
 * Copyright 2021 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package instance

import (
        "encoding/json"
        "fmt"
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager-cli/pkg/types"

        "github.com/spf13/cobra"
)

type UpdateCmd struct {
        *cmd.Context
        instance       types.ServiceInstance
        instanceName   string
        planName       string
        parametersJSON string
        outputFormat   output.Format
}

func NewUpdateInstanceCmd(context *cmd.Context) *UpdateCmd <span class="cov8" title="1">{
        return &amp;UpdateCmd{Context: context, instance: types.ServiceInstance{}}
}</span>

// Prepare returns cobra command
func (uc *UpdateCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:   "update-instance [name] --id service-instance-id --new-name new-service-name --plan new-plan-name --instance-params new-configuration-parameters",
                Short: "Update a service instance",
                Long:  `Update the name, associated plan, and configuration parameters of an existing service instance`,

                PreRunE: prepare(uc, uc.Context),
                RunE:    cmd.RunE(uc),
        }
        result.Flags().StringVarP(&amp;uc.instance.ID, "id", "", "", "The id of the service instance to update")
        result.Flags().StringVarP(&amp;uc.instance.Name, "new-name", "", "", "The new name of the service instance")
        result.Flags().StringVarP(&amp;uc.planName, "plan", "", "", "The name of the new service plan to use for the instance")
        result.Flags().StringVarP(&amp;uc.parametersJSON, "instance-params", "c", "", "Valid JSON object containing instance configuration parameters")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddModeFlag(result.Flags(), "async")
        return result
}</span>

func (uc *UpdateCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("name is required")
        }</span>
        <span class="cov8" title="1">uc.instanceName = args[0]
        return nil</span>
}

func (uc *UpdateCmd) Run() error <span class="cov8" title="1">{
        var instanceBeforeUpdate *types.ServiceInstance
        if uc.instance.ID == "" </span><span class="cov8" title="1">{
                instances, err := uc.Client.ListInstances(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", uc.instanceName),
                        },
                        GeneralParams: uc.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(instances.ServiceInstances) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf(cmd.NO_INSTANCES_FOUND, uc.instanceName)
                }</span>

                <span class="cov8" title="1">if len(instances.ServiceInstances) &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf(cmd.FOUND_TOO_MANY_INSTANCES, uc.instanceName, "update")

                }</span>
                <span class="cov8" title="1">instanceBeforeUpdate = &amp;instances.ServiceInstances[0]</span>

        } else<span class="cov8" title="1"> {
                instance, err := uc.Client.GetInstanceByID(uc.instance.ID, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">instanceBeforeUpdate = instance</span>

        }

        <span class="cov8" title="1">if uc.planName != "" </span><span class="cov8" title="1">{
                currentPlan, err := uc.Client.GetPlanByID(instanceBeforeUpdate.ServicePlanID, &amp;uc.Parameters)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">plans, err := uc.Client.ListPlans(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("catalog_name eq '%s'", uc.planName),
                                fmt.Sprintf("service_offering_id eq '%s'", currentPlan.ServiceOfferingID),
                        },
                        GeneralParams: uc.Parameters.GeneralParams,
                })

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(plans.ServicePlans) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("service plan with name %s for offering with id %s not found", uc.planName, currentPlan.ServiceOfferingID)
                }</span>
                <span class="cov8" title="1">if len(plans.ServicePlans) &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("exactly one service plan with name %s for offering with id %s expected", uc.planName, currentPlan.ServiceOfferingID)
                }</span>

                <span class="cov8" title="1">uc.instance.ServicePlanID = plans.ServicePlans[0].ID</span>
        }
        <span class="cov8" title="1">if len(uc.parametersJSON) &gt; 0 </span><span class="cov8" title="1">{
                uc.instance.Parameters = json.RawMessage(uc.parametersJSON)
        }</span>

        <span class="cov8" title="1">resultInstance, location, err := uc.Client.UpdateInstance(instanceBeforeUpdate.ID, &amp;uc.instance, &amp;uc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                output.PrintMessage(uc.Output, "Could not update service instance. Reason: ")
                return err
        }</span>

        <span class="cov8" title="1">if len(location) != 0 </span><span class="cov8" title="1">{
                cmd.CommonHandleAsyncExecution(uc.Context, location, fmt.Sprintf("Service Instance %s successfully scheduled for update. To see status of the operation use:\n", uc.instance.Name))
                return nil
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(uc.Output, uc.outputFormat, resultInstance)
        output.Println(uc.Output)
        return nil</span>
}

// SetOutputFormat set output format
func (uc *UpdateCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        uc.outputFormat = format
}</span>

// HideUsage hide command's usage
func (uc *UpdateCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package instance

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager-cli/pkg/types"
        "github.com/Peripli/service-manager/pkg/web"

        "fmt"

        "github.com/spf13/cobra"
)

type UpdateSharingCmd struct {
        *cmd.Context
        instanceName string
        instanceID   string
        outputFormat output.Format
        share        bool
        action       string
}

// NewUpdateSharingCmd returns new share/unshare instance command with context
func NewUpdateSharingCmd(context *cmd.Context, share bool) *UpdateSharingCmd <span class="cov8" title="1">{
        return &amp;UpdateSharingCmd{Context: context, share: share}
}</span>

// Prepare returns cobra command
func (shc *UpdateSharingCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                PreRunE: prepare(shc, shc.Context),
                RunE:    cmd.RunE(shc),
        }
        if shc.share </span><span class="cov0" title="0">{
                shc.action = "share"
                result.Use = "share-instance [name] --id service-instance-id "
                result.Short = "Share a service instance"
                result.Long = `Share a service instance so that it can be consumed from various platforms in your subaccount.
Instance can be shared only if it was created with the plan that supports instance sharing. For more information, see the documentation of the service whose instance you want to share. To check if the service instance was created with a shareable plan, use 'smctl list-plans'.`
        }</span> else<span class="cov8" title="1"> {
                shc.action = "unshare"
                result.Use = "unshare-instance [name] --id service-instance-id "
                result.Short = "Unshare a service instance"
                result.Long = `Unshare a service instance to disable its consumption from any but the original platform in which it was created in your subaccount. If an instance you want to unshare has references, an error is returned`
        }</span>
        <span class="cov8" title="1">result.Flags().StringVarP(&amp;shc.instanceID, "id", "", "", cmd.INSTANCE_ID_DESCRIPTION)
        cmd.AddFormatFlag(result.Flags())
        return result</span>
}

// Validate validates command's arguments
func (shc *UpdateSharingCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("service instance name is required")
        }</span>
        <span class="cov8" title="1">shc.instanceName = args[0]
        return nil</span>
}

// Run runs the command's logic
func (shc *UpdateSharingCmd) Run() error <span class="cov8" title="1">{
        if shc.instanceID == "" </span><span class="cov8" title="1">{
                instances, err := shc.Client.ListInstances(&amp;query.Parameters{
                        FieldQuery: []string{
                                fmt.Sprintf("name eq '%s'", shc.instanceName),
                        },
                        GeneralParams: shc.Parameters.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(instances.ServiceInstances) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf(cmd.NO_INSTANCES_FOUND, shc.instanceName)
                }</span>

                <span class="cov8" title="1">if len(instances.ServiceInstances) &gt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf(cmd.FOUND_TOO_MANY_INSTANCES, shc.instanceName, shc.action)
                }</span>

                <span class="cov8" title="1">shc.instanceID = instances.ServiceInstances[0].ID</span>
        }
        <span class="cov8" title="1">shc.Parameters.GeneralParams = append(shc.Parameters.GeneralParams, fmt.Sprintf("%s=%s", web.QueryParamAsync, "false"))
        shared:=new(bool)
        *shared = shc.share
        resultInstance, _, err := shc.Client.UpdateInstance(shc.instanceID, &amp;types.ServiceInstance{
                Shared: shared,
        }, &amp;query.Parameters{
                GeneralParams: shc.Parameters.GeneralParams,
        })
        if err != nil </span><span class="cov8" title="1">{
                output.PrintMessage(shc.Output, fmt.Sprintf("Couldn't %s the service instance. ", shc.action))
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(shc.Output, shc.outputFormat, resultInstance)
        output.Println(shc.Output)
        return nil</span>
}

// SetOutputFormat set output format
func (shc *UpdateSharingCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        shc.outputFormat = format
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package label

import (
        "fmt"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/types"
        smtypes "github.com/Peripli/service-manager/pkg/types"
        "github.com/Peripli/service-manager/pkg/web"
        "github.com/spf13/cobra"
)

// Cmd wraps smctl label command
type Cmd struct {
        *cmd.Context

        resourcePath string
        id           string
        values       []string
        labelChanges types.LabelChanges
}

// NewLabelCmd returns new label command with context
func NewLabelCmd(context *cmd.Context) *Cmd <span class="cov8" title="1">{
        return &amp;Cmd{Context: context, labelChanges: types.LabelChanges{}}
}</span>

// Prepare returns cobra command
func (c *Cmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:   "label [resource] [id] [operation] [key] [--val value1 --val value2 ...]",
                Short: "Add or remove resource labels",
                Long:  "Add or remove resource labels. Supported resources: platform, broker, service-instance",

                PreRunE: prepare(c, c.Context),
                RunE:    cmd.RunE(c),
        }

        result.Flags().StringArrayVar(&amp;c.values, "val", []string{}, "Label value to be used")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;c.Parameters)

        return result
}</span>

// Validate validates command's arguments
func (c *Cmd) Validate(args []string) error <span class="cov8" title="1">{

        resources := map[string]string{
                "platform": web.PlatformsURL,
                "broker":   web.ServiceBrokersURL,
                "service-instance":   web.ServiceInstancesURL,
        }

        operations := map[string]string{
                "add":           "add",
                "remove":        "remove",
                "add-values":    "add_values",
                "remove-values": "remove_values",
        }

        if len(args) &lt; 4 </span><span class="cov8" title="1">{
                return fmt.Errorf("resource type, id, operation, key and values are required")
        }</span>

        <span class="cov8" title="1">if len(args) &gt; 4 </span><span class="cov8" title="1">{
                return fmt.Errorf("too much arguments, in case you have whitespaces in some of the arguments consider enclosig it with single quotes")
        }</span>

        <span class="cov8" title="1">if v, ok := resources[args[0]]; ok </span><span class="cov8" title="1">{
                c.resourcePath = v
                c.id = args[1]
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("unknown resource")
        }</span>

        <span class="cov8" title="1">labelChange := &amp;smtypes.LabelChange{}

        if v, ok := operations[args[2]]; ok </span><span class="cov8" title="1">{
                labelChange.Operation = smtypes.LabelOperation(v)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("unknown operation")
        }</span>

        <span class="cov8" title="1">labelChange.Key = args[3]

        if len(c.values) &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one value is required")
        }</span>

        <span class="cov8" title="1">labelChange.Values = c.values
        c.labelChanges.LabelChanges = append(c.labelChanges.LabelChanges, labelChange)
        return nil</span>
}

// Run runs the command's logic
func (c *Cmd) Run() error <span class="cov8" title="1">{
        if err := c.Client.Label(c.resourcePath, c.id, &amp;c.labelChanges, &amp;c.Parameters); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintMessage(c.Output, "Resource labeled successfully!")
        return nil</span>
}

// HideUsage hide command's usage
func (c *Cmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package login

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "syscall"

        cliErr "github.com/Peripli/service-manager-cli/pkg/errors"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/configuration"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/internal/util"
        "github.com/Peripli/service-manager-cli/pkg/auth"
        "github.com/Peripli/service-manager-cli/pkg/smclient"
        "github.com/spf13/cobra"
        "golang.org/x/crypto/ssh/terminal"
)

const (
        defaultClientID     = "cf"
        defaultClientSecret = ""
)

var validationError = errors.New("Invalid credentials. In a Client Credentials authorization flow, use either the combination of a client_id and client_secret or client_id and client cert and key.")

// Cmd wraps the smctl login command
type Cmd struct {
        *cmd.Context

        input io.ReadWriter

        serviceManagerURL  string
        user               string
        password           string
        sslDisabled        bool
        clientID           string
        clientSecret       string
        cert               string
        key                string
        authenticationFlow auth.Flow

        authBuilder authenticationBuilder
}

type authenticationBuilder func(*auth.Options) (auth.Authenticator, *auth.Options, error)

// NewLoginCmd return new login command with context and input reader
func NewLoginCmd(context *cmd.Context, input io.ReadWriter, authBuilder authenticationBuilder) *Cmd <span class="cov8" title="1">{
        return &amp;Cmd{Context: context, input: input, authBuilder: authBuilder}
}</span>

// Prepare returns cobra command
func (lc *Cmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "login",
                Aliases: []string{"l"},
                Short:   "Logs user in",
                Long:    `Connects to a Service Manager and logs user in.`,

                PreRunE: prepare(lc, lc.Context),
                RunE:    cmd.RunE(lc),
        }

        result.Flags().StringVarP(&amp;lc.serviceManagerURL, "url", "a", "", "Base URL of the Service Manager")
        result.Flags().StringVarP(&amp;lc.user, "user", "u", "", "User ID")
        result.Flags().StringVarP(&amp;lc.password, "password", "p", "", "Password")
        result.Flags().StringVarP(&amp;lc.clientID, "client-id", "", "", "Client id used for OAuth flow")
        result.Flags().StringVarP(&amp;lc.clientSecret, "client-secret", "", defaultClientSecret, "Client secret used for OAuth flow")
        result.Flags().StringVarP(&amp;lc.cert, "cert", "", "", "Path to the file which contains the certificate (public-key)")
        result.Flags().StringVarP(&amp;lc.key, "key", "", "", "Path to the file which contains the key (private-key)")
        result.Flags().BoolVarP(&amp;lc.sslDisabled, "skip-ssl-validation", "", false, "Skip verification of the OAuth endpoint. Not recommended!")
        result.Flags().StringVarP((*string)(&amp;lc.authenticationFlow), "auth-flow", "", string(auth.PasswordGrant), `Authentication flow (grant type): "client-credentials" or "password-grant"`)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;lc.Parameters)

        return result
}</span>

// HideUsage hides the command's usage
func (lc *Cmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Validate valides the command's arguments
func (lc *Cmd) Validate(args []string) error <span class="cov8" title="1">{
        if lc.serviceManagerURL == "" </span><span class="cov8" title="1">{
                return errors.New("URL flag must be provided")
        }</span>

        <span class="cov8" title="1">if err := util.ValidateURL(lc.serviceManagerURL); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("service manager URL is invalid: %v", err)
        }</span>

        <span class="cov8" title="1">if err := lc.validateLoginFlow(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Run runs the logic of the command
func (lc *Cmd) Run() error <span class="cov8" title="1">{
        httpClient, err := util.BuildHTTPClient(&amp;auth.Options{SSLDisabled: lc.sslDisabled})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if lc.Client == nil </span><span class="cov0" title="0">{
                lc.Client = smclient.NewClient(lc.Ctx, httpClient, lc.serviceManagerURL)
        }</span>

        <span class="cov8" title="1">if lc.authenticationFlow == auth.ClientCredentials </span><span class="cov8" title="1">{
                lc.Parameters.GeneralParams = append(lc.Parameters.GeneralParams, "grant_type=client_credentials")
        }</span>

        <span class="cov8" title="1">info, err := lc.Client.GetInfo(&amp;lc.Parameters)
        if err != nil </span><span class="cov0" title="0">{
                return cliErr.New("Could not get Service Manager info", err)
        }</span>

        <span class="cov8" title="1">options := &amp;auth.Options{
                User:           lc.user,
                Password:       lc.password,
                ClientID:       lc.clientID,
                ClientSecret:   lc.clientSecret,
                IssuerURL:      info.TokenIssuerURL,
                TokenBasicAuth: info.TokenBasicAuth,
                SSLDisabled:    lc.sslDisabled,
                Certificate:    lc.cert,
                Key:            lc.key,
        }

        authStrategy, options, err := lc.authBuilder(options)
        if err != nil </span><span class="cov0" title="0">{
                return cliErr.New("Could not build authenticator", err)
        }</span>
        <span class="cov8" title="1">token, err := lc.getToken(authStrategy)
        if err != nil </span><span class="cov0" title="0">{
                return cliErr.New("could not login", err)
        }</span>

        <span class="cov8" title="1">settings := &amp;configuration.Settings{
                URL:         lc.serviceManagerURL,
                User:        lc.user,
                SSLDisabled: lc.sslDisabled,
                AuthFlow:    lc.authenticationFlow,

                Token: *token,

                IssuerURL:             info.TokenIssuerURL,
                AuthorizationEndpoint: options.AuthorizationEndpoint,
                TokenEndpoint:         options.TokenEndpoint,
                TokenBasicAuth:        info.TokenBasicAuth,
        }
        if options.ClientID == defaultClientID &amp;&amp; options.ClientSecret == defaultClientSecret </span><span class="cov8" title="1">{
                settings.ClientID = options.ClientID
                settings.ClientSecret = options.ClientSecret
        }</span>
        <span class="cov8" title="1">if settings.User == "" </span><span class="cov8" title="1">{
                settings.User = options.ClientID
        }</span>
        <span class="cov8" title="1">err = lc.Configuration.Save(settings)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintMessage(lc.Output, "Logged in successfully.\n")
        return nil</span>
}

func (lc *Cmd) getToken(authStrategy auth.Authenticator) (*auth.Token, error) <span class="cov8" title="1">{
        switch lc.authenticationFlow </span>{
        case auth.ClientCredentials:<span class="cov8" title="1">
                return authStrategy.ClientCredentials()</span>
        case auth.PasswordGrant:<span class="cov8" title="1">
                return authStrategy.PasswordCredentials(lc.user, lc.password)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("authentication flow %s not recognized", lc.authenticationFlow)</span>
        }
}

func (lc *Cmd) validateLoginFlow() error <span class="cov8" title="1">{
        switch lc.authenticationFlow </span>{
        case auth.ClientCredentials:<span class="cov8" title="1">
                validClientSecret := len(lc.clientID) &gt; 0 &amp;&amp; len(lc.clientSecret) &gt; 0
                validMTLS := len(lc.clientID) &gt; 0 &amp;&amp; len(lc.cert) &gt; 0 &amp;&amp; len(lc.key) &gt; 0
                if !validClientSecret &amp;&amp; !validMTLS </span><span class="cov8" title="1">{
                        return validationError
                }</span>
        case auth.PasswordGrant:<span class="cov8" title="1">
                return lc.validatePasswordGrant()</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unknown authentication flow: %s", lc.authenticationFlow)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (lc *Cmd) validatePasswordGrant() error <span class="cov8" title="1">{
        if len(lc.clientID) == 0 </span><span class="cov8" title="1">{
                lc.clientID = defaultClientID
        }</span>

        <span class="cov8" title="1">if err := lc.readUser(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := lc.readPassword(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(lc.user) == 0 || len(lc.password) == 0 </span><span class="cov8" title="1">{
                return errors.New("username/password should not be empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (lc *Cmd) readUser() error <span class="cov8" title="1">{
        if lc.user == "" </span><span class="cov8" title="1">{
                output.PrintMessage(lc.Output, "User: ")
                bufReader := bufio.NewReader(lc.input)
                readUser, isPrefix, err := bufReader.ReadLine()
                if isPrefix </span><span class="cov0" title="0">{
                        return errors.New("username too long")
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">lc.user = string(readUser)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (lc *Cmd) readPassword() error <span class="cov8" title="1">{
        if lc.password == "" </span><span class="cov0" title="0">{
                output.PrintMessage(lc.Output, "Password: ")
                password, err := terminal.ReadPassword((int)(syscall.Stdin))
                output.Println(lc.Output)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">lc.password = string(password)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package logout

import (
        "github.com/spf13/cobra"
        "time"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
)

// Cmd wraps the smctl version command
type Cmd struct {
        *cmd.Context
}

// NewLogoutCmd returns new version command
func NewLogoutCmd(context *cmd.Context) *Cmd <span class="cov8" title="1">{
        return &amp;Cmd{context}
}</span>

// Prepare returns cobra command
func (vc *Cmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "logout",
                Short:   "Logs the user out",
                Long:    `Logs the user out of the system and deletes the active client access token.`,
                PreRunE: prepare(vc, vc.Context),
                RunE:    cmd.RunE(vc),
        }

        return result
}</span>

// Run runs command's logic
func (vc *Cmd) Run() error <span class="cov8" title="1">{
        config, err := vc.Configuration.Load()

        if config != nil &amp;&amp; err != nil </span><span class="cov8" title="1">{
                if config.Token.AccessToken == "" </span><span class="cov8" title="1">{
                        output.PrintMessage(vc.Output, "You are already logged out.\n")
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">config.RefreshToken = ""
        config.ExpiresIn = time.Time{}
        config.AccessToken = ""
        config.Scope = ""
        config.User = ""

        err = vc.Configuration.Save(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintMessage(vc.Output, "You have successfully logged out.\n")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package offering

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// ListOfferingsCmd wraps the smctl list-offerings command
type ListOfferingsCmd struct {
        *cmd.Context
        outputFormat output.Format
}

// NewListOfferingsCmd returns new list-offerings command with context
func NewListOfferingsCmd(context *cmd.Context) *ListOfferingsCmd <span class="cov8" title="1">{
        return &amp;ListOfferingsCmd{Context: context}
}</span>

// Run runs the command's logic
func (lo *ListOfferingsCmd) Run() error <span class="cov8" title="1">{
        offerings, err := lo.Client.ListOfferings(&amp;lo.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(lo.Output, lo.outputFormat, offerings)
        output.Println(lo.Output)

        return nil</span>
}

// SetOutputFormat set output format
func (lo *ListOfferingsCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        lo.outputFormat = format
}</span>

// HideUsage hide command's usage
func (lo *ListOfferingsCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (lo *ListOfferingsCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "list-offerings",
                Aliases: []string{"lo"},
                Short:   "List service-offerings",
                Long:    `List service-offerings.`,
                PreRunE: prepare(lo, lo.Context),
                RunE:    cmd.RunE(lo),
        }
        cmd.AddSupportedEnvironmentFlag(result.Flags(), &amp;lo.Parameters, "Filters service offerings by supported environments")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddQueryingFlags(result.Flags(), &amp;lo.Parameters)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;lo.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package offering

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/types"
        "github.com/spf13/cobra"
)

// MarketplaceCmd wraps the smctl marketplace command
type MarketplaceCmd struct {
        *cmd.Context

        prepare      cmd.PrepareFunc
        outputFormat output.Format

        offering string
}

// NewMarketplaceCmd returns new list-offerings command with context
func NewMarketplaceCmd(context *cmd.Context) *MarketplaceCmd <span class="cov8" title="1">{
        return &amp;MarketplaceCmd{Context: context}
}</span>

// Run runs the command's logic
func (m *MarketplaceCmd) Run() error <span class="cov8" title="1">{
        marketplace, err := m.Client.Marketplace(&amp;m.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if m.offering == "" </span><span class="cov8" title="1">{
                output.PrintServiceManagerObject(m.Output, m.outputFormat, marketplace)
        }</span> else<span class="cov8" title="1"> {
                plans := &amp;types.ServicePlansForOffering{}
                for _, v := range marketplace.ServiceOfferings </span><span class="cov8" title="1">{
                        if v.Name == m.offering </span><span class="cov8" title="1">{
                                plans.ServicePlans = append(plans.ServicePlans, v.Plans...)
                        }</span>
                }
                <span class="cov8" title="1">output.PrintServiceManagerObject(m.Output, m.outputFormat, plans)</span>
        }
        <span class="cov8" title="1">output.Println(m.Output)
        return nil</span>
}

// SetOutputFormat set output format
func (m *MarketplaceCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        m.outputFormat = format
}</span>

// HideUsage hide command's usage
func (m *MarketplaceCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (m *MarketplaceCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        m.prepare = prepare
        result := &amp;cobra.Command{
                Use:     "marketplace",
                Aliases: []string{"m"},
                Short:   "Shows marketplace for the service-offerings",
                Long:    `Shows marketplace for the service-offerings`,
                PreRunE: m.prepare(m, m.Context),
                RunE:    cmd.RunE(m),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddSupportedEnvironmentFlag(result.Flags(), &amp;m.Parameters, "Filters service offerings by supported environments")
        result.Flags().StringVarP(&amp;m.offering, "service", "s", "", "Plan details for a single service offering")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;m.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package plan

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// ListPlansCmd wraps the smctl list-plans command
type ListPlansCmd struct {
        *cmd.Context
        environment string
        outputFormat output.Format
}

// NewListPlansCmd returns new list-plans command with context
func NewListPlansCmd(context *cmd.Context) *ListPlansCmd <span class="cov8" title="1">{
        return &amp;ListPlansCmd{Context: context}
}</span>

// Run runs the command's logic
func (lp *ListPlansCmd) Run() error <span class="cov8" title="1">{
        plans, err := lp.Client.ListPlans(&amp;lp.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(lp.Output, lp.outputFormat, plans)
        output.Println(lp.Output)

        return nil</span>
}

// SetOutputFormat set output format
func (lp *ListPlansCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        lp.outputFormat = format
}</span>

// HideUsage hide command's usage
func (lp *ListPlansCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (lp *ListPlansCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "list-plans",
                Short:   "List service-plans",
                Long:    `List service-plans.`,
                PreRunE: prepare(lp, lp.Context),
                RunE:    cmd.RunE(lp),
        }
        cmd.AddSupportedEnvironmentFlag(result.Flags(), &amp;lp.Parameters, "Filters service plans by supported environments")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddQueryingFlags(result.Flags(), &amp;lp.Parameters)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;lp.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package platform

import (
        "fmt"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager/pkg/web"
        "io"
        "strings"

        "github.com/Peripli/service-manager-cli/internal/output"

        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
)

// DeletePlatformCmd wraps the smctl delete-platform command
type DeletePlatformCmd struct {
        *cmd.Context

        input       io.Reader
        force       bool
        cascadeFlag *bool

        name string
}

// NewDeletePlatformCmd returns new delete-platform command with context
func NewDeletePlatformCmd(context *cmd.Context, input io.Reader) *DeletePlatformCmd <span class="cov8" title="1">{
        return &amp;DeletePlatformCmd{Context: context, input: input}
}</span>

// Validate validates command's arguments
func (dpc *DeletePlatformCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) != 1 || len(args[0]) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("single [name] is required")
        }</span>

        <span class="cov8" title="1">dpc.name = args[0]

        return nil</span>
}

// Run runs the command's logic
func (dpc *DeletePlatformCmd) Run() error <span class="cov8" title="1">{

        if *dpc.cascadeFlag </span><span class="cov8" title="1">{
                return dpc.cascadeDelete()
        }</span>

        <span class="cov8" title="1">dpc.Parameters.FieldQuery = append(dpc.Parameters.FieldQuery, fmt.Sprintf("name eq '%s'", dpc.name))

        if err := dpc.Client.DeletePlatforms(&amp;dpc.Parameters); err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov8" title="1">{
                        output.PrintMessage(dpc.Output, "Platform(s) not found.\n")
                        return nil
                }</span>
                <span class="cov8" title="1">output.PrintMessage(dpc.Output, "Could not delete platform(s). Reason: ")
                return err</span>
        }
        <span class="cov8" title="1">output.PrintMessage(dpc.Output, "Platform(s) successfully deleted.\n")
        return nil</span>
}

func (dpc *DeletePlatformCmd) cascadeDelete() error <span class="cov8" title="1">{

        platforms, err := dpc.Client.ListPlatforms(&amp;query.Parameters{
                FieldQuery: []string{
                        fmt.Sprintf("name eq '%s'", dpc.name),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(platforms.Platforms) &lt; 1 </span><span class="cov8" title="1">{
                output.PrintMessage(dpc.Output, "Platform(s) not found.")
                return nil
        }</span>

        <span class="cov8" title="1">dpc.Parameters.GeneralParams = append(dpc.Parameters.GeneralParams, fmt.Sprintf("%s=%s", web.QueryParamCascade, "true"))
        dpc.Parameters.GeneralParams = append(dpc.Parameters.GeneralParams, fmt.Sprintf("%s=%s", web.QueryParamAsync, "true"))

        for _, platform := range platforms.Platforms </span><span class="cov8" title="1">{
                location, err := dpc.Client.DeletePlatform(platform.ID, &amp;dpc.Parameters)
                if err != nil </span><span class="cov8" title="1">{
                        // The platform could be deleted after List and before Delete
                        if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">output.PrintMessage(dpc.Output, "Could not cascade-delete platform %s. Reason: %s\n", platform.ID, err)
                        continue</span>
                }
                <span class="cov8" title="1">if len(location) != 0 </span><span class="cov8" title="1">{
                        cmd.CommonHandleAsyncExecution(dpc.Context, location, fmt.Sprintf("Cascade delete successfully scheduled for platform id: %s . "+
                                "To see status of the operation use:\n", platform.ID))
                        continue</span>
                }

                // Something went wrong in SM.
                // SM must return location&gt;0, because it's async flow
                <span class="cov0" title="0">output.PrintMessage(dpc.Output, "Error: Unable to get operation ID for platform %s.\n", platform.ID)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// HideUsage hide command's usage
func (dpc *DeletePlatformCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// AskForConfirmation asks the user to confirm deletion
func (dpc *DeletePlatformCmd) AskForConfirmation() (bool, error) <span class="cov8" title="1">{
        if !dpc.force </span><span class="cov8" title="1">{
                message := fmt.Sprintf("Do you really want to delete platforms with names [%s] (Y/n): ", dpc.name)
                return cmd.CommonConfirmationPrompt(message, dpc.Context, dpc.input)
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// PrintDeclineMessage prints confirmation decline message to the user
func (dpc *DeletePlatformCmd) PrintDeclineMessage() <span class="cov8" title="1">{
        cmd.CommonPrintDeclineMessage(dpc.Output)
}</span>

// Prepare returns cobra command
func (dpc *DeletePlatformCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "delete-platform [name]",
                Aliases: []string{"dp"},
                Short:   "Deletes platforms",
                Long:    `Delete one or more platforms with name.`,
                PreRunE: prepare(dpc, dpc.Context),
                RunE:    cmd.RunE(dpc),
        }
        dpc.cascadeFlag = result.PersistentFlags().Bool("cascade", false, "Cascade delete platform with all the associated resources")
        result.Flags().BoolVarP(&amp;dpc.force, "force", "f", false, "Force delete without confirmation")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;dpc.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package platform

import (
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
)

// ListPlatformsCmd wraps the smctl list-brokers command
type ListPlatformsCmd struct {
        *cmd.Context

        outputFormat output.Format
}

// NewListPlatformsCmd returns new list-brokers command with context
func NewListPlatformsCmd(context *cmd.Context) *ListPlatformsCmd <span class="cov8" title="1">{
        return &amp;ListPlatformsCmd{Context: context}
}</span>

// Run runs the command's logic
func (lp *ListPlatformsCmd) Run() error <span class="cov8" title="1">{
        platforms, err := lp.Client.ListPlatforms(&amp;lp.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(lp.Output, lp.outputFormat, platforms)
        output.Println(lp.Output)

        return nil</span>
}

// SetOutputFormat set output format
func (lp *ListPlatformsCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        lp.outputFormat = format
}</span>

// HideUsage hide command's usage
func (lp *ListPlatformsCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (lp *ListPlatformsCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "list-platforms",
                Aliases: []string{"lp"},
                Short:   "List platforms",
                Long:    `List all platforms.`,
                PreRunE: prepare(lp, lp.Context),
                RunE:    cmd.RunE(lp),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddQueryingFlags(result.Flags(), &amp;lp.Parameters)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;lp.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package platform

import (
        "fmt"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/types"

        "github.com/spf13/cobra"
)

// RegisterPlatformCmd wraps the smctl register-platform command
type RegisterPlatformCmd struct {
        *cmd.Context

        platform types.Platform

        outputFormat output.Format
}

// NewRegisterPlatformCmd returns new register-platform command with context
func NewRegisterPlatformCmd(context *cmd.Context) *RegisterPlatformCmd <span class="cov8" title="1">{
        return &amp;RegisterPlatformCmd{Context: context, platform: types.Platform{}}
}</span>

// SetOutputFormat set command's output format
func (rpc *RegisterPlatformCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        rpc.outputFormat = format
}</span>

// HideUsage hide command's usage
func (rpc *RegisterPlatformCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (rpc *RegisterPlatformCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "register-platform [name] [type] &lt;description&gt;",
                Aliases: []string{"rp"},
                Short:   "Registers a platform",
                Long:    `Registers a platform`,

                PreRunE: prepare(rpc, rpc.Context),
                RunE:    cmd.RunE(rpc),
        }

        result.Flags().StringVarP(&amp;rpc.platform.ID, "id", "i", "", "external platform ID")
        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;rpc.Parameters)

        return result
}</span>

// Validate validates command's arguments
func (rpc *RegisterPlatformCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("requires at least 2 args")
        }</span>

        <span class="cov8" title="1">rpc.platform.Name = args[0]
        rpc.platform.Type = args[1]

        if len(args) &gt; 2 </span><span class="cov8" title="1">{
                rpc.platform.Description = args[2]
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Run runs command's logic
func (rpc *RegisterPlatformCmd) Run() error <span class="cov8" title="1">{
        resultPlatform, err := rpc.Client.RegisterPlatform(&amp;rpc.platform, &amp;rpc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(rpc.Output, rpc.outputFormat, resultPlatform)
        output.Println(rpc.Output)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package platform

import (
        "encoding/json"
        "fmt"

        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/pkg/types"
)

// UpdatePlatformCmd wraps the smctl update-platform command
type UpdatePlatformCmd struct {
        *cmd.Context

        outputFormat          output.Format
        name                  string
        regenerateCredentials bool
        updatedPlatform       *types.Platform
}

// NewUpdatePlatformCmd returns new update-platform command with context
func NewUpdatePlatformCmd(context *cmd.Context) *UpdatePlatformCmd <span class="cov8" title="1">{
        return &amp;UpdatePlatformCmd{Context: context}
}</span>

// Validate validates command's arguments
func (upc *UpdatePlatformCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("[name] is required")
        }</span>

        <span class="cov8" title="1">upc.name = args[0]

        if len(args) &lt; 2 &amp;&amp; !upc.regenerateCredentials </span><span class="cov8" title="1">{
                return fmt.Errorf("nothing to update. Platform JSON is not provided")
        }</span>

        <span class="cov8" title="1">if len(args) &gt;= 2 </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(args[1]), &amp;upc.updatedPlatform); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("platform JSON is invalid. Reason: %s", err.Error())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Run runs the command's logic
func (upc *UpdatePlatformCmd) Run() error <span class="cov8" title="1">{
        upc.Parameters.FieldQuery = append(upc.Parameters.FieldQuery, fmt.Sprintf("name eq '%s'", upc.name))
        toUpdatePlatforms, err := upc.Client.ListPlatforms(&amp;upc.Parameters)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(toUpdatePlatforms.Platforms) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("platform with name %s not found", upc.name)
        }</span>
        <span class="cov8" title="1">toUpdatePlatform := toUpdatePlatforms.Platforms[0]
        if upc.regenerateCredentials </span><span class="cov8" title="1">{
                upc.Parameters.GeneralParams = append(upc.Parameters.GeneralParams, "regenerateCredentials=true")
        }</span>
        <span class="cov8" title="1">result, err := upc.Client.UpdatePlatform(toUpdatePlatform.ID, upc.updatedPlatform, &amp;upc.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(upc.Output, upc.outputFormat, result)
        output.Println(upc.Output)

        return nil</span>
}

// HideUsage hide command's usage
func (upc *UpdatePlatformCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (upc *UpdatePlatformCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "update-platform [name] &lt;json_platform&gt;",
                Aliases: []string{"up"},
                Short:   "Updates platform",
                Long: `Update platform with name.
Example:
smctl update-platform platform '{"name": "new-name", "description": "new-description", "type": "new-type"}'`,
                PreRunE: prepare(upc, upc.Context),
                RunE:    cmd.RunE(upc),
        }

        result.Flags().BoolVarP(&amp;upc.regenerateCredentials, "regenerate-credentials", "c", false, "Whether to regenerate credentials")

        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;upc.Parameters)

        return result
}</span>

// SetOutputFormat set output format
func (upc *UpdatePlatformCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        upc.outputFormat = format
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package cmd

import (
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"

        "github.com/Peripli/service-manager-cli/internal/configuration"
        "github.com/Peripli/service-manager/pkg/log"
)

// Execute executes the root command
func Execute(cmd *cobra.Command) <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

// BuildRootCommand builds a new SM root command with context
func BuildRootCommand(ctx *Context) *cobra.Command <span class="cov0" title="0">{
        var cfgFile string
        viperEnv := viper.New()

        rootCmd := &amp;cobra.Command{
                Use:   "smctl",
                Short: "Service Manager CLI",
                Long:  `smctl controls a Service Manager instance.`,

                PersistentPreRunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        var err error
                        if ctx.Ctx, err = log.Configure(ctx.Ctx, logSettings(ctx.Verbose)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">cmd.SilenceUsage = true

                        if ctx.Output == nil </span><span class="cov0" title="0">{
                                ctx.Output = cmd.OutOrStdout()
                        }</span>
                        <span class="cov0" title="0">if ctx.Configuration == nil </span><span class="cov0" title="0">{
                                configuration, err := configuration.NewSMConfiguration(viperEnv, cfgFile)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">ctx.Configuration = configuration</span>
                        }

                        <span class="cov0" title="0">cmd.SilenceUsage = false
                        return nil</span>
                },
        }

        <span class="cov0" title="0">rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.sm/config.json)")
        rootCmd.PersistentFlags().BoolVarP(&amp;ctx.Verbose, "verbose", "v", false, "verbose")

        return rootCmd</span>
}

func logSettings(verbose bool) *log.Settings <span class="cov0" title="0">{
        settings := log.DefaultSettings()
        if verbose </span><span class="cov0" title="0">{
                settings.Level = "debug"
        }</span> else<span class="cov0" title="0"> {
                settings.Level = "info"
        }</span>
        <span class="cov0" title="0">return settings</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package status

import (
        "fmt"
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
        "strings"
)

// Cmd wraps smctl status command
type Cmd struct {
        *cmd.Context

        operationURL string
        outputFormat output.Format
}

// NewStatusCmd returns new label command with context
func NewStatusCmd(context *cmd.Context) *Cmd <span class="cov8" title="1">{
        return &amp;Cmd{Context: context}
}</span>

// Prepare returns cobra command
func (c *Cmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:   "status [operation URL path]",
                Short: "Get asynchronous operation's status",
                Long:  "Get asynchronous operation's status",

                PreRunE: prepare(c, c.Context),
                RunE:    cmd.RunE(c),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;c.Parameters)

        return result
}</span>

// Validate validates command's arguments
func (c *Cmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("a path to operation is required")
        }</span>
        <span class="cov8" title="1">c.operationURL = args[0]
        return nil</span>
}

// Run runs the command's logic
func (c *Cmd) Run() error <span class="cov8" title="1">{
        operation, err := c.Client.Status(c.operationURL, &amp;c.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov8" title="1">{
                        output.PrintMessage(c.Output, "Operation not found.\n")
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">output.PrintServiceManagerObject(c.Output, c.outputFormat, operation)
        output.Println(c.Output)

        return nil</span>
}

// HideUsage hide command's usage
func (c *Cmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// SetOutputFormat set output format
func (c *Cmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        c.outputFormat = format
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package version

import (
        "github.com/spf13/cobra"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
)

// Cmd wraps the smctl version command
type Cmd struct {
        *cmd.Context
}

// Version is the tool version, injected by the build
var Version = "local.build"

// GitCommit is the git commit id, injected by the build
var GitCommit string

// NewVersionCmd returns new version command
func NewVersionCmd(context *cmd.Context) *Cmd <span class="cov8" title="1">{
        return &amp;Cmd{context}
}</span>

// Prepare returns cobra command
func (vc *Cmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "version",
                Aliases: []string{"v"},
                Short:   "Prints smctl version",
                Long:    `Prints smctl version.`,

                PreRunE: prepare(vc, vc.Context),
                RunE:    cmd.RunE(vc),
        }

        return result
}</span>

// Run runs command's logic
func (vc *Cmd) Run() error <span class="cov8" title="1">{
        output.PrintMessage(vc.Output, "Service Manager Client %s (%s)\n", Version, GitCommit)

        return nil
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package visibility

import (
        "fmt"
        "io"
        "strings"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// DeleteVisibilityCmd wraps the smctl delete-visibility command
type DeleteVisibilityCmd struct {
        *cmd.Context

        input io.Reader
        force bool

        id string
}

// NewDeleteVisibilityCmd returns new delete-visibility command with context
func NewDeleteVisibilityCmd(context *cmd.Context, input io.Reader) *DeleteVisibilityCmd <span class="cov8" title="1">{
        return &amp;DeleteVisibilityCmd{Context: context, input: input}
}</span>

// Validate validates command's arguments
func (dv *DeleteVisibilityCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("single [id] is required")
        }</span>

        <span class="cov8" title="1">dv.id = args[0]

        return nil</span>
}

// Run runs the command's logic
func (dv *DeleteVisibilityCmd) Run() error <span class="cov8" title="1">{
        dv.Parameters.FieldQuery = append(dv.Parameters.FieldQuery, fmt.Sprintf("id eq '%s'", dv.id))

        if err := dv.Client.DeleteVisibilities(&amp;dv.Parameters); err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "StatusCode: 404") </span><span class="cov8" title="1">{
                        output.PrintMessage(dv.Output, "Visibility not found.\n")
                        return nil
                }</span>
                <span class="cov0" title="0">output.PrintMessage(dv.Output, "Could not delete visibility(s). Reason: ")
                return err</span>
        }
        <span class="cov8" title="1">output.PrintMessage(dv.Output, "Visibility successfully deleted.\n")
        return nil</span>
}

// HideUsage hide command's usage
func (dv *DeleteVisibilityCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// AskForConfirmation asks the user to confirm deletion
func (dv *DeleteVisibilityCmd) AskForConfirmation() (bool, error) <span class="cov8" title="1">{
        if !dv.force </span><span class="cov8" title="1">{
                message := fmt.Sprintf("Do you really want to delete visibilities with ids [%s] (Y/n): ", dv.id)
                return cmd.CommonConfirmationPrompt(message, dv.Context, dv.input)
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// PrintDeclineMessage prints confirmation decline message to the user
func (dv *DeleteVisibilityCmd) PrintDeclineMessage() <span class="cov8" title="1">{
        cmd.CommonPrintDeclineMessage(dv.Output)
}</span>

// Prepare returns cobra command
func (dv *DeleteVisibilityCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "delete-visibility [id]",
                Aliases: []string{"dv"},
                Short:   "Deletes visibility",
                Long:    `Delete one or more visibilities by name.`,
                PreRunE: prepare(dv, dv.Context),
                RunE:    cmd.RunE(dv),
        }

        result.Flags().BoolVarP(&amp;dv.force, "force", "f", false, "Force delete without confirmation")
        cmd.AddCommonQueryFlag(result.Flags(), &amp;dv.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package visibility

import (
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/spf13/cobra"
)

// ListVisibilitiesCmd wraps the smctl list-visibilities command
type ListVisibilitiesCmd struct {
        *cmd.Context

        outputFormat output.Format
}

// NewListVisibilitiesCmd returns new list-visibilities command with context
func NewListVisibilitiesCmd(context *cmd.Context) *ListVisibilitiesCmd <span class="cov8" title="1">{
        return &amp;ListVisibilitiesCmd{Context: context}
}</span>

//Run runs the command's logic
func (lv *ListVisibilitiesCmd) Run() error <span class="cov8" title="1">{
        visibilities, err := lv.Client.ListVisibilities(&amp;lv.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">output.PrintServiceManagerObject(lv.Output, lv.outputFormat, visibilities)
        output.Println(lv.Output)
        return nil</span>
}

// SetOutputFormat sets output format
func (lv *ListVisibilitiesCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        lv.outputFormat = format
}</span>

// HideUsage hides command's usage
func (lv *ListVisibilitiesCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (lv *ListVisibilitiesCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "list-visibilities",
                Aliases: []string{"lv"},
                Short:   "List visibilities",
                Long:    "List all visibilities.",
                PreRunE: prepare(lv, lv.Context),
                RunE:    cmd.RunE(lv),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddQueryingFlags(result.Flags(), &amp;lv.Parameters)
        cmd.AddCommonQueryFlag(result.Flags(), &amp;lv.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package visibility

import (
        "fmt"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/types"
        "github.com/spf13/cobra"
)

// RegisterVisibilityCmd wraps the smctl register-visibility command
type RegisterVisibilityCmd struct {
        *cmd.Context

        visibility types.Visibility

        outputFormat output.Format
}

// NewRegisterVisibilityCmd returns new smctl register-visibility command with context
func NewRegisterVisibilityCmd(ctx *cmd.Context) *RegisterVisibilityCmd <span class="cov8" title="1">{
        return &amp;RegisterVisibilityCmd{Context: ctx}
}</span>

// Validate validates command's arguments
func (rv *RegisterVisibilityCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("platform-id and service-plan-id required but not provided")
        }</span>
        <span class="cov8" title="1">rv.visibility.PlatformID = args[0]
        rv.visibility.ServicePlanID = args[1]
        return nil</span>
}

// Run runs command's logic
func (rv *RegisterVisibilityCmd) Run() error <span class="cov8" title="1">{
        resultVisibility, err := rv.Client.RegisterVisibility(&amp;rv.visibility, &amp;rv.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(rv.Output, rv.outputFormat, resultVisibility)
        output.Println(rv.Output)
        return nil</span>
}

// SetOutputFormat sets command's output format
func (rv *RegisterVisibilityCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        rv.outputFormat = format
}</span>

// HideUsage hide command's usage
func (rv *RegisterVisibilityCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// Prepare returns cobra command
func (rv *RegisterVisibilityCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "register-visibility [platform id] [service plan id]",
                Aliases: []string{"rv"},
                Short:   "Registers a visibility",
                Long:    "Registers a visibility",

                PreRunE: prepare(rv, rv.Context),
                RunE:    cmd.RunE(rv),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;rv.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package visibility

import (
        "encoding/json"
        "fmt"

        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/output"
        "github.com/Peripli/service-manager-cli/pkg/types"
        "github.com/spf13/cobra"
)

// UpdateVisibilityCmd wraps smctl update-visibility command
type UpdateVisibilityCmd struct {
        *cmd.Context

        outputFormat      output.Format
        id                string
        updatedVisibility *types.Visibility
}

// NewUpdateVisibilityCmd returns new smctl update-visibility command with context
func NewUpdateVisibilityCmd(context *cmd.Context) *UpdateVisibilityCmd <span class="cov8" title="1">{
        return &amp;UpdateVisibilityCmd{Context: context}
}</span>

// Validate validates command's arguments
func (uv *UpdateVisibilityCmd) Validate(args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("id is required")
        }</span>

        <span class="cov8" title="1">uv.id = args[0]

        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("nothing to update. Visibility JSON is not provided")
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal([]byte(args[1]), &amp;uv.updatedVisibility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("visibility JSON is invalid. Reason: %s", err.Error())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Run runs the command's logic
func (uv *UpdateVisibilityCmd) Run() error <span class="cov8" title="1">{
        updatedVisibility, err := uv.Client.UpdateVisibility(uv.id, uv.updatedVisibility, &amp;uv.Parameters)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">output.PrintServiceManagerObject(uv.Output, uv.outputFormat, updatedVisibility)
        output.Println(uv.Output)
        return nil</span>
}

// HideUsage hide command's usage
func (uv *UpdateVisibilityCmd) HideUsage() bool <span class="cov8" title="1">{
        return true
}</span>

// SetOutputFormat set output format
func (uv *UpdateVisibilityCmd) SetOutputFormat(format output.Format) <span class="cov8" title="1">{
        uv.outputFormat = format
}</span>

//Prepare returns cobra command
func (uv *UpdateVisibilityCmd) Prepare(prepare cmd.PrepareFunc) *cobra.Command <span class="cov8" title="1">{
        result := &amp;cobra.Command{
                Use:     "update-visibility [id] &lt;json-visibility&gt;",
                Aliases: []string{"uv"},
                Short:   "Updates visibility",
                Long:    "Updates visibility by id.",
                PreRunE: prepare(uv, uv.Context),
                RunE:    cmd.RunE(uv),
        }

        cmd.AddFormatFlag(result.Flags())
        cmd.AddCommonQueryFlag(result.Flags(), &amp;uv.Parameters)

        return result
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package configuration

import (
        "fmt"
        "os"
        "path/filepath"
        "runtime"
)

const (
        defaultConfigDirName  = ".sm"
        defaultConfigFileName = "config.json"
)

func ensureDirExists(path string) error <span class="cov8" title="1">{
        dirPath := filepath.Dir(path)
        if _, err := os.Stat(dirPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if mkderr := os.Mkdir(dirPath, 0700); mkderr != nil </span><span class="cov0" title="0">{
                        return mkderr
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func defaultFilePath() (string, error) <span class="cov0" title="0">{
        homeDir, err := homeDir()

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return filepath.Join(homeDir, defaultConfigDirName, defaultConfigFileName), nil</span>
}

func homeDir() (string, error) <span class="cov0" title="0">{
        var homeDir string

        if os.Getenv("SM_HOME") != "" </span><span class="cov0" title="0">{
                homeDir = os.Getenv("SM_HOME")

                if _, err := os.Stat(homeDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("error locating SM_HOME folder '%s'", homeDir)
                }</span>
        } else<span class="cov0" title="0"> {
                homeDir = userHomeDir()
        }</span>

        <span class="cov0" title="0">return homeDir, nil</span>
}

// See: http://stackoverflow.com/questions/7922270/obtain-users-home-directory
// we can't cross compile using cgo and use user.Current()
var userHomeDir = func() string <span class="cov0" title="0">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                home := os.Getenv("HOMEDRIVE") + os.Getenv("HOMEPATH")
                if home == "" </span><span class="cov0" title="0">{
                        home = os.Getenv("USERPROFILE")
                }</span>
                <span class="cov0" title="0">return home</span>
        }

        <span class="cov0" title="0">return os.Getenv("HOME")</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package configuration

import (
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/Peripli/service-manager-cli/internal/util"
        "github.com/Peripli/service-manager-cli/pkg/auth"
        "github.com/spf13/viper"
)

// Settings contains the information that will be saved/loaded in the CLI config file
type Settings struct {
        auth.Token

        ClientID              string
        ClientSecret          string
        AuthorizationEndpoint string
        TokenEndpoint         string
        IssuerURL             string
        AuthFlow              auth.Flow

        URL            string
        User           string
        TokenBasicAuth bool
        SSLDisabled    bool
}

// Validate validates client config
func (settings Settings) Validate() error <span class="cov8" title="1">{
        if err := util.ValidateURL(settings.URL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if settings.User == "" </span><span class="cov0" title="0">{
                return errors.New("user must not be empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetToken returns the oauth token from the client configuration
func (settings Settings) GetToken() auth.Token <span class="cov0" title="0">{
        return settings.Token
}</span>

// Configuration should be implemented for load and save of SM client config
//go:generate counterfeiter . Configuration
type Configuration interface {
        Save(*Settings) error
        Load() (*Settings, error)
}

type smConfiguration struct {
        viperEnv *viper.Viper
}

// NewSMConfiguration returns implementation of Configuration interface
func NewSMConfiguration(viperEnv *viper.Viper, cfgFile string) (Configuration, error) <span class="cov8" title="1">{
        if cfgFile == "" </span><span class="cov0" title="0">{
                var err error
                cfgFile, err = defaultFilePath()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if err := ensureDirExists(cfgFile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">viperEnv.SetConfigFile(cfgFile)
        viperEnv.SetDefault("token_basic_auth", true) // RFC 6749 section 2.3.1

        return &amp;smConfiguration{viperEnv}, nil</span>
}

// Save implements configuration save
func (smCfg *smConfiguration) Save(settings *Settings) error <span class="cov8" title="1">{
        smCfg.viperEnv.Set("url", settings.URL)
        smCfg.viperEnv.Set("user", settings.User)
        smCfg.viperEnv.Set("ssl_disabled", settings.SSLDisabled)
        smCfg.viperEnv.Set("token_basic_auth", settings.TokenBasicAuth)

        smCfg.viperEnv.Set("access_token", settings.AccessToken)
        smCfg.viperEnv.Set("refresh_token", settings.RefreshToken)
        smCfg.viperEnv.Set("expiry", settings.ExpiresIn.Format(time.RFC1123Z))

        smCfg.viperEnv.Set("client_id", settings.ClientID)
        smCfg.viperEnv.Set("client_secret", settings.ClientSecret)
        smCfg.viperEnv.Set("issuer_url", settings.IssuerURL)
        smCfg.viperEnv.Set("token_url", settings.TokenEndpoint)
        smCfg.viperEnv.Set("auth_url", settings.AuthorizationEndpoint)
        smCfg.viperEnv.Set("auth_flow", string(settings.AuthFlow))

        cfgFile := smCfg.viperEnv.ConfigFileUsed()
        if err := smCfg.viperEnv.WriteConfig(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not save config file %s: %s", cfgFile, err)
        }</span>
        <span class="cov8" title="1">const ownerAccessOnly = 0600
        if err := os.Chmod(cfgFile, ownerAccessOnly); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("could not set access rights of config file %s: %s", cfgFile, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Load implements configuration load
func (smCfg *smConfiguration) Load() (*Settings, error) <span class="cov8" title="1">{
        if err := smCfg.viperEnv.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">settings := &amp;Settings{}

        if err := smCfg.viperEnv.Unmarshal(&amp;settings); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">settings.SSLDisabled = smCfg.viperEnv.Get("ssl_disabled").(bool)
        settings.TokenBasicAuth = smCfg.viperEnv.Get("token_basic_auth").(bool)
        settings.AccessToken = smCfg.viperEnv.Get("access_token").(string)
        settings.RefreshToken = smCfg.viperEnv.Get("refresh_token").(string)
        settings.ExpiresIn, _ = time.Parse(time.RFC1123Z, smCfg.viperEnv.Get("expiry").(string))
        settings.TokenEndpoint = smCfg.viperEnv.Get("token_url").(string)
        settings.AuthorizationEndpoint = smCfg.viperEnv.Get("auth_url").(string)
        settings.AuthFlow = auth.Flow(smCfg.viperEnv.Get("auth_flow").(string))
        settings.IssuerURL = smCfg.viperEnv.Get("issuer_url").(string)
        settings.ClientID = smCfg.viperEnv.Get("client_id").(string)
        settings.ClientSecret = smCfg.viperEnv.Get("client_secret").(string)

        if err := settings.Validate(); err != nil </span><span class="cov0" title="0">{
                return settings, err
        }</span>

        <span class="cov8" title="1">return settings, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package output

import (
        "fmt"
        "io"
        "encoding/json"

        "github.com/Peripli/service-manager-cli/pkg/types"
)

// Format is predefined type for output format
type Format int

const (
        // FormatText const for text output format
        FormatText = iota
        // FormatJSON const for json output format
        FormatJSON
        // FormatYAML const for yaml output format
        FormatYAML
        // FormatUnknown const for unknown output format
        FormatUnknown
)

var (
        printers = map[Format]Printer{
                FormatJSON: &amp;JSONPrinter{},
                FormatYAML: &amp;YAMLPrinter{},
        }
)

// PrintError prints an error.
func PrintError(wr io.Writer, err error) <span class="cov0" title="0">{
        if _, err := fmt.Fprintf(wr, "Error: %s\n", err); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// PrintMessage prints a message.
func PrintMessage(wr io.Writer, format string, a ...interface{}) <span class="cov8" title="1">{
        if _, err := fmt.Fprintf(wr, format, a...); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// Println prints a new line.
func Println(wr io.Writer) <span class="cov8" title="1">{
        if _, err := fmt.Fprintln(wr); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// PrintTable prints in table format
func PrintTable(wr io.Writer, data *types.TableData) <span class="cov8" title="1">{
        if _, err := fmt.Fprint(wr, data); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// PrintServiceManagerObject should be used for printing SM objects in different formats
func PrintServiceManagerObject(wr io.Writer, outputFormat Format, object types.ServiceManagerObject) <span class="cov8" title="1">{
        tableDataPrinter, isTableDataPrinter := object.(types.TableDataPrinter)
        if outputFormat == FormatText &amp;&amp; isTableDataPrinter </span><span class="cov8" title="1">{
                PrintMessage(wr, object.Message())
                Println(wr)
                if !object.IsEmpty() </span><span class="cov8" title="1">{
                        PrintTable(wr, tableDataPrinter.TableData())
                        Println(wr)
                }</span>
        } else<span class="cov8" title="1"> {
                printers[outputFormat].Print(wr, object)
        }</span>
}

type converterFunc func([]byte) (interface{}, error)

// PrintFormat prints the object in the provided format if possible
func PrintFormat(wr io.Writer, outputFormat Format, encodedObject []byte, converter converterFunc) error <span class="cov8" title="1">{
        object, err := converter(encodedObject)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">printer, found := printers[outputFormat]
        if !found </span><span class="cov0" title="0">{
                PrintMessage(wr, string(encodedObject))
                return nil
        }</span>
        <span class="cov8" title="1">printer.Print(wr, object)
        return nil</span>
}
// PrintParameters convert map to string
func PrintParameters(parameters map[string]interface{}) string<span class="cov8" title="1">{
        jsonParameters,_ := json.MarshalIndent(parameters, "", "   ")
        stringParams := string(jsonParameters)
        return stringParams
}</pre>
		
		<pre class="file" id="file39" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package output

import (
        "bytes"
        "encoding/json"
        "io"

        yaml "gopkg.in/yaml.v2"
)

// Printer should be implemented for different output formats
type Printer interface {
        // Print is executed with writer and data to be printed
        Print(io.Writer, interface{})
}

// JSONPrinter implements Printer interface and outputs in JSON format
type JSONPrinter struct{}

// Print prints in json format
func (p *JSONPrinter) Print(wr io.Writer, data interface{}) <span class="cov8" title="1">{
        b, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                PrintError(wr, err)
        }</span> else<span class="cov8" title="1"> {
                var out bytes.Buffer
                err := json.Indent(&amp;out, b, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        PrintError(wr, err)
                }</span>
                <span class="cov8" title="1">PrintMessage(wr, out.String())</span>
        }
}

// YAMLPrinter implements Printer interface and outputs in YAML format
type YAMLPrinter struct{}

// Print prints in yaml format
func (p *YAMLPrinter) Print(wr io.Writer, data interface{}) <span class="cov8" title="1">{
        b, err := yaml.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                PrintError(wr, err)
        }</span> else<span class="cov8" title="1"> {
                PrintMessage(wr, string(b))
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package util

import (
        "crypto/tls"
        "errors"
        "fmt"
        "github.com/Peripli/service-manager-cli/pkg/auth"
        "net"
        "net/http"
        "net/url"
        "time"
)

// ValidateURL validates a URL
func ValidateURL(URL string) error <span class="cov8" title="1">{
        if URL == "" </span><span class="cov0" title="0">{
                return errors.New("url not provided")
        }</span>

        <span class="cov8" title="1">parsedURL, err := url.Parse(URL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("url cannot be parsed: %s", err)
        }</span>

        <span class="cov8" title="1">if !parsedURL.IsAbs() || (parsedURL.Scheme != "http" &amp;&amp; parsedURL.Scheme != "https") </span><span class="cov8" title="1">{
                return fmt.Errorf("url is not an HTTP URL: %s", URL)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BuildHTTPClient builds custom http client with configured ssl validation / mtls
func BuildHTTPClient(options *auth.Options) (*http.Client, error) <span class="cov8" title="1">{
        client := getClient()

        if MtlsEnabled(options) </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(options.Certificate, options.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">client.Transport.(*http.Transport).TLSClientConfig = &amp;tls.Config{
                        Certificates: []tls.Certificate{cert},
                }

                return client, nil</span>
        } else<span class="cov8" title="1"> {
                if options.SSLDisabled </span><span class="cov0" title="0">{
                        client.Transport.(*http.Transport).TLSClientConfig = &amp;tls.Config{InsecureSkipVerify: true}
                }</span>
        }

        <span class="cov8" title="1">return client, nil</span>
}

func MtlsEnabled(options *auth.Options) bool <span class="cov8" title="1">{
        return len(options.Certificate) &gt; 0 &amp;&amp; len(options.Key) &gt; 0
}</span>

func getClient() *http.Client <span class="cov8" title="1">{
        return &amp;http.Client{
                Timeout: time.Second * 10,
                Transport: &amp;http.Transport{
                        Proxy: http.ProxyFromEnvironment,
                        DialContext: (&amp;net.Dialer{
                                Timeout:   30 * time.Second,
                                KeepAlive: 30 * time.Second,
                        }).DialContext,
                        MaxIdleConns:          100,
                        IdleConnTimeout:       90 * time.Second,
                        TLSHandshakeTimeout:   10 * time.Second,
                        ExpectContinueTimeout: 1 * time.Second,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package main

import (
        "context"
        "github.com/Peripli/service-manager-cli/internal/cmd"
        "github.com/Peripli/service-manager-cli/internal/cmd/binding"
        "github.com/Peripli/service-manager-cli/internal/cmd/broker"
        "github.com/Peripli/service-manager-cli/internal/cmd/curl"
        "github.com/Peripli/service-manager-cli/internal/cmd/info"
        "github.com/Peripli/service-manager-cli/internal/cmd/instance"
        "github.com/Peripli/service-manager-cli/internal/cmd/label"
        "github.com/Peripli/service-manager-cli/internal/cmd/login"
        "github.com/Peripli/service-manager-cli/internal/cmd/logout"
        "github.com/Peripli/service-manager-cli/internal/cmd/offering"
        "github.com/Peripli/service-manager-cli/internal/cmd/plan"
        "github.com/Peripli/service-manager-cli/internal/cmd/platform"
        "github.com/Peripli/service-manager-cli/internal/cmd/status"
        "github.com/Peripli/service-manager-cli/internal/cmd/version"
        "github.com/Peripli/service-manager-cli/internal/cmd/visibility"
        "github.com/Peripli/service-manager-cli/pkg/auth"
        "github.com/Peripli/service-manager-cli/pkg/auth/oidc"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"

        "os"
)

func oidcAuthBuilder(options *auth.Options) (auth.Authenticator, *auth.Options, error) <span class="cov0" title="0">{
        return oidc.NewOpenIDStrategy(options)
}</span>

func main() <span class="cov0" title="0">{
        cmdContext := &amp;cmd.Context{
                Ctx: context.Background(),
        }
        rootCmd := cmd.BuildRootCommand(cmdContext)
        fs := afero.NewOsFs()

        normalCommandsGroup := cmd.Group{
                Commands: []cmd.CommandPreparator{
                        login.NewLoginCmd(cmdContext, os.Stdin, oidcAuthBuilder),
                        version.NewVersionCmd(cmdContext),
                        logout.NewLogoutCmd(cmdContext),
                        info.NewInfoCmd(cmdContext),
                },
                PrepareFn: cmd.CommonPrepare,
        }

        smCommandsGroup := cmd.Group{
                Commands: []cmd.CommandPreparator{
                        curl.NewCurlCmd(cmdContext, fs),
                        binding.NewListBindingsCmd(cmdContext),
                        binding.NewGetBindingCmd(cmdContext),
                        binding.NewBindCmd(cmdContext),
                        binding.NewUnbindCmd(cmdContext, os.Stdin),
                        broker.NewRegisterBrokerCmd(cmdContext),
                        broker.NewGetBrokerCmd(cmdContext),
                        broker.NewListBrokersCmd(cmdContext),
                        broker.NewDeleteBrokerCmd(cmdContext, os.Stdin),
                        broker.NewUpdateBrokerCmd(cmdContext),
                        platform.NewRegisterPlatformCmd(cmdContext),
                        platform.NewListPlatformsCmd(cmdContext),
                        platform.NewDeletePlatformCmd(cmdContext, os.Stdin),
                        platform.NewUpdatePlatformCmd(cmdContext),
                        visibility.NewRegisterVisibilityCmd(cmdContext),
                        visibility.NewListVisibilitiesCmd(cmdContext),
                        visibility.NewUpdateVisibilityCmd(cmdContext),
                        visibility.NewDeleteVisibilityCmd(cmdContext, os.Stdin),
                        offering.NewListOfferingsCmd(cmdContext),
                        offering.NewMarketplaceCmd(cmdContext),
                        plan.NewListPlansCmd(cmdContext),
                        label.NewLabelCmd(cmdContext),
                        status.NewStatusCmd(cmdContext),
                        instance.NewListInstancesCmd(cmdContext),
                        instance.NewGetInstanceCmd(cmdContext),
                        instance.NewProvisionCmd(cmdContext),
                        instance.NewDeprovisionCmd(cmdContext, os.Stdin),
                        instance.NewTransferCmd(cmdContext, os.Stdin),
                        instance.NewUpdateInstanceCmd(cmdContext),
                        instance.NewUpdateSharingCmd(cmdContext,true),
                        instance.NewUpdateSharingCmd(cmdContext,false),


                },
                PrepareFn: cmd.SmPrepare,
        }

        registerGroups(rootCmd, normalCommandsGroup, smCommandsGroup)

        cmd.Execute(rootCmd)
}</span>

func registerGroups(rootCmd *cobra.Command, groups ...cmd.Group) <span class="cov0" title="0">{
        for _, group := range groups </span><span class="cov0" title="0">{
                for _, command := range group.Commands </span><span class="cov0" title="0">{
                        cobraCmd := command.Prepare(group.PrepareFn)
                        rootCmd.AddCommand(cobraCmd)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package auth

// GetToken uses the provided authenticator to get a token using the
// appropriate flow depending on the provided options
func GetToken(options *Options, authenticator Authenticator) (*Token, error) <span class="cov0" title="0">{
        if options.User != "" &amp;&amp; options.Password != "" </span><span class="cov0" title="0">{
                return authenticator.PasswordCredentials(options.User, options.Password)
        }</span>
        <span class="cov0" title="0">return authenticator.ClientCredentials()</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package oidc

import (
        "context"
        "errors"
        "net/http"

        "github.com/Peripli/service-manager-cli/internal/util"
        "github.com/Peripli/service-manager-cli/pkg/auth"
        "github.com/Peripli/service-manager-cli/pkg/httputil"
        "golang.org/x/oauth2"
        "golang.org/x/oauth2/clientcredentials"
)

// ErrTokenExpired indicates that the access token has expired and cannot be refreshed
var ErrTokenExpired = errors.New("access token has expired")

// NewClient builds configured HTTP client.
//
// If token is provided will try to refresh the token if it has expired,
// otherwise if token is not provided will do client_credentials flow and fetch token
func NewClient(options *auth.Options, token *auth.Token) (*Client, error) <span class="cov8" title="1">{
        httpClient, err := util.BuildHTTPClient(options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpClient.Timeout = options.Timeout

        ctx := context.WithValue(context.Background(), oauth2.HTTPClient, httpClient)

        var tt oauth2.Token
        if token != nil </span><span class="cov8" title="1">{
                tt.AccessToken = token.AccessToken
                tt.RefreshToken = token.RefreshToken
                tt.Expiry = token.ExpiresIn
                tt.TokenType = token.TokenType
        }</span>

        <span class="cov8" title="1">flow := options.AuthFlow
        if flow == auth.DefaultFlow </span><span class="cov8" title="1">{
                if options.User != "" </span><span class="cov8" title="1">{
                        flow = auth.PasswordGrant
                }</span> else<span class="cov8" title="1"> {
                        flow = auth.ClientCredentials
                }</span>
        }

        <span class="cov8" title="1">tokenSource := noRefreshTokenSource(tt)
        if options.ClientID != "" </span><span class="cov8" title="1">{
                if tt.RefreshToken != "" </span><span class="cov8" title="1">{
                        tokenSource = refreshTokenSource(ctx, options, tt)
                }</span> else<span class="cov8" title="1"> if flow == auth.ClientCredentials </span><span class="cov8" title="1">{
                        tokenSource = clientCredentialsTokenSource(ctx, options, tt)
                }</span>
        }

        <span class="cov8" title="1">oauthClient := oauth2.NewClient(ctx, tokenSource)
        oauthClient.Timeout = options.Timeout

        return &amp;Client{
                tokenSource: tokenSource,
                httpClient:  oauthClient,
        }, nil</span>
}

type requireLoginTokenSource struct{}

func (requireLoginTokenSource) Token() (*oauth2.Token, error) <span class="cov8" title="1">{
        return nil, ErrTokenExpired
}</span>

func noRefreshTokenSource(token oauth2.Token) oauth2.TokenSource <span class="cov8" title="1">{
        var requireLogin requireLoginTokenSource
        return oauth2.ReuseTokenSource(&amp;token, requireLogin)
}</span>

func refreshTokenSource(ctx context.Context, options *auth.Options, token oauth2.Token) oauth2.TokenSource <span class="cov8" title="1">{
        oauthConfig := newOauth2Config(options)
        return oauthConfig.TokenSource(ctx, &amp;token)
}</span>

func newClientCredentialsConfig(options *auth.Options) *clientcredentials.Config <span class="cov8" title="1">{
        return &amp;clientcredentials.Config{
                ClientID:     options.ClientID,
                ClientSecret: options.ClientSecret,
                TokenURL:     options.TokenEndpoint,
                AuthStyle:    authStyle(options),
        }
}</span>

func newOauth2Config(options *auth.Options) *oauth2.Config <span class="cov8" title="1">{
        return &amp;oauth2.Config{
                ClientID:     options.ClientID,
                ClientSecret: options.ClientSecret,
                Endpoint: oauth2.Endpoint{
                        AuthURL:   options.AuthorizationEndpoint,
                        TokenURL:  options.TokenEndpoint,
                        AuthStyle: authStyle(options),
                },
        }
}</span>

func authStyle(options *auth.Options) oauth2.AuthStyle <span class="cov8" title="1">{
        authStyle := oauth2.AuthStyleAutoDetect
        if !options.TokenBasicAuth </span><span class="cov8" title="1">{
                authStyle = oauth2.AuthStyleInParams
        }</span>
        <span class="cov8" title="1">return authStyle</span>
}

func clientCredentialsTokenSource(ctx context.Context, options *auth.Options, token oauth2.Token) oauth2.TokenSource <span class="cov8" title="1">{
        oauthConfig := newClientCredentialsConfig(options)
        clientCredentialsSource := oauthConfig.TokenSource(ctx)
        // The double wrapping of TokenSource objects is needed, because there is no other way
        // to pass the existing access token and the client will try to fetch a token for each request
        return oauth2.ReuseTokenSource(&amp;token, clientCredentialsSource)
}</span>

// Client is used to make http requests including bearer token automatically and refreshing it
// if necessary
type Client struct {
        tokenSource oauth2.TokenSource
        httpClient  *http.Client
}

// Do makes a http request with the underlying HTTP client which includes an access token in the request
func (c *Client) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        return c.httpClient.Do(req)
}</span>

// Token returns the token, refreshing it if necessary
func (c *Client) Token() (*auth.Token, error) <span class="cov8" title="1">{
        token, err := c.tokenSource.Token()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;auth.Token{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                ExpiresIn:    token.Expiry,
                TokenType:    token.TokenType,
        }, nil</span>
}

// DoRequestFunc is an alias for any function that takes an http request and returns a response and error
type DoRequestFunc func(request *http.Request) (*http.Response, error)

func fetchOpenidConfiguration(issuerURL string, readConfigurationFunc DoRequestFunc) (*openIDConfiguration, error) <span class="cov8" title="1">{
        url := issuerURL + "/.well-known/openid-configuration"
        req, err := http.NewRequest(http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">response, err := readConfigurationFunc(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, errors.New("unexpected status code")
        }</span>

        <span class="cov8" title="1">var configuration *openIDConfiguration
        if err = httputil.UnmarshalResponse(response, &amp;configuration); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return configuration, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package oidc

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/Peripli/service-manager/pkg/log"
        "net/http"

        "github.com/Peripli/service-manager-cli/internal/util"
        "github.com/Peripli/service-manager-cli/pkg/auth"
        "golang.org/x/oauth2"
        "golang.org/x/oauth2/clientcredentials"
)

type openIDConfiguration struct {
        TokenEndpoint         string              `json:"token_endpoint"`
        AuthorizationEndpoint string              `json:"authorization_endpoint"`
        MTLSEndpointAliases   MTLSEndpointAliases `json:"mtls_endpoint_aliases"`
}

type MTLSEndpointAliases struct {
        TokenEndpoint         string `json:"token_endpoint"`
        AuthorizationEndpoint string `json:"authorization_endpoint"`
}

// OpenIDStrategy implementation of OpenID strategy
type OpenIDStrategy struct {
        oauth2Config *oauth2.Config
        ccConfig     *clientcredentials.Config
        httpClient   *http.Client
}

// NewOpenIDStrategy returns OpenId auth strategy
func NewOpenIDStrategy(options *auth.Options) (*OpenIDStrategy, *auth.Options, error) <span class="cov8" title="1">{
        var httpClient *http.Client
        var err error

        httpClient, err = util.BuildHTTPClient(options)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">httpClient.Timeout = options.Timeout

        var oauthConfig *oauth2.Config
        var ccConfig *clientcredentials.Config

        openIDConfig, err := fetchOpenidConfiguration(options.IssuerURL, httpClient.Do)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("error occurred while fetching openid configuration: %s", err)
        }</span>

        <span class="cov8" title="1">options.AuthorizationEndpoint, options.TokenEndpoint = RetrieveAuthEndpoints(openIDConfig, util.MtlsEnabled(options))

        oauthConfig = newOauth2Config(options)

        ccConfig = newClientCredentialsConfig(options)

        return &amp;OpenIDStrategy{
                oauth2Config: oauthConfig,
                ccConfig:     ccConfig,
                httpClient:   httpClient,
        }, options, nil</span>
}

func RetrieveAuthEndpoints(openIDConfig *openIDConfiguration, mtlsEnabled bool) (string, string) <span class="cov8" title="1">{
        var AuthorizationEndpoint string
        var TokenEndpoint string
        if mtlsEnabled </span><span class="cov0" title="0">{
                AuthorizationEndpoint = openIDConfig.MTLSEndpointAliases.AuthorizationEndpoint
                TokenEndpoint = openIDConfig.MTLSEndpointAliases.TokenEndpoint
        }</span> else<span class="cov8" title="1"> {
                AuthorizationEndpoint = openIDConfig.AuthorizationEndpoint
                TokenEndpoint = openIDConfig.TokenEndpoint
        }</span>
        <span class="cov8" title="1">return AuthorizationEndpoint, TokenEndpoint</span>
}

// ClientCredentials is used to perform client credentials grant type flow
func (s *OpenIDStrategy) ClientCredentials() (*auth.Token, error) <span class="cov0" title="0">{
        ctx := context.WithValue(context.Background(), oauth2.HTTPClient, s.httpClient)
        token, err := s.ccConfig.Token(ctx)

        if err != nil </span><span class="cov0" title="0">{
                log.D().Debugf("authenticator: %s", err.Error())
                return nil, wrapError(err)
        }</span>

        <span class="cov0" title="0">resultToken := &amp;auth.Token{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                ExpiresIn:    token.Expiry,
                TokenType:    token.TokenType,
        }

        return resultToken, err</span>
}

// PasswordCredentials is used to perform password grant type flow
func (s *OpenIDStrategy) PasswordCredentials(user, password string) (*auth.Token, error) <span class="cov8" title="1">{
        ctx := context.WithValue(context.Background(), oauth2.HTTPClient, s.httpClient)
        token, err := s.oauth2Config.PasswordCredentialsToken(ctx, user, password)
        if err != nil </span><span class="cov8" title="1">{
                return nil, wrapError(err)
        }</span>

        <span class="cov8" title="1">resultToken := &amp;auth.Token{
                AccessToken:  token.AccessToken,
                RefreshToken: token.RefreshToken,
                ExpiresIn:    token.Expiry,
                TokenType:    token.TokenType,
        }

        return resultToken, err</span>
}

func wrapError(err error) error <span class="cov8" title="1">{
        oauth2Err, ok := err.(*oauth2.RetrieveError)
        log.D().Debugf("oidc error: %s", oauth2Err)
        if ok </span><span class="cov8" title="1">{
                type A struct {
                        Description string `json:"error_description"`
                }
                a := A{}
                unmarshalErr := json.Unmarshal(oauth2Err.Body, &amp;a)
                if unmarshalErr != nil </span><span class="cov8" title="1">{
                        a.Description = string(oauth2Err.Body)
                }</span>

                <span class="cov8" title="1">return fmt.Errorf("auth error: %s", a.Description)</span>
        }
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package errors

import (
        "fmt"
)

// Error wraps command errors
type Error struct {
        Description string
        Cause       error
}

// New is used to create command errors
func New(description string, cause error) *Error <span class="cov0" title="0">{
        return &amp;Error{
                description,
                cause,
        }
}</span>

// Error prints the error description and the reason for the error
func (e *Error) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s\nReason: %s", e.Description, e.Cause.Error())
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package httputil

import (
        "encoding/json"
        "net/http"
        "strings"
)

// UnmarshalResponse reads the response body and tries to parse it.
func UnmarshalResponse(response *http.Response, jsonResult interface{}) error <span class="cov8" title="1">{

        defer func() </span><span class="cov8" title="1">{
                err := response.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }()

        <span class="cov8" title="1">return json.NewDecoder(response.Body).Decode(&amp;jsonResult)</span>
}

// NormalizeURL removes trailing slashesh in url
func NormalizeURL(url string) string <span class="cov8" title="1">{
        for strings.HasSuffix(url, "/") </span><span class="cov0" title="0">{
                url = url[:len(url)-1]
        }</span>
        <span class="cov8" title="1">return url</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package query

import (
        "net/url"
        "strings"

        smquery "github.com/Peripli/service-manager/pkg/query"
)

// Parameters holds common query parameters
type Parameters struct {
        FieldQuery    []string
        LabelQuery    []string
        GeneralParams []string
        Environment   string
}

// Encode encodes the parameters as URL query parameters
func (p *Parameters) Encode() string <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">v := url.Values{}

        if len(p.FieldQuery) &gt; 0 </span><span class="cov8" title="1">{
                v.Set(string(smquery.FieldQuery), strings.Join(p.FieldQuery, " and "))
        }</span>

        <span class="cov8" title="1">if len(p.LabelQuery) &gt; 0 </span><span class="cov8" title="1">{
                v.Set(string(smquery.LabelQuery), strings.Join(p.LabelQuery, " and "))
        }</span>
        <span class="cov8" title="1">if len(p.Environment) &gt; 0 </span><span class="cov0" title="0">{
                v.Set("environment", p.Environment)
        }</span>

        <span class="cov8" title="1">for _, param := range p.GeneralParams </span><span class="cov8" title="1">{
                s := strings.SplitN(param, "=", 2)
                if len(s) &lt; 2 </span><span class="cov8" title="1">{
                        v.Add(param, "")
                }</span> else<span class="cov8" title="1"> {
                        v.Add(s[0], s[1])
                }</span>
        }

        <span class="cov8" title="1">return v.Encode()</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package smclient

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "github.com/Peripli/service-manager/pkg/log"
        "io"
        "net/http"

        "github.com/Peripli/service-manager/pkg/util"

        "github.com/Peripli/service-manager/pkg/web"

        "github.com/Peripli/service-manager-cli/pkg/auth/oidc"

        "github.com/Peripli/service-manager-cli/pkg/auth"
        "github.com/Peripli/service-manager-cli/pkg/httputil"
        "github.com/Peripli/service-manager-cli/pkg/query"
        "github.com/Peripli/service-manager-cli/pkg/types"
)

// Client should be implemented by SM clients
//go:generate counterfeiter . Client
type Client interface {
        GetInfo(*query.Parameters) (*types.Info, error)

        RegisterPlatform(*types.Platform, *query.Parameters) (*types.Platform, error)
        ListPlatforms(*query.Parameters) (*types.Platforms, error)
        UpdatePlatform(string, *types.Platform, *query.Parameters) (*types.Platform, error)
        DeletePlatforms(*query.Parameters) error
        DeletePlatform(id string, q *query.Parameters) (string, error)

        RegisterBroker(*types.Broker, *query.Parameters) (*types.Broker, string, error)
        GetBrokerByID(string, *query.Parameters) (*types.Broker, error)
        ListBrokers(*query.Parameters) (*types.Brokers, error)
        UpdateBroker(string, *types.Broker, *query.Parameters) (*types.Broker, string, error)
        DeleteBroker(string, *query.Parameters) (string, error)

        RegisterVisibility(*types.Visibility, *query.Parameters) (*types.Visibility, error)
        ListVisibilities(*query.Parameters) (*types.Visibilities, error)
        UpdateVisibility(string, *types.Visibility, *query.Parameters) (*types.Visibility, error)
        DeleteVisibilities(*query.Parameters) error

        ListOfferings(*query.Parameters) (*types.ServiceOfferings, error)
        ListPlans(*query.Parameters) (*types.ServicePlans, error)
        GetPlanByID(string, *query.Parameters) (*types.ServicePlan, error)
        ListInstances(*query.Parameters) (*types.ServiceInstances, error)
        GetInstanceByID(string, *query.Parameters) (*types.ServiceInstance, error)
        GetInstanceParameters(string, *query.Parameters) (map[string]interface{}, error)
        UpdateInstance(string, *types.ServiceInstance, *query.Parameters) (*types.ServiceInstance, string, error)
        Provision(*types.ServiceInstance, *query.Parameters) (*types.ServiceInstance, string, error)
        Deprovision(string, *query.Parameters) (string, error)

        ListBindings(*query.Parameters) (*types.ServiceBindings, error)
        GetBindingByID(string, *query.Parameters) (*types.ServiceBinding, error)
        GetBindingParameters(string, *query.Parameters) (map[string]interface{}, error)
        Bind(*types.ServiceBinding, *query.Parameters) (*types.ServiceBinding, string, error)
        Unbind(string, *query.Parameters) (string, error)

        Label(string, string, *types.LabelChanges, *query.Parameters) error

        Status(string, *query.Parameters) (*types.Operation, error)

        Marketplace(*query.Parameters) (*types.Marketplace, error)

        // Call makes HTTP request to the Service Manager server with authentication.
        // It should be used only in case there is no already implemented method for such an operation
        Call(method string, smpath string, body io.Reader, q *query.Parameters) (*http.Response, error)
}

type serviceManagerClient struct {
        ctx        context.Context
        config     *ClientConfig
        httpClient auth.Client
}

// NewClientWithAuth returns new SM Client configured with the provided configuration
func NewClientWithAuth(httpClient auth.Client, config *ClientConfig) (Client, error) <span class="cov0" title="0">{
        if httpClient == nil </span><span class="cov0" title="0">{
                httpClient = http.DefaultClient
        }</span>
        <span class="cov0" title="0">client := &amp;serviceManagerClient{ctx: context.Background(), config: config, httpClient: httpClient}
        info, err := client.GetInfo(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">authOptions := &amp;auth.Options{
                IssuerURL:    info.TokenIssuerURL,
                ClientID:     config.ClientID,
                ClientSecret: config.ClientSecret,
                SSLDisabled:  config.SSLDisabled,
        }
        var authStrategy auth.Authenticator
        authStrategy, authOptions, err = oidc.NewOpenIDStrategy(authOptions)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">token, err := auth.GetToken(authOptions, authStrategy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">authClient, err := oidc.NewClient(authOptions, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client = &amp;serviceManagerClient{ctx: context.Background(), config: config, httpClient: authClient}

        return client, nil</span>
}

// NewClient returns new SM client which will use the http client provided to make calls
func NewClient(ctx context.Context, httpClient auth.Client, URL string) Client <span class="cov8" title="1">{
        return &amp;serviceManagerClient{ctx: ctx, config: &amp;ClientConfig{URL: URL}, httpClient: httpClient}
}</span>

func (client *serviceManagerClient) GetInfo(q *query.Parameters) (*types.Info, error) <span class="cov8" title="1">{
        response, err := client.Call(http.MethodGet, web.InfoURL, nil, q)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, util.HandleResponseError(response)
        }</span>

        <span class="cov8" title="1">info := types.DefaultInfo
        err = httputil.UnmarshalResponse(response, &amp;info)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;info, nil</span>
}

// RegisterPlatform registers a platform in the service manager
func (client *serviceManagerClient) RegisterPlatform(platform *types.Platform, q *query.Parameters) (*types.Platform, error) <span class="cov8" title="1">{
        var newPlatform *types.Platform
        _, err := client.register(platform, web.PlatformsURL, q, &amp;newPlatform)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return newPlatform, nil</span>
}

// RegisterBroker registers a broker in the service manager
func (client *serviceManagerClient) RegisterBroker(broker *types.Broker, q *query.Parameters) (*types.Broker, string, error) <span class="cov8" title="1">{
        var newBroker *types.Broker
        location, err := client.register(broker, web.ServiceBrokersURL, q, &amp;newBroker)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>
        <span class="cov8" title="1">return newBroker, location, nil</span>
}

// RegisterVisibility registers a visibility in the service manager
func (client *serviceManagerClient) RegisterVisibility(visibility *types.Visibility, q *query.Parameters) (*types.Visibility, error) <span class="cov8" title="1">{
        var newVisibility *types.Visibility
        _, err := client.register(visibility, web.VisibilitiesURL, q, &amp;newVisibility)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return newVisibility, nil</span>
}

// Provision provisions a new service instance in service manager
func (client *serviceManagerClient) Provision(instance *types.ServiceInstance, q *query.Parameters) (*types.ServiceInstance, string, error) <span class="cov8" title="1">{
        var newInstance *types.ServiceInstance
        location, err := client.register(instance, web.ServiceInstancesURL, q, &amp;newInstance)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>
        <span class="cov8" title="1">return newInstance, location, nil</span>
}

// Bind creates binding to an instance in service manager
func (client *serviceManagerClient) Bind(binding *types.ServiceBinding, q *query.Parameters) (*types.ServiceBinding, string, error) <span class="cov8" title="1">{
        var newBinding *types.ServiceBinding
        location, err := client.register(binding, web.ServiceBindingsURL, q, &amp;newBinding)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>
        <span class="cov8" title="1">return newBinding, location, nil</span>
}

func (client *serviceManagerClient) register(resource interface{}, url string, q *query.Parameters, result interface{}) (string, error) <span class="cov8" title="1">{
        requestBody, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">buffer := bytes.NewBuffer(requestBody)
        response, err := client.Call(http.MethodPost, url, buffer, q)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">switch response.StatusCode </span>{
        case http.StatusCreated:<span class="cov8" title="1">
                return "", httputil.UnmarshalResponse(response, &amp;result)</span>
        case http.StatusAccepted:<span class="cov8" title="1">
                return response.Header.Get("Location"), nil</span>
        default:<span class="cov8" title="1">
                return "", util.HandleResponseError(response)</span>
        }
}

// GetBrokerByID returns broker registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) GetBrokerByID(id string, q *query.Parameters) (*types.Broker, error) <span class="cov8" title="1">{
        broker := &amp;types.Broker{}
        err := client.get(broker, web.ServiceBrokersURL+"/"+id, &amp;query.Parameters{
                GeneralParams: q.GeneralParams,
        })

        return broker, err
}</span>

// ListBrokers returns brokers registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) ListBrokers(q *query.Parameters) (*types.Brokers, error) <span class="cov8" title="1">{
        brokers := &amp;types.Brokers{}
        err := client.list(&amp;brokers.Brokers, web.ServiceBrokersURL, q)

        return brokers, err
}</span>

// ListPlatforms returns platforms registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) ListPlatforms(q *query.Parameters) (*types.Platforms, error) <span class="cov8" title="1">{
        platforms := &amp;types.Platforms{}
        err := client.list(&amp;platforms.Platforms, web.PlatformsURL, q)

        return platforms, err
}</span>

// ListOfferings returns offerings registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) ListOfferings(q *query.Parameters) (*types.ServiceOfferings, error) <span class="cov0" title="0">{
        offerings := &amp;types.ServiceOfferings{}
        err := client.list(&amp;offerings.ServiceOfferings, web.ServiceOfferingsURL, q)

        return offerings, err
}</span>

// ListPlans returns plans registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) ListPlans(q *query.Parameters) (*types.ServicePlans, error) <span class="cov0" title="0">{
        plans := &amp;types.ServicePlans{}
        err := client.list(&amp;plans.ServicePlans, web.ServicePlansURL, q)
        return plans, err
}</span>

// ListVisibilities returns visibilities registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) ListVisibilities(q *query.Parameters) (*types.Visibilities, error) <span class="cov8" title="1">{
        visibilities := &amp;types.Visibilities{}
        err := client.list(&amp;visibilities.Visibilities, web.VisibilitiesURL, q)

        return visibilities, err
}</span>

// ListInstances returns service instances registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) ListInstances(q *query.Parameters) (*types.ServiceInstances, error) <span class="cov8" title="1">{
        instances := &amp;types.ServiceInstances{}
        err := client.list(&amp;instances.ServiceInstances, web.ServiceInstancesURL, q)

        return instances, err
}</span>

// GetInstanceParameters returns service instance configuration parameters
func (client *serviceManagerClient) GetInstanceParameters(id string, q *query.Parameters) (map[string]interface{}, error) <span class="cov8" title="1">{
        parameters := make(map[string]interface{})
        err := client.get(&amp;parameters, web.ServiceInstancesURL+"/"+id+web.ParametersURL, q)

        return parameters, err
}</span>

// GetPlanByID returns pla by id
func (client *serviceManagerClient) GetPlanByID(id string, q *query.Parameters) (*types.ServicePlan, error) <span class="cov0" title="0">{
        plan := &amp;types.ServicePlan{}
        err := client.get(plan, web.ServicePlansURL+"/"+id, &amp;query.Parameters{
                GeneralParams: q.GeneralParams,
        })

        return plan, err
}</span>

// GetInstanceByID returns instance registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) GetInstanceByID(id string, q *query.Parameters) (*types.ServiceInstance, error) <span class="cov8" title="1">{
        instance := &amp;types.ServiceInstance{}
        err := client.get(instance, web.ServiceInstancesURL+"/"+id, &amp;query.Parameters{
                GeneralParams: q.GeneralParams,
        })

        return instance, err
}</span>

// ListBindings returns service bindings registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) ListBindings(q *query.Parameters) (*types.ServiceBindings, error) <span class="cov8" title="1">{
        bindings := &amp;types.ServiceBindings{}
        err := client.list(&amp;bindings.ServiceBindings, web.ServiceBindingsURL, q)

        return bindings, err
}</span>

// GetBindingParameters returns service binding configuration parameters
func (client *serviceManagerClient) GetBindingParameters(id string, q *query.Parameters) (map[string]interface{}, error) <span class="cov8" title="1">{
        parameters := make(map[string]interface{})
        err := client.get(&amp;parameters, web.ServiceBindingsURL+"/"+id+web.ParametersURL, q)

        return parameters, err
}</span>

// GetBindingByID returns binding registered in the Service Manager satisfying provided queries
func (client *serviceManagerClient) GetBindingByID(id string, q *query.Parameters) (*types.ServiceBinding, error) <span class="cov8" title="1">{
        binding := &amp;types.ServiceBinding{}
        err := client.get(binding, web.ServiceBindingsURL+"/"+id, &amp;query.Parameters{
                GeneralParams: q.GeneralParams,
        })

        return binding, err
}</span>

// Marketplace returns service offerings satisfying provided queries
func (client *serviceManagerClient) Marketplace(q *query.Parameters) (*types.Marketplace, error) <span class="cov8" title="1">{
        marketplace := &amp;types.Marketplace{}
        err := client.list(&amp;marketplace.ServiceOfferings, web.ServiceOfferingsURL, q)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for i, so := range marketplace.ServiceOfferings </span><span class="cov8" title="1">{
                plans := &amp;types.ServicePlansForOffering{}
                err := client.list(&amp;plans.ServicePlans, web.ServicePlansURL, &amp;query.Parameters{
                        Environment:   q.Environment,
                        FieldQuery:    []string{fmt.Sprintf("service_offering_id eq '%s'", so.ID)},
                        GeneralParams: q.GeneralParams,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">marketplace.ServiceOfferings[i].Plans = plans.ServicePlans</span>
        }
        <span class="cov8" title="1">return marketplace, nil</span>
}

func (client *serviceManagerClient) Status(url string, q *query.Parameters) (*types.Operation, error) <span class="cov8" title="1">{
        operation := &amp;types.Operation{}
        err := client.get(operation, url, &amp;query.Parameters{
                GeneralParams: q.GeneralParams,
        })

        return operation, err
}</span>

func (client *serviceManagerClient) list(result interface{}, url string, q *query.Parameters) error <span class="cov8" title="1">{
        fullURL := httputil.NormalizeURL(client.config.URL) + BuildURL(url, q)
        return util.ListAll(client.ctx, client.httpClient.Do, fullURL, result)
}</span>

func (client *serviceManagerClient) get(result interface{}, url string, q *query.Parameters) error <span class="cov8" title="1">{
        resp, err := client.Call(http.MethodGet, url, nil, q)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return util.HandleResponseError(resp)
        }</span>

        <span class="cov8" title="1">return httputil.UnmarshalResponse(resp, &amp;result)</span>
}

func (client *serviceManagerClient) DeleteBroker(id string, q *query.Parameters) (string, error) <span class="cov8" title="1">{
        return client.delete(web.ServiceBrokersURL+"/"+id, q)
}</span>

func (client *serviceManagerClient) DeletePlatforms(q *query.Parameters) error <span class="cov8" title="1">{
        _, err := client.delete(web.PlatformsURL, q)
        return err
}</span>

func (client *serviceManagerClient) DeletePlatform(id string, q *query.Parameters) (string, error) <span class="cov8" title="1">{
        location, err := client.delete(web.PlatformsURL+"/"+id, q)
        return location, err
}</span>

func (client *serviceManagerClient) DeleteVisibilities(q *query.Parameters) error <span class="cov8" title="1">{
        _, err := client.delete(web.VisibilitiesURL, q)
        return err
}</span>

func (client *serviceManagerClient) Deprovision(id string, q *query.Parameters) (string, error) <span class="cov8" title="1">{
        return client.delete(web.ServiceInstancesURL+"/"+id, q)
}</span>

func (client *serviceManagerClient) Unbind(id string, q *query.Parameters) (string, error) <span class="cov8" title="1">{
        return client.delete(web.ServiceBindingsURL+"/"+id, q)
}</span>

func (client *serviceManagerClient) delete(url string, q *query.Parameters) (string, error) <span class="cov8" title="1">{
        resp, err := client.Call(http.MethodDelete, url, nil, q)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">switch resp.StatusCode </span>{
        case http.StatusOK:<span class="cov8" title="1">
                return "", nil</span>
        case http.StatusAccepted:<span class="cov8" title="1">
                return resp.Header.Get("Location"), nil</span>
        default:<span class="cov8" title="1">
                return "", util.HandleResponseError(resp)</span>
        }
}

func (client *serviceManagerClient) UpdateBroker(id string, updatedBroker *types.Broker, q *query.Parameters) (*types.Broker, string, error) <span class="cov8" title="1">{
        var result *types.Broker
        location, err := client.update(updatedBroker, web.ServiceBrokersURL, id, q, &amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>
        <span class="cov8" title="1">return result, location, nil</span>
}

func (client *serviceManagerClient) UpdateInstance(id string, updatedInstance *types.ServiceInstance, q *query.Parameters) (*types.ServiceInstance, string, error) <span class="cov8" title="1">{
        var result *types.ServiceInstance
        location, err := client.update(updatedInstance, web.ServiceInstancesURL, id, q, &amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>
        <span class="cov8" title="1">return result, location, nil</span>
}

func (client *serviceManagerClient) UpdatePlatform(id string, updatedPlatform *types.Platform, q *query.Parameters) (*types.Platform, error) <span class="cov8" title="1">{
        result := &amp;types.Platform{}
        _, err := client.update(updatedPlatform, web.PlatformsURL, id, q, &amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func (client *serviceManagerClient) UpdateVisibility(id string, updatedVisibility *types.Visibility, q *query.Parameters) (*types.Visibility, error) <span class="cov8" title="1">{
        result := &amp;types.Visibility{}
        _, err := client.update(updatedVisibility, web.VisibilitiesURL, id, q, &amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func (client *serviceManagerClient) update(resource interface{}, url string, id string, q *query.Parameters, result interface{}) (string, error) <span class="cov8" title="1">{
        requestBody, err := json.Marshal(resource)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">buffer := bytes.NewBuffer(requestBody)
        resp, err := client.Call(http.MethodPatch, url+"/"+id, buffer, q)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">switch resp.StatusCode </span>{
        case http.StatusOK:<span class="cov8" title="1">
                return "", httputil.UnmarshalResponse(resp, &amp;result)</span>
        case http.StatusAccepted:<span class="cov8" title="1">
                return resp.Header.Get("Location"), nil</span>
        default:<span class="cov8" title="1">
                return "", util.HandleResponseError(resp)</span>
        }
}

func (client *serviceManagerClient) Label(url string, id string, change *types.LabelChanges, q *query.Parameters) error <span class="cov8" title="1">{
        requestBody, err := json.Marshal(change)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">buffer := bytes.NewBuffer(requestBody)
        response, err := client.Call(http.MethodPatch, url+"/"+id, buffer, q)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return util.HandleResponseError(response)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (client *serviceManagerClient) Call(method string, smpath string, body io.Reader, q *query.Parameters) (*http.Response, error) <span class="cov8" title="1">{
        fullURL := httputil.NormalizeURL(client.config.URL) + BuildURL(smpath, q)

        req, err := http.NewRequest(method, fullURL, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Add("Content-Type", "application/json")

        log.C(client.ctx).Debugf("Sending request %s %s", req.Method, req.URL)
        resp, err := client.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode &lt; 200 || resp.StatusCode &gt; 299 </span><span class="cov8" title="1">{
                return nil, util.HandleResponseError(resp)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

// BuildURL builds the url with provided query parameters
func BuildURL(baseURL string, q *query.Parameters) string <span class="cov8" title="1">{
        queryParams := q.Encode()
        if queryParams == "" </span><span class="cov0" title="0">{
                return baseURL
        }</span>
        <span class="cov8" title="1">return baseURL + "?" + queryParams</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "fmt"
        "github.com/Peripli/service-manager/pkg/types"
        "strconv"
)

// Broker defines the data of a service broker.
type Broker struct {
        ID          string       `json:"id,omitempty" yaml:"id,omitempty"`
        Name        string       `json:"name,omitempty" yaml:"name,omitempty"`
        URL         string       `json:"broker_url,omitempty" yaml:"broker_url,omitempty"`
        Description string       `json:"description,omitempty" yaml:"description,omitempty"`
        Created     string       `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        Updated     string       `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
        Credentials *Credentials `json:"credentials,omitempty" yaml:"credentials,omitempty"`
        Labels      types.Labels `json:"labels,omitempty" yaml:"labels,omitempty"`
        Ready       bool         `json:"ready,omitempty" yaml:"ready,omitempty"`

        LastOperation *types.Operation `json:"last_operation,omitempty" yaml:"last_operation,omitempty"`
}

// Message title of the table
func (b *Broker) Message() string <span class="cov8" title="1">{
        return ""
}</span>

// IsEmpty whether the structure is empty
func (b *Broker) IsEmpty() bool <span class="cov8" title="1">{
        return false
}</span>

// TableData returns the data to populate a table
func (b *Broker) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{Vertical: true}
        result.Headers = []string{"ID", "Name", "URL", "Description", "Created", "Updated", "Labels", "Last Op"}

        lastState := "-"
        if b.LastOperation != nil </span><span class="cov0" title="0">{
                lastState = formatLastOp(b.LastOperation)
        }</span>
        <span class="cov8" title="1">row := []string{b.ID, b.Name, b.URL, b.Description, b.Created, b.Updated, formatLabels(b.Labels), lastState}
        result.Data = append(result.Data, row)

        return result</span>
}

// Brokers wraps an array of brokers
type Brokers struct {
        Brokers []Broker `json:"items"`
}

// IsEmpty whether the structure is empty
func (b *Brokers) IsEmpty() bool <span class="cov8" title="1">{
        return len(b.Brokers) == 0
}</span>

// Message title of the table
func (b *Brokers) Message() string <span class="cov8" title="1">{
        var msg string

        if len(b.Brokers) == 0 </span><span class="cov8" title="1">{
                msg = "No brokers registered."
        }</span> else<span class="cov8" title="1"> if len(b.Brokers) == 1 </span><span class="cov8" title="1">{
                msg = "One broker registered."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d brokers registered.", len(b.Brokers))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// TableData returns the data to populate a table
func (b *Brokers) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"ID", "Name", "URL", "Description", "Created", "Updated", "Ready", "Labels"}

        for _, broker := range b.Brokers </span><span class="cov8" title="1">{
                row := []string{broker.ID, broker.Name, broker.URL, broker.Description, broker.Created, broker.Updated, strconv.FormatBool(broker.Ready), formatLabels(broker.Labels)}
                result.Data = append(result.Data, row)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "encoding/json"
        "github.com/Peripli/service-manager/pkg/types"
)

// Operation defines the data of a operation.
type Operation struct {
        ID           string          `json:"id,omitempty" yaml:"id,omitempty"`
        Description  string          `json:"description,omitempty" yaml:"description,omitempty"`
        Type         string          `json:"type,omitempty" yaml:"type,omitempty"`
        State        string          `json:"state,omitempty" yaml:"state,omitempty"`
        ResourceID   string          `json:"resource_id,omitempty" yaml:"resource_id,omitempty"`
        ResourceType string          `json:"resource_type,omitempty" yaml:"resource_type,omitempty"`
        Errors       json.RawMessage `json:"errors,omitempty" yaml:"errors,omitempty"`
        Created      string          `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        Updated      string          `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
        Labels       types.Labels    `json:"labels,omitempty" yaml:"labels,omitempty"`
}

// Message title of the table
func (o *Operation) Message() string <span class="cov8" title="1">{
        return ""
}</span>

// IsEmpty whether the structure is empty
func (o *Operation) IsEmpty() bool <span class="cov8" title="1">{
        return false
}</span>

// TableData returns the data to populate a table
func (o *Operation) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{Vertical: true}
        var row []string
        if o.State == string(types.FAILED) </span><span class="cov8" title="1">{
                result.Headers = []string{"ID", "Type", "State", "Error"}
                row = []string{o.ID, o.Type, o.State, string(o.Errors)}
        }</span> else<span class="cov0" title="0"> {
                result.Headers = []string{"ID", "Type", "State"}
                row = []string{o.ID, o.Type, o.State}
        }</span>
        <span class="cov8" title="1">result.Data = append(result.Data, row)
        return result</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "fmt"
        "github.com/Peripli/service-manager/pkg/types"
        "strconv"
)

// Platform defines the data of a platform.
type Platform struct {
        ID          string       `json:"id,omitempty" yaml:"id,omitempty"`
        Name        string       `json:"name,omitempty" yaml:"name,omitempty"`
        Description string       `json:"description,omitempty" yaml:"description,omitempty"`
        Type        string       `json:"type,omitempty" yaml:"type,omitempty"`
        Created     string       `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        Updated     string       `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
        Credentials *Credentials `json:"credentials,omitempty" yaml:"credentials,omitempty"`
        Labels      types.Labels `json:"labels,omitempty" yaml:"labels,omitempty"`
        Ready       bool         `json:"ready,omitempty" yaml:"ready,omitempty"`
}

// Message title of the table
func (p *Platform) Message() string <span class="cov8" title="1">{
        return ""
}</span>

// IsEmpty whether the structure is empty
func (p *Platform) IsEmpty() bool <span class="cov8" title="1">{
        return false
}</span>

// TableData returns the data to populate a table
func (p *Platform) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}

        result.Headers = []string{"ID", "Name", "Type", "Description", "Created", "Updated", "Labels"}
        row := []string{p.ID, p.Name, p.Type, p.Description, p.Created, p.Updated, formatLabels(p.Labels)}

        if p.Credentials != nil </span><span class="cov8" title="1">{
                result.Headers = append(result.Headers, "Username", "Password")
                row = append(row, p.Credentials.Basic.User, p.Credentials.Basic.Password)
        }</span>

        <span class="cov8" title="1">result.Data = append(result.Data, row)

        return result</span>
}

// Platforms wraps an array of platforms
type Platforms struct {
        Platforms []Platform `json:"items"`
}

// IsEmpty whether the structure is empty
func (p *Platforms) IsEmpty() bool <span class="cov8" title="1">{
        return len(p.Platforms) == 0
}</span>

// Message title of the table
func (p *Platforms) Message() string <span class="cov8" title="1">{
        var msg string

        if len(p.Platforms) == 0 </span><span class="cov8" title="1">{
                msg = "No platforms registered."
        }</span> else<span class="cov8" title="1"> if len(p.Platforms) == 1 </span><span class="cov8" title="1">{
                msg = "One platform registered."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d platforms registered.", len(p.Platforms))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// TableData returns the data to populate a table
func (p *Platforms) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"ID", "Name", "Type", "Description", "Created", "Updated", "Ready", "Labels"}

        for _, platform := range p.Platforms </span><span class="cov8" title="1">{
                row := []string{platform.ID, platform.Name, platform.Type, platform.Description, platform.Created, platform.Updated, strconv.FormatBool(platform.Ready), formatLabels(platform.Labels)}
                result.Data = append(result.Data, row)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "encoding/json"
        "fmt"
        "strconv"

        "github.com/Peripli/service-manager/pkg/types"
)

// ServiceBinding defines the data of a service instance.
type ServiceBinding struct {
        ID             string       `json:"id,omitempty" yaml:"id,omitempty"`
        Name           string       `json:"name,omitempty" yaml:"name,omitempty"`
        CreatedAt      string       `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        UpdatedAt      string       `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
        Labels         types.Labels `json:"labels,omitempty" yaml:"labels,omitempty"`
        PagingSequence int64        `json:"-" yaml:"-"`

        Credentials json.RawMessage `json:"credentials,omitempty" yaml:"credentials,omitempty"`

        ServiceInstanceID   string `json:"service_instance_id" yaml:"service_instance_id,omitempty"`
        ServiceInstanceName string `json:"service_instance_name,omitempty" yaml:"service_instance_name,omitempty"`

        SyslogDrainURL  string          `json:"syslog_drain_url,omitempty" yaml:"syslog_drain_url,omitempty"`
        RouteServiceURL string          `json:"route_service_url,omitempty"`
        VolumeMounts    json.RawMessage `json:"-" yaml:"-"`
        Endpoints       json.RawMessage `json:"-" yaml:"-"`
        Context         json.RawMessage `json:"context,omitempty" yaml:"context,omitempty"`
        Parameters      json.RawMessage `json:"parameters,omitempty" yaml:"parameters,omitempty"`
        BindResource    json.RawMessage `json:"-" yaml:"-"`

        Ready bool `json:"ready,omitempty" yaml:"ready,omitempty"`

        LastOperation *types.Operation `json:"last_operation,omitempty" yaml:"last_operation,omitempty"`
}

// Message title of the table
func (sb *ServiceBinding) Message() string <span class="cov8" title="1">{
        return ""
}</span>

// IsEmpty whether the structure is empty
func (sb *ServiceBinding) IsEmpty() bool <span class="cov8" title="1">{
        return false
}</span>

// TableData returns the data to populate a table
func (sb *ServiceBinding) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{Vertical: true}
        result.Headers = []string{"ID", "Name", "Service Instance Name", "Service Instance ID", "Credentials", "Created", "Updated", "Ready", "Labels", "Last Op"}

        lastState := "-"
        if sb.LastOperation != nil </span><span class="cov0" title="0">{
                lastState = formatLastOp(sb.LastOperation)
        }</span>
        <span class="cov8" title="1">row := []string{sb.ID, sb.Name, sb.ServiceInstanceName, sb.ServiceInstanceID, string(sb.Credentials), sb.CreatedAt, sb.UpdatedAt, strconv.FormatBool(sb.Ready), formatLabels(sb.Labels), lastState}
        result.Data = append(result.Data, row)

        return result</span>
}

// ServiceBindings wraps an array of service bindings
type ServiceBindings struct {
        ServiceBindings []ServiceBinding `json:"items" yaml:"items"`
        Vertical        bool             `json:"-" yaml:"-"`
}

// Message title of the table
func (sb *ServiceBindings) Message() string <span class="cov8" title="1">{
        var msg string

        if len(sb.ServiceBindings) == 0 </span><span class="cov8" title="1">{
                msg = "There are no service bindings."
        }</span> else<span class="cov8" title="1"> if len(sb.ServiceBindings) == 1 </span><span class="cov8" title="1">{
                msg = "One service binding."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d service bindings.", len(sb.ServiceBindings))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// IsEmpty whether the structure is empty
func (sb *ServiceBindings) IsEmpty() bool <span class="cov8" title="1">{
        return len(sb.ServiceBindings) == 0
}</span>

// TableData returns the data to populate a table
func (sb *ServiceBindings) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{Vertical: sb.Vertical}
        result.Headers = []string{"ID", "Name", "Instance Name", "Credentials", "Created", "Updated", "Ready", "Labels"}

        addLastOpColumn := false
        for _, binding := range sb.ServiceBindings </span><span class="cov8" title="1">{
                lastState := "-"
                if binding.LastOperation != nil </span><span class="cov0" title="0">{
                        lastState = formatLastOp(binding.LastOperation)
                        addLastOpColumn = true
                }</span>
                <span class="cov8" title="1">row := []string{binding.ID, binding.Name, binding.ServiceInstanceName, string(binding.Credentials), binding.CreatedAt, binding.UpdatedAt, strconv.FormatBool(binding.Ready), formatLabels(binding.Labels), lastState}
                result.Data = append(result.Data, row)</span>
        }

        <span class="cov8" title="1">if addLastOpColumn </span><span class="cov0" title="0">{
                result.Headers = append(result.Headers, "Last Op")
        }</span> else<span class="cov8" title="1"> {
                for i := range result.Data </span><span class="cov8" title="1">{
                        result.Data[i] = result.Data[i][:len(result.Data[i])-1]
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "encoding/json"
        "fmt"
        "github.com/Peripli/service-manager/pkg/types"
)

// ServiceInstance defines the data of a service instance.
type ServiceInstance struct {
        ID        string `json:"id,omitempty" yaml:"id,omitempty"`
        Name      string `json:"name,omitempty" yaml:"name,omitempty"`
        CreatedAt string `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        UpdatedAt string `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`

        Labels types.Labels `json:"labels,omitempty" yaml:"labels,omitempty"`

        ServiceID     string `json:"service_id,omitempty" yaml:"service_id,omitempty"`
        ServicePlanID string `json:"service_plan_id,omitempty" yaml:"service_plan_id,omitempty"`
        PlatformID    string `json:"platform_id,omitempty" yaml:"platform_id,omitempty"`

        Parameters      json.RawMessage `json:"parameters,omitempty" yaml:"parameters,omitempty"`
        MaintenanceInfo json.RawMessage `json:"maintenance_info,omitempty" yaml:"-"`
        Context         json.RawMessage `json:"context,omitempty" yaml:"context,omitempty"`
        PreviousValues  json.RawMessage `json:"-" yaml:"-"`

        Ready         *bool             `json:"ready,omitempty" yaml:"ready,omitempty"`
        Usable        *bool             `json:"usable,omitempty" yaml:"usable,omitempty"`
        Shared        *bool             `json:"shared,omitempty" yaml:"shared,omitempty"`
        LastOperation *types.Operation `json:"last_operation,omitempty" yaml:"last_operation,omitempty"`
}

// Message title of the table
func (si *ServiceInstance) Message() string <span class="cov8" title="1">{
        return ""
}</span>

// IsEmpty whether the structure is empty
func (si *ServiceInstance) IsEmpty() bool <span class="cov8" title="1">{
        return false
}</span>

// TableData returns the data to populate a table
func (si *ServiceInstance) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{Vertical: true}
        result.Headers = []string{"ID", "Name", "Service Plan ID", "Platform ID", "Shared", "Created", "Updated", "Ready", "Usable", "Labels", "Last Op"}

        lastState := "-"
        if si.LastOperation != nil </span><span class="cov0" title="0">{
                lastState = formatLastOp(si.LastOperation)
        }</span>
        <span class="cov8" title="1">row := []string{si.ID, si.Name, si.ServicePlanID, si.PlatformID, formatNullableBool(si.Shared), si.CreatedAt, si.UpdatedAt, formatNullableBool(si.Ready), formatNullableBool(si.Usable), formatLabels(si.Labels), lastState}
        result.Data = append(result.Data, row)

        return result</span>
}

// ServiceInstances wraps an array of service instances
type ServiceInstances struct {
        ServiceInstances []ServiceInstance `json:"items" yaml:"items"`
        Vertical         bool              `json:"-" yaml:"-"`
}

// Message title of the table
func (si *ServiceInstances) Message() string <span class="cov8" title="1">{
        var msg string

        if len(si.ServiceInstances) == 0 </span><span class="cov8" title="1">{
                msg = "There are no service instances."
        }</span> else<span class="cov8" title="1"> if len(si.ServiceInstances) == 1 </span><span class="cov8" title="1">{
                msg = "One service instance."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d service instances.", len(si.ServiceInstances))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// IsEmpty whether the structure is empty
func (si *ServiceInstances) IsEmpty() bool <span class="cov8" title="1">{
        return len(si.ServiceInstances) == 0
}</span>

// TableData returns the data to populate a table
func (si *ServiceInstances) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{Vertical: si.Vertical}
        result.Headers = []string{"ID", "Name", "Service Plan ID", "Platform ID", "Shared", "Created", "Updated", "Ready", "Usable", "Labels"}

        addLastOpColumn := false
        for _, instance := range si.ServiceInstances </span><span class="cov8" title="1">{
                lastState := "-"
                if instance.LastOperation != nil </span><span class="cov0" title="0">{
                        lastState = formatLastOp(instance.LastOperation)
                        addLastOpColumn = true
                }</span>
                <span class="cov8" title="1">row := []string{instance.ID, instance.Name, instance.ServicePlanID, instance.PlatformID, formatNullableBool(instance.Shared), instance.CreatedAt, instance.UpdatedAt, formatNullableBool(instance.Ready), formatNullableBool(instance.Usable), formatLabels(instance.Labels), lastState}
                result.Data = append(result.Data, row)</span>
        }

        <span class="cov8" title="1">if addLastOpColumn </span><span class="cov0" title="0">{
                result.Headers = append(result.Headers, "Last Op")
        }</span> else<span class="cov8" title="1"> {
                for i := range result.Data </span><span class="cov8" title="1">{
                        result.Data[i] = result.Data[i][:len(result.Data[i])-1]
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"

        "github.com/Peripli/service-manager/pkg/types"
)

// ServiceOffering defines the data of a service offering.
type ServiceOffering struct {
        ID          string `json:"id,omitempty" yaml:"id,omitempty"`
        Name        string `json:"name,omitempty" yaml:"name,omitempty"`
        Description string `json:"description,omitempty" yaml:"description,omitempty"`
        CreatedAt   string `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        UpdatedAt   string `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`

        Bindable             bool   `json:"bindable,omitempty" yaml:"bindable,omitempty"`
        InstancesRetrievable bool   `json:"instances_retrievable,omitempty" yaml:"instances_retrievable,omitempty"`
        BindingsRetrievable  bool   `json:"bindings_retrievable,omitempty" yaml:"bindings_retrievable,omitempty"`
        AllowContextUpdates  bool   `json:"allow_context_updates,omitempty" yaml:"allow_context_updates,omitempty"`
        PlanUpdatable        bool   `json:"plan_updateable,omitempty" yaml:"plan_updateable,omitempty"`
        CatalogID            string `json:"catalog_id,omitempty" yaml:"catalog_id,omitempty"`
        CatalogName          string `json:"catalog_name,omitempty" yaml:"catalog_name,omitempty"`

        Tags     json.RawMessage `json:"tags,omitempty" yaml:"-"`
        Requires json.RawMessage `json:"requires,omitempty" yaml:"-"`
        Metadata json.RawMessage `json:"metadata,omitempty" yaml:"-"`

        BrokerID   string        `json:"broker_id,omitempty" yaml:"broker_id,omitempty"`
        BrokerName string        `json:"broker_name,omitempty" yaml:"broker_name,omitempty"`
        Plans      []ServicePlan `json:"plans,omitempty" yaml:"plans,omitempty"`
        Labels     types.Labels  `json:"labels,omitempty" yaml:"labels,omitempty"`
        Ready      bool          `json:"ready,omitempty" yaml:"ready,omitempty"`
}

// Message title of the table
func (so *ServiceOffering) Message() string <span class="cov0" title="0">{
        return ""
}</span>

// IsEmpty whether the structure is empty
func (so *ServiceOffering) IsEmpty() bool <span class="cov0" title="0">{
        return false
}</span>

// TableData returns the data to populate a table
func (so *ServiceOffering) TableData() *TableData <span class="cov0" title="0">{
        result := &amp;TableData{}
        result.Headers = []string{"Name", "Plans", "Description", "Broker ID"}

        plans := make([]string, len(so.Plans))
        for i, v := range so.Plans </span><span class="cov0" title="0">{
                plans[i] = v.Name
        }</span>

        <span class="cov0" title="0">row := []string{so.Name, strings.Join(plans, ", "), so.Description, so.BrokerID}
        result.Data = append(result.Data, row)

        return result</span>
}

// Marketplace wraps an array of service offerings with marketplace related table data
type Marketplace struct {
        ServiceOfferings []ServiceOffering `json:"items" yaml:"items"`
}

// Message title of the table
func (m *Marketplace) Message() string <span class="cov8" title="1">{
        var msg string

        if len(m.ServiceOfferings) == 0 </span><span class="cov8" title="1">{
                msg = "There are no service offerings."
        }</span> else<span class="cov8" title="1"> if len(m.ServiceOfferings) == 1 </span><span class="cov8" title="1">{
                msg = "One service offering."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d service offerings.", len(m.ServiceOfferings))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// IsEmpty whether the structure is empty
func (m *Marketplace) IsEmpty() bool <span class="cov8" title="1">{
        return len(m.ServiceOfferings) == 0
}</span>

// TableData returns the data to populate a table
func (m *Marketplace) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"Name", "Plans", "Description", "Broker ID"}

        for _, v := range m.ServiceOfferings </span><span class="cov8" title="1">{
                plans := make([]string, len(v.Plans))
                for i, v := range v.Plans </span><span class="cov8" title="1">{
                        plans[i] = v.Name
                }</span>

                <span class="cov8" title="1">row := []string{v.Name, strings.Join(plans, ", "), v.Description, v.BrokerID}
                result.Data = append(result.Data, row)</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ServiceOfferings wraps an array of service offerings
type ServiceOfferings struct {
        ServiceOfferings []ServiceOffering `json:"items" yaml:"items"`
}

// Message title of the table
func (so *ServiceOfferings) Message() string <span class="cov8" title="1">{
        var msg string

        if len(so.ServiceOfferings) == 0 </span><span class="cov8" title="1">{
                msg = "There are no service offerings."
        }</span> else<span class="cov8" title="1"> if len(so.ServiceOfferings) == 1 </span><span class="cov8" title="1">{
                msg = "One service offering."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d service offerings.", len(so.ServiceOfferings))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// IsEmpty whether the structure is empty
func (so *ServiceOfferings) IsEmpty() bool <span class="cov8" title="1">{
        return len(so.ServiceOfferings) == 0
}</span>

// TableData returns the data to populate a table
func (so *ServiceOfferings) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"ID", "Name", "Description", "Broker ID", "Ready", "Labels"}

        for _, v := range so.ServiceOfferings </span><span class="cov8" title="1">{
                row := []string{v.ID, v.Name, v.Description, v.BrokerID, strconv.FormatBool(v.Ready), formatLabels(v.Labels)}
                result.Data = append(result.Data, row)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "encoding/json"
        "fmt"
        "github.com/Peripli/service-manager/pkg/instance_sharing"
        "github.com/Peripli/service-manager/pkg/types"
        "github.com/tidwall/gjson"
        "strconv"
)

// ServicePlan defines the data of a service plan.
type ServicePlan struct {
        ID          string `json:"id,omitempty" yaml:"id,omitempty"`
        Name        string `json:"name,omitempty" yaml:"name,omitempty"`
        Description string `json:"description,omitempty" yaml:"description,omitempty"`
        CreatedAt   string `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        UpdatedAt   string `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`

        CatalogID     string `json:"catalog_id,omitempty" yaml:"catalog_id,omitempty"`
        CatalogName   string `json:"catalog_name,omitempty" yaml:"catalog_name,omitempty"`
        Free          bool   `json:"free,omitempty" yaml:"free,omitempty"`
        Bindable      bool   `json:"bindable,omitempty" yaml:"bindable,omitempty"`
        PlanUpdatable bool   `json:"plan_updateable,omitempty" yaml:"plan_updateable,omitempty"`

        Metadata json.RawMessage `json:"metadata,omitempty" yaml:"-"`
        Schemas  json.RawMessage `json:"schemas,omitempty" yaml:"-"`

        ServiceOfferingID string       `json:"service_offering_id,omitempty" yaml:"service_offering_id,omitempty"`
        Labels            types.Labels `json:"labels,omitempty" yaml:"labels,omitempty"`
        Ready             bool         `json:"ready,omitempty" yaml:"ready,omitempty"`
}

// Message title of the table
func (sp *ServicePlan) Message() string <span class="cov0" title="0">{
        return ""
}</span>

// IsEmpty whether the structure is empty
func (sp *ServicePlan) IsEmpty() bool <span class="cov0" title="0">{
        return false
}</span>

// TableData returns the data to populate a table
func (sp *ServicePlan) TableData() *TableData <span class="cov0" title="0">{
        result := &amp;TableData{}
        result.Headers = []string{"Plan", "Description", "ID"}

        row := []string{sp.Name, sp.Description, sp.ID}
        result.Data = append(result.Data, row)

        return result
}</span>

// ServicePlansForOffering wraps an array of service plans for marketplace command
type ServicePlansForOffering struct {
        ServicePlans []ServicePlan `json:"items" yaml:"items"`
}

// Message title of the table
func (sp *ServicePlansForOffering) Message() string <span class="cov8" title="1">{
        var msg string

        if len(sp.ServicePlans) == 0 </span><span class="cov8" title="1">{
                msg = "There are no service plans for this service offering."
        }</span> else<span class="cov8" title="1"> if len(sp.ServicePlans) == 1 </span><span class="cov8" title="1">{
                msg = "One service plan for this service offering."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d service plans for this service offering.", len(sp.ServicePlans))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// IsEmpty whether the structure is empty
func (sp *ServicePlansForOffering) IsEmpty() bool <span class="cov8" title="1">{
        return len(sp.ServicePlans) == 0
}</span>

// TableData returns the data to populate a table
func (sp *ServicePlansForOffering) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"Plan", "Description", "ID"}

        for _, v := range sp.ServicePlans </span><span class="cov8" title="1">{
                row := []string{v.Name, v.Description, v.ID}
                result.Data = append(result.Data, row)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ServicePlans wraps an array of service plans
type ServicePlans struct {
        ServicePlans []ServicePlan `json:"items" yaml:"items"`
}

// Message title of the table
func (sp *ServicePlans) Message() string <span class="cov8" title="1">{
        var msg string

        if len(sp.ServicePlans) == 0 </span><span class="cov8" title="1">{
                msg = "There are no service plans."
        }</span> else<span class="cov8" title="1"> if len(sp.ServicePlans) == 1 </span><span class="cov8" title="1">{
                msg = "One service plan."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d service plans.", len(sp.ServicePlans))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// IsEmpty whether the structure is empty
func (sp *ServicePlans) IsEmpty() bool <span class="cov8" title="1">{
        return len(sp.ServicePlans) == 0
}</span>

// TableData returns the data to populate a table
func (sp *ServicePlans) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"ID", "Name", "Shareable", "Description", "Offering ID", "Ready", "Labels"}

        for _, v := range sp.ServicePlans </span><span class="cov8" title="1">{
                row := []string{v.ID, v.Name, strconv.FormatBool(v.ShareableProperty()), v.Description, v.ServiceOfferingID, strconv.FormatBool(v.Ready), formatLabels(v.Labels)}
                result.Data = append(result.Data, row)
        }</span>

        <span class="cov8" title="1">return result</span>
}

func (sp *ServicePlan) ShareableProperty() bool <span class="cov8" title="1">{
        if sp.Metadata == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return gjson.GetBytes(sp.Metadata, instance_sharing.SupportsInstanceSharingKey).Bool()</span>

}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "fmt"
        "github.com/Peripli/service-manager/pkg/types"
        "strings"
)

// TableData holds data for table header and content
type TableData struct {
        Headers  []string
        Data     [][]string
        Vertical bool
}

// String implements Stringer interface
func (table *TableData) String() string <span class="cov8" title="1">{
        if table.Vertical </span><span class="cov8" title="1">{
                return table.verticalTable()
        }</span>
        <span class="cov8" title="1">return table.horizontalTable()</span>
}

func (table *TableData) horizontalTable() string <span class="cov8" title="1">{
        output := ""
        if len(table.Data) == 0 </span><span class="cov0" title="0">{
                return output
        }</span>

        // get fields lengths
        <span class="cov8" title="1">fieldLen := table.fieldsLen()

        for i, header := range table.Headers </span><span class="cov8" title="1">{
                output += pad(header, fieldLen[i])
        }</span>
        <span class="cov8" title="1">output += "\n"

        for i := range table.Headers </span><span class="cov8" title="1">{
                output += line(fieldLen[i]-2) + "  "
        }</span>
        <span class="cov8" title="1">output += "\n"

        for _, row := range table.Data </span><span class="cov8" title="1">{
                for i, cell := range row </span><span class="cov8" title="1">{
                        output += pad(cell, fieldLen[i])
                }</span>
                <span class="cov8" title="1">output += "\n"</span>
        }

        <span class="cov8" title="1">return output</span>
}

func (table *TableData) verticalTable() string <span class="cov8" title="1">{
        output := ""
        if len(table.Data) == 0 </span><span class="cov0" title="0">{
                return output
        }</span>

        <span class="cov8" title="1">headerLen := table.headerLen()
        maxHeaderLen := max(headerLen...)

        dataLen := table.dataLen()
        maxDataLen := max(dataLen...)

        for i, header := range table.Headers </span><span class="cov8" title="1">{
                output += "| "
                output += pad(header, maxHeaderLen)
                output += "| "
                for _, row := range table.Data </span><span class="cov8" title="1">{
                        output += pad(row[i], maxDataLen)
                        output += "| "
                }</span>
                <span class="cov8" title="1">output += "\n"</span>
        }

        <span class="cov8" title="1">return output</span>
}

func (table *TableData) headerLen() []int <span class="cov8" title="1">{
        fieldLen := make([]int, len(table.Headers))
        for i, header := range table.Headers </span><span class="cov8" title="1">{
                if fieldLen[i] &lt; len(header)+2 </span><span class="cov8" title="1">{
                        fieldLen[i] = len(header) + 2
                }</span>
        }
        <span class="cov8" title="1">return fieldLen</span>
}

func (table *TableData) dataLen() []int <span class="cov8" title="1">{
        fieldLen := make([]int, len(table.Headers))
        for _, row := range table.Data </span><span class="cov8" title="1">{
                for i, cell := range row </span><span class="cov8" title="1">{
                        if fieldLen[i] &lt; len(cell)+2 </span><span class="cov8" title="1">{
                                fieldLen[i] = len(cell) + 2
                        }</span>
                }
        }

        <span class="cov8" title="1">return fieldLen</span>
}

func (table *TableData) fieldsLen() []int <span class="cov8" title="1">{
        fieldLen := make([]int, len(table.Headers))
        headerLen := table.headerLen()
        dataLen := table.dataLen()

        for i := range fieldLen </span><span class="cov8" title="1">{
                fieldLen[i] = max(headerLen[i], dataLen[i])
        }</span>
        <span class="cov8" title="1">return fieldLen</span>
}

func pad(s string, p int) string <span class="cov8" title="1">{
        result := s

        for len(result) &lt; p </span><span class="cov8" title="1">{
                result += " "
        }</span>

        <span class="cov8" title="1">return result</span>
}

func line(p int) string <span class="cov8" title="1">{
        result := ""

        for len(result) &lt; p </span><span class="cov8" title="1">{
                result += "-"
        }</span>

        <span class="cov8" title="1">return result</span>
}

func max(arr ...int) int <span class="cov8" title="1">{
        tmp := arr[0]
        for _, i := range arr </span><span class="cov8" title="1">{
                if i &gt; tmp </span><span class="cov8" title="1">{
                        tmp = i
                }</span>
        }
        <span class="cov8" title="1">return tmp</span>
}

func formatNullableBool(val *bool) string<span class="cov8" title="1">{
        if val == nil </span><span class="cov8" title="1">{
                return "false"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%v", *val)</span>
}
func formatLabels(labels types.Labels) string <span class="cov8" title="1">{
        formattedLabels := make([]string, 0, len(labels))
        for i, v := range labels </span><span class="cov0" title="0">{
                formattedLabels = append(formattedLabels, i+"="+strings.Join(v, ","))
        }</span>
        <span class="cov8" title="1">return strings.Join(formattedLabels, " ")</span>
}

func formatLastOp(operation *types.Operation) string <span class="cov0" title="0">{
        if operation.State != types.FAILED </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s %s", operation.Type, operation.State)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s %s %s", operation.Type, operation.State, operation.Errors)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
 * Copyright 2018 The Service Manager Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package types

import (
        "fmt"
        "github.com/Peripli/service-manager/pkg/types"
        "strconv"
)

// Visibility defines the data of a visibility
type Visibility struct {
        ID            string       `json:"id,omitempty" yaml:"id,omitempty"`
        PlatformID    string       `json:"platform_id,omitempty" yaml:"platform_id,omitempty"`
        ServicePlanID string       `json:"service_plan_id,omitempty" yaml:"service_plan_id,omitempty"`
        CreatedAt     string       `json:"created_at,omitempty" yaml:"created_at,omitempty"`
        UpdatedAt     string       `json:"updated_at,omitempty" yaml:"updated_at,omitempty"`
        Labels        types.Labels `json:"labels,omitempty" yaml:"labels,omitempty"`
        Ready         bool         `json:"ready,omitempty" yaml:"ready,omitempty"`
}

// Message title of the table
func (v *Visibility) Message() string <span class="cov8" title="1">{
        return ""
}</span>

// IsEmpty whether the struct is empty
func (v *Visibility) IsEmpty() bool <span class="cov8" title="1">{
        return false
}</span>

// TableData returns the data to populate a table
func (v *Visibility) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"ID", "Platform ID", "Service Plan ID", "Labels"}

        row := []string{v.ID, v.PlatformID, v.ServicePlanID, formatLabels(v.Labels)}
        result.Data = append(result.Data, row)

        return result
}</span>

// Visibilities wraps an array of Visibilities
type Visibilities struct {
        Visibilities []Visibility `json:"items,omitempty" yaml:"items,omitempty"`
}

// IsEmpty whether the structure is empty
func (v *Visibilities) IsEmpty() bool <span class="cov8" title="1">{
        return len(v.Visibilities) == 0
}</span>

// Message title of the table
func (v *Visibilities) Message() string <span class="cov8" title="1">{
        var msg string

        if len(v.Visibilities) == 0 </span><span class="cov8" title="1">{
                msg = "No visibilities registered."
        }</span> else<span class="cov8" title="1"> if len(v.Visibilities) == 1 </span><span class="cov8" title="1">{
                msg = "One visibility registered."
        }</span> else<span class="cov8" title="1"> {
                msg = fmt.Sprintf("%d visibilities registered.", len(v.Visibilities))
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// TableData returns the data to populate a table
func (v *Visibilities) TableData() *TableData <span class="cov8" title="1">{
        result := &amp;TableData{}
        result.Headers = []string{"ID", "Platform ID", "Service Plan ID", "Ready", "Labels"}

        for _, visibility := range v.Visibilities </span><span class="cov8" title="1">{
                row := []string{visibility.ID, visibility.PlatformID, visibility.ServicePlanID, strconv.FormatBool(visibility.Ready), formatLabels(visibility.Labels)}
                result.Data = append(result.Data, row)
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
